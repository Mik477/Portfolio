function r(t){const e=Math.max(1,t.currentTimeMs-t.lastTimeMs);return(t.currentY-t.lastY)/e}function u(t){return t.absDy>t.dragThresholdPx||t.absDx>t.dragThresholdPx?t.absDx>t.absDy*1.5&&t.absDx>t.horizTolerancePx*.5?{intent:"horizontal",startDragging:!1}:t.absDy>t.absDx*.7?{intent:"vertical",startDragging:!0}:{intent:null,startDragging:!1}:{intent:null,startDragging:!1}}function c(t){return t.absDx>t.horizTolerancePx}function o(t){return t.atBoundary?t.offsetPx*t.rubberBandFactor*(1-Math.abs(t.offsetPx)/(t.viewportHeightPx*2)):t.offsetPx}function f(t){const e=t.dragOffsetPx*t.maxVisualFeedback,n=o({offsetPx:e,atBoundary:t.atBoundary,rubberBandFactor:t.rubberBandFactor,viewportHeightPx:t.viewportHeightPx}),i=n/t.viewportHeightPx;return{effectiveOffsetPx:n,progress:i}}function s(t){const e=Math.abs(t.dragOffsetPx)/t.viewportHeightPx,n=Math.abs(t.finalVelocityPxPerMs)*t.momentumMultiplier;return n>t.minMomentumDistancePx&&Math.abs(t.finalVelocityPxPerMs)>t.velocityThresholdPxPerMs?{shouldNavigate:!0,direction:t.dragOffsetPx<0?1:-1,dragPercent:e,momentumDistancePx:n}:e>t.snapThreshold?{shouldNavigate:!0,direction:t.dragOffsetPx<0?1:-1,dragPercent:e,momentumDistancePx:n}:{shouldNavigate:!1,direction:0,dragPercent:e,momentumDistancePx:n}}export{f as a,s as b,r as c,u as d,c as s};
