--- START OF FILE src\app.css ---
/* src/app.css */
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300..700&display=swap');

:root {
    --keyboard-background-2: #09090b;
    --keyboard-background-3: #232b34;
    --keyboard-contrast: #fff;
    --keyboard-key-base-size: 4rem;
}

@keyframes fade-in-bottom {
    0% {
        transform: translateY(50px) rotateY(0.05turn) rotateX(-0.1turn);
        opacity: 0;
        filter: blur(16px);
    }
    to {
        transform: translateY(0) rotateY(0.05turn) rotateX(-0.1turn);
        opacity: 1;
        filter: blur(0);
    }
}

/* This is the style we are moving from +layout.svelte */
body {
    background-color: rgb(9 9 11);
    color: rgb(245 245 247);
}

/* Body scroll control: home page (immersive sections) uses a fixed viewport stack; legal and other content pages must scroll */
/* Home immersive experience locks body scroll inline via layout; other pages default to auto */
/* Allow vertical scrolling by default (home page script will set body.style.overflow='hidden' when needed) */
body {
    overflow-y: auto;
}


@media (max-width: 768px) {
    :root { --keyboard-key-base-size: 3.5rem; }
}
@media (max-width: 640px) {
    :root { --keyboard-key-base-size: 3rem; }
}
--- END OF FILE src\app.css ---

--- START OF FILE src\app.d.ts ---
// src/app.d.ts
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

--- END OF FILE src\app.d.ts ---

--- START OF FILE src\app.html ---
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
		<!-- FIX: Add Google Fonts import for Source Code Pro -->
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@300;700&display=swap" rel="stylesheet">
		<style>
			/* Global Resets and Viewport Styling */
			html, body {
				margin: 0;
				padding: 0;
				height: 100%;
				width: 100%;
				/* NOTE: Removed global overflow:hidden to allow legal/content pages to scroll.
				   The immersive home page now locks scroll explicitly via +layout.svelte (document.body.style.overflow = 'hidden'). */
				overflow-x: hidden; /* Still prevent horizontal scrollbar flashes */
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
			}

			/* Ensure SvelteKit's main div also takes full height if needed, though 'display: contents' usually negates its layout impact */
			body > div[style="display: contents"] {
				height: 100%; 
			}
		</style>
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
--- END OF FILE src\app.html ---

--- START OF FILE src\lib\index.ts ---
// place files you want to import through the `$lib` alias in this folder.

--- END OF FILE src\lib\index.ts ---

--- START OF FILE src\lib\components\AboutImageEffect.svelte ---
<!-- src/lib/components/AboutImageEffect.svelte -->
<script context="module" lang="ts">
  // This allows other components to know about and call them safely.
  export type AboutImageEffectInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    initializeEffect?: () => Promise<void>;
    onTransitionComplete?: () => void;
    onUnload?: () => void; // <<< ADDED
  };
</script>

<script lang="ts">
  import { onMount, onDestroy, tick } from 'svelte';
  import * as THREE from 'three';
  import { gsap } from 'gsap';
    import { prefersReducedMotion as prm } from '$lib/stores/renderProfile';
  import { BloomEffect } from '$lib/three/BloomEffect';

  export let imageUrl: string;
  export let fadeInDelay: number = 250;
    // Mobile-optimized mode controls
    export let mobileMode: boolean = false;
    // Shift image slightly on mobile (percentage of image width; 50=center)
    export let mobileImageOffsetX: number = 58;
    export let mobileSymbolCount: number = 150; // reduced default number of active symbols
    export let mobileSymbolLifetime: { min: number; max: number } = { min: 4, max: 30 };
    export let mobileSymbolSize: { min: number; max: number } = { min: 12, max: 22 };
    // Debug logging
    export let debug: boolean = true;
            // Grouped configuration for easy editing (overrides above if provided)
            type MobileConfig = {
                count: number;
                lifetime: { min: number; max: number };
                size: { min: number; max: number };
                amplitude: { min: number; max: number };
                speedFactor: number; // multiplier on derived speed
                fadeStartScreenFraction: number; // when to start fading relative to screen width (e.g., 0.5)
                fadeStartLifetimeFraction: number; // when to start fading relative to particle lifetime (e.g., 0.5)
                fadeInDuration: number; // seconds
                fadeOutDuration: number; // seconds
                rampDuration: number; // seconds to reach full count
            };
            export let mobileConfig: Partial<MobileConfig> | undefined = undefined;

  let mainContainer: HTMLDivElement;
  let imageElement: HTMLImageElement;
  let particleOverlayElement: HTMLDivElement;

  let effectInstance: DigitalDecayEffect | null = null;
  let isInitialized = false;
    let fadeInTimeoutId: number | undefined;
        let _boundVisibilityHandler: (() => void) | null = null;
        let _boundFocusHandler: (() => void) | null = null;
        let _boundBlurHandler: (() => void) | null = null;
        let _boundPageShowHandler: ((e: Event) => void) | null = null;
        let _boundPageHideHandler: ((e: Event) => void) | null = null;

  // --- Component API ---

  export async function initializeEffect() {
    if (isInitialized) return;
    await tick();
    if (!particleOverlayElement || !imageElement) return;
                effectInstance = new DigitalDecayEffect(particleOverlayElement, imageElement, {
            mobileMode,
            mobileParams: {
                            count: Math.max(50, Math.floor(mobileConfig?.count ?? mobileSymbolCount)),
                            lifetime: mobileConfig?.lifetime ?? mobileSymbolLifetime,
                            size: mobileConfig?.size ?? mobileSymbolSize,
                            amplitude: mobileConfig?.amplitude ?? { min: 3, max: 10 },
                            speedFactor: mobileConfig?.speedFactor ?? 0.8,
                            fadeStartScreenFraction: mobileConfig?.fadeStartScreenFraction ?? 0.5,
                            fadeStartLifetimeFraction: mobileConfig?.fadeStartLifetimeFraction ?? 0.5,
                            fadeInDuration: mobileConfig?.fadeInDuration ?? 0.05,
                            fadeOutDuration: mobileConfig?.fadeOutDuration ?? 0.8,
                            rampDuration: mobileConfig?.rampDuration ?? 15.0
                        },
                        debug
        });
        if (debug) {
            console.log('[AboutImageEffect] initializeEffect()', {
                mobileMode,
                mobileSymbolCount,
                mobileSymbolLifetime,
                mobileSymbolSize,
                overlayEl: !!particleOverlayElement,
                imageEl: !!imageElement
            });
        }
    effectInstance.init();
    isInitialized = true;
  }

  export async function onEnterSection() {
    if (fadeInTimeoutId) clearTimeout(fadeInTimeoutId);

    fadeInTimeoutId = window.setTimeout(() => {
      gsap.to(mainContainer, { autoAlpha: 1, duration: 1.2, ease: 'power2.inOut' });
    }, fadeInDelay);
  }
  
    export function onTransitionComplete() {
          if (debug) console.log('[AboutImageEffect] onTransitionComplete() called. isInitialized:', isInitialized, 'hasInstance:', !!effectInstance);
          if ($prm) { if (debug) console.log('[AboutImageEffect] reduced-motion active, skipping start'); return; }
        if (!effectInstance && !isInitialized) {
            // Safety: ensure initialization happened even if preload didn't call it
            // Non-blocking; we'll poll next frame to start
            initializeEffect();
        }
        const kickoff = () => {
            if (effectInstance) {
            if (debug) console.log('[AboutImageEffect] kickoff start, calling onWindowResize() + start()');
                effectInstance.onWindowResize();
                effectInstance.start();
            } else {
                requestAnimationFrame(kickoff);
            }
        };
        kickoff();
    }

  export function onLeaveSection() {
    if (fadeInTimeoutId) clearTimeout(fadeInTimeoutId);
    
    if (effectInstance) {
      effectInstance.beginLeaveAnimation();
      gsap.killTweensOf(mainContainer);
      gsap.set(mainContainer, { autoAlpha: 0 });
    }
  }

  // --- NEW Component API Method ---
  export function onUnload() {
    if (effectInstance) {
      console.log('AboutImageEffect: Unloading and disposing Three.js resources.');
      effectInstance.dispose();
      effectInstance = null;
    }
    // Reset the initialization flag so it can be re-initialized if needed.
    isInitialized = false;
  }
  
  // --- Lifecycle ---

    onMount(() => {
        // Initialization is fully deferred to the Animation API.
        const handler = () => {
            if (document.visibilityState === 'visible') {
                console.log('[AboutImageEffect][COMP] visibilitychange -> visible: init + enter + kickoff');
                // Ensure the effect is initialized; prefer a hard restart to avoid stuck opacity/pipeline
                initializeEffect();
                onEnterSection();
                if (effectInstance && (effectInstance as any).restart) {
                    (effectInstance as any).restart();
                } else {
                    onTransitionComplete();
                }
            } else {
                console.log('[AboutImageEffect][COMP] visibilitychange -> hidden');
            }
        };
        document.addEventListener('visibilitychange', handler);
        _boundVisibilityHandler = handler;

        const onFocus = () => console.log('[AboutImageEffect][COMP] window focus');
        const onBlur = () => console.log('[AboutImageEffect][COMP] window blur');
        const onPageShow = (e: Event) => console.log('[AboutImageEffect][COMP] pageshow (persisted=', (e as any).persisted, ')');
        const onPageHide = (e: Event) => console.log('[AboutImageEffect][COMP] pagehide (persisted=', (e as any).persisted, ')');
        window.addEventListener('focus', onFocus);
        window.addEventListener('blur', onBlur);
        window.addEventListener('pageshow', onPageShow);
        window.addEventListener('pagehide', onPageHide);
        _boundFocusHandler = onFocus;
        _boundBlurHandler = onBlur;
        _boundPageShowHandler = onPageShow;
        _boundPageHideHandler = onPageHide;
    });

  onDestroy(() => {
    // onDestroy should also ensure cleanup, acting as a final safeguard.
    onUnload();
    if (fadeInTimeoutId) clearTimeout(fadeInTimeoutId);
        if (_boundVisibilityHandler) {
            document.removeEventListener('visibilitychange', _boundVisibilityHandler);
            _boundVisibilityHandler = null;
        }
    if (_boundFocusHandler) { window.removeEventListener('focus', _boundFocusHandler); _boundFocusHandler = null; }
    if (_boundBlurHandler) { window.removeEventListener('blur', _boundBlurHandler); _boundBlurHandler = null; }
    if (_boundPageShowHandler) { window.removeEventListener('pageshow', _boundPageShowHandler); _boundPageShowHandler = null; }
    if (_boundPageHideHandler) { window.removeEventListener('pagehide', _boundPageHideHandler); _boundPageHideHandler = null; }
  });

  // --- DigitalDecayEffect Class ---

    interface GridCell { state: number; timer: number; opacity: number; }
    interface Particle { index: number; active: boolean; originalPos: THREE.Vector2; amplitude: number; timeOffset: number; speed: number; lifetime: number; age: number; size: number; color: THREE.Color; symbolIndex: number; gridCellIndex: number; lastSymbolChange: number; symbolChangeInterval: number; }
    // replaced with extended MobileParams below
                type MobileParams = {
                    count: number;
                    lifetime: { min: number; max: number };
                    size: { min: number; max: number };
                    amplitude: { min: number; max: number };
                    speedFactor: number;
                    fadeStartScreenFraction: number;
                    fadeStartLifetimeFraction: number;
                    fadeInDuration: number;
                    fadeOutDuration: number;
                    rampDuration: number;
                };

    class DigitalDecayEffect {
    private overlayContainer: HTMLElement;
    private image: HTMLImageElement;
    private clock: THREE.Clock | null = null;
    private animationFrameId: number | null = null;
    private debug = false;
    private frameCount = 0;
    
    private width = 0;   // CSS width of overlay container
    private height = 0;  // CSS height of overlay container
    private scene!: THREE.Scene;
    private camera!: THREE.OrthographicCamera;
    private renderer!: THREE.WebGLRenderer;
    private bloomEffect!: BloomEffect;

    // ================= Symbol Scaling System (hero parity) =================
    private readonly SCREEN_SIZES = {
        mobile: { maxWidth: 640 },
        tablet: { minWidth: 641, maxWidth: 900 },
        laptop: { minWidth: 901, maxWidth: 1200 },
        desktop: { minWidth: 1201, maxWidth: 1800 },
        large: { minWidth: 1801, maxWidth: 2900 },
        ultrawide: { minWidth: 2901 }
    } as const;
    private currentScreenSizeType: 'mobile' | 'tablet' | 'laptop' | 'desktop' | 'large' | 'ultrawide' = 'desktop';
    private readonly SCREEN_SYMBOL_RATIO: Record<'mobile' | 'tablet' | 'laptop' | 'desktop' | 'large' | 'ultrawide', number> = {
        mobile: 1.00,
        tablet: 1.00,
        laptop: 1.00,
        desktop: 1.04,
        large: 0.8,
        ultrawide: 1.12
    };
    private globalSymbolSizeMul: number = 1.0;
    private referenceContainerHeight: number | null = null;
    private lastMeasuredContainerHeight: number = 0;
    private baseSizeFactors: Float32Array | null = null;
    private lastSpawnComputedSize: number = 0;
    private lastSpawnRawBase: number = 0;
    private lastSpawnScreenRatio: number = 1;
    private lastSpawnScale: number = 1;
    // Density & GPU handling additions
    private enableDensityCompensation: boolean = true;
    private densityExponent: number = 0.45; // 0=no effect, 1=linear inverse DPR scaling
    private densityBaseDPR: number = 1.0; // reference baseline DPR
    private cachedDPR: number = (typeof window !== 'undefined' ? window.devicePixelRatio : 1) || 1;
    private gpuPointSizeRange: [number, number] | null = null; // queried from GL
    private lastClampOccurred: boolean = false;

    // Internal resolution scaling (DRS)
    private internalScale: number = 1.0; // dynamic internal resolution scale
    private readonly MAX_INTERNAL_DIM = 1440; // cap for larger dimension
    private readonly SCALE_FLOOR = 0.6;
    private readonly SCALE_CEIL = 1.0;
    private frameTimes: number[] = [];
    private readonly FRAME_WINDOW = 50;
    private readonly HIGH_THRESHOLD = 19.5; // ms (≈51 FPS) -> downscale when slower than this
    private readonly LOW_THRESHOLD = 16.7;  // ms (≈60 FPS) -> upscale when consistently faster
    private scaleCooldown = 0;
    private readonly SCALE_COOLDOWN_FRAMES = 45;
    private avgFrameMs = 0;
    private metricsEnabled = false;
    private isPageVisible = true;
    private boundOnVisibilityChange = this.onVisibilityChange.bind(this);

    // Mobile mode
    private isMobileMode = false;
    private mobileParams: MobileParams = {
                count: 100,
                lifetime: { min: 1, max: 4 },
                size: { min: 12, max: 22 },
                amplitude: { min: 8, max: 18 },
                speedFactor: 0.8,
                fadeStartScreenFraction: 0.5,
                fadeStartLifetimeFraction: 0.5,
                fadeInDuration: 0.01,
                fadeOutDuration: 0.6,
                rampDuration: 10.0
            };
            private rampTimer = 0;

    // =========================================================================
    // == EFFECT PARAMETERS ==
    // =========================================================================
    
    // --- Grid & Spawning ---
    private readonly CELL_SIZE = 9;                         // Size of each grid cell over the image.
    private readonly BASE_CHANCE = 0.003;                   // Base probability for a cell to become active per frame.
    private readonly PROBABILITY_DECAY_FACTOR = 9;          // How quickly the spawn chance decreases from left to right. Higher value = more concentrated on the left.
    private readonly SPAWN_AREA_WIDTH = 0.5;                // Percentage of the image width (from the left) where particles can spawn.
    private readonly REGENERATION_TIME = 1.5;               // Seconds a grid cell must wait after a particle dies before it can spawn another.
    private readonly ONSET_DURATION = 5.0;      //Was 2            // Seconds over which the particle spawning ramps up to full intensity.
    
    // --- Particle Pool & Lifetime ---
    private readonly MAX_ACTIVE_PARTICLES = 2000;           // Maximum number of particles that can be on screen at once.
    private readonly PARTICLE_LIFETIME = { min: 4, max: 8 };// Min/max seconds a particle will exist.
    
    // --- Particle Movement & Appearance ---
    private readonly PARTICLE_SPEED = 0.25;                 // Base speed multiplier for horizontal travel.
    private readonly PARTICLE_SPEED_VARIATION = 0.5;        // Randomness in particle speed (e.g., 0.5 = +/- 50%).
    private readonly AMPLITUDE = { min: 90, max: 210 };     // Min/max horizontal distance a particle will travel over its lifetime.
    private readonly SYMBOL_CHANGE_INTERVAL = 2;          // Base time in seconds before a particle's symbol character changes.
    private readonly SYMBOL_CHANGE_VARIATION = 0.95;         // Randomness in the symbol change interval.
    
    // --- Particle Opacity & Fading ---
    private readonly PARTICLE_FADE_IN_DURATION = 0.4;       // Seconds for a particle to fade in.
    private readonly PARTICLE_FADEOUT_DURATION = 0.3;       // Seconds for a particle to fade out at the end of its life.
    private readonly PARTICLE_BASE_OPACITY = 0.9;           // The base opacity multiplied into the final particle color.
    private readonly BLACKOUT_FADE_DURATION = 0.35;         // Seconds for the black squares to fade in/out.
    
    // --- Visuals & Colors ---
    private readonly SYMBOLS = [ '日', '〇', 'ハ', 'ミ', 'ヒ', 'ウ', 'シ', 'ナ', 'モ', 'サ', 'ワ', 'ツ', 'オ', 'リ', 'ア', 'ホ', 'テ', 'マ', 'ケ', 'メ', 'エ', 'カ', 'キ', 'ム', 'ユ', 'ラ', 'セ', 'ネ', 'ヲ', 'イ', 'ク', 'コ', 'ソ', 'タ', 'チ', 'ト', 'ノ', 'フ', 'ヘ', 'ヤ', 'ヨ', 'ル', 'レ', 'ロ', '∆', 'δ', 'ε', 'ζ', 'η', 'θ', '∃', '∄', '∅', 'Д' ];
    private readonly SYMBOL_COLORS = [ new THREE.Color(0.0, 0.95, 0.05), new THREE.Color(0.0, 1.0, 0.0), new THREE.Color(0.3, 1.0, 0.3) ];
    private readonly BLACKOUT_COLOR = new THREE.Color('#09090b');
    
    // --- State & Control ---
    private STATE = { IDLE: 0, ACTIVE: 1, REGENERATING: 2 };
    private isFadingOut = false;
    private fadeOutTimer = 0;
    private onsetTimer = 0;
    private readonly SHUTDOWN_CLEANUP_DELAY = 1.0;          // Seconds after leave animation starts to fully stop the rAF loop.

    // =========================================================================
    
    private grid: { cols: number; rows: number; cells: GridCell[] } = { cols: 0, rows: 0, cells: [] };
    private particles: { pool: Particle[]; active: Map<number, Particle> } = { pool: [], active: new Map() };
    private imageRect: DOMRect | null = null;
    private particleSystem!: THREE.Points<THREE.BufferGeometry, THREE.ShaderMaterial>;
    private blackoutMesh!: THREE.InstancedMesh;
    private symbolsTexture!: THREE.CanvasTexture;
    private boundOnWindowResize = this.onWindowResize.bind(this);

    constructor(overlayContainer: HTMLElement, image: HTMLImageElement, opts?: { mobileMode?: boolean; mobileParams?: MobileParams; debug?: boolean }) {
        this.overlayContainer = overlayContainer;
        this.image = image;
        if (opts?.mobileMode) this.isMobileMode = true;
        if (opts?.mobileParams) this.mobileParams = { ...this.mobileParams, ...opts.mobileParams };
        if (opts?.debug) this.debug = !!opts.debug;
    }

    private dlog(...args: any[]) { if (this.debug) console.log('[DigitalDecayEffect]', ...args); }

    public init(): void {
      if (this.image.complete && this.image.naturalHeight !== 0) {
          this.dlog('init(): image already loaded; setting up scene');
          this.setupSceneOnce();
      } else {
          this.dlog('init(): waiting for image load...');
          this.image.onload = () => { this.dlog('image onload fired'); this.setupSceneOnce(); };
      }
    }

    private setupSceneOnce(): void {
        this.setupScene();
    this.dlog('setupSceneOnce(): dimensions', { width: this.width, height: this.height });
    this.bloomEffect = new BloomEffect(this.renderer, this.scene, this.camera, this.width, this.height);
    this.createSymbolTexture();
    if (!this.isMobileMode) this.createBlackoutMesh();
    this.createParticleSystem();

    // Ensure point size is normalized to CSS pixels initially
    this.updatePointScale(this.width, this.height);
    this.dlog('setupSceneOnce(): point scale set, renderer size', this.renderer.getSize(new THREE.Vector2()).toArray(), 'css', { w: (this.renderer.domElement.style.width), h: (this.renderer.domElement.style.height) });

        if (this.bloomEffect && this.bloomEffect.composer) {
            this.bloomEffect.composer.render(0.01);
        }

    window.addEventListener('resize', this.boundOnWindowResize);
    document.addEventListener('visibilitychange', this.boundOnVisibilityChange);
        this.dlog('setupSceneOnce(): listeners attached, mobileMode=', this.isMobileMode);
    }
    
    private animate(): void {
    this.animationFrameId = requestAnimationFrame(() => this.animate());
        if (!this.clock) return;
        if (!this.isMobileMode && !this.imageRect) return;
    this.frameCount++;

                const rawDt = this.clock.getDelta();
        // clamp large deltas (e.g., after tab becomes visible again) to avoid jumps
        const deltaTime = Math.min(rawDt, 0.05);
        if (this.isPageVisible) {
            const frameMs = deltaTime * 1000;
            this.frameTimes.push(frameMs);
            if (this.frameTimes.length > this.FRAME_WINDOW) this.frameTimes.shift();
            if (this.frameTimes.length === this.FRAME_WINDOW) {
                this.avgFrameMs = this.frameTimes.reduce((a,b)=>a+b,0)/this.frameTimes.length;
                if (this.scaleCooldown > 0) this.scaleCooldown--;
                let changed = false;
                if (this.scaleCooldown === 0) {
                    if (this.avgFrameMs > this.HIGH_THRESHOLD && this.internalScale > this.SCALE_FLOOR) {
                        this.internalScale = Math.max(this.SCALE_FLOOR, +(this.internalScale - 0.1).toFixed(2));
                        changed = true;
                    } else if (this.avgFrameMs < this.LOW_THRESHOLD && this.internalScale < this.SCALE_CEIL) {
                        this.internalScale = Math.min(this.SCALE_CEIL, +(this.internalScale + 0.1).toFixed(2));
                        changed = true;
                    }
                    if (changed) { this.scaleCooldown = this.SCALE_COOLDOWN_FRAMES; this.onWindowResize(); }
                }
            }
        }

        if (this.isFadingOut) {
            this.fadeOutTimer += deltaTime;
            if (this.isMobileMode) this.updateParticlesMobile(deltaTime); else this.updateParticles(deltaTime);
            const fadeProgress = Math.max(0, 1.0 - (this.fadeOutTimer / this.PARTICLE_FADEOUT_DURATION));
            this.particleSystem.material.uniforms.globalOpacity.value = fadeProgress;

            if (this.fadeOutTimer >= this.SHUTDOWN_CLEANUP_DELAY) {
                this.stop();
                this.fullReset();
            }
                } else {
                        if (this.isMobileMode) {
                            // Ramp up desired active count over configured duration
                            this.rampTimer += deltaTime;
                            const rampProgress = Math.min(1, this.mobileParams.rampDuration > 0 ? this.rampTimer / this.mobileParams.rampDuration : 1);
                            const target = Math.floor(this.mobileParams.count * rampProgress);
                            if (this.particles.active.size < target) this.initMobileParticles(target);
                            // No emergency spawn; ramp controls initial population from zero
                            this.updateParticlesMobile(deltaTime);
                        } else {
                            this.updateGrid(deltaTime);
                            this.updateParticles(deltaTime);
                            this.updateBlackout();
                        }
        }

    this.bloomEffect.render(deltaTime);
    }

    public onWindowResize(): void {
    // Use overlay container CSS size to keep world-space alignment stable
    this.width = this.overlayContainer.clientWidth;
    this.height = this.overlayContainer.clientHeight;

        this.camera.left = -this.width / 2;
        this.camera.right = this.width / 2;
        this.camera.top = this.height / 2;
        this.camera.bottom = -this.height / 2;
        this.camera.updateProjectionMatrix();

        // Compute capped internal size and apply internalScale; upscale via CSS
        const { targetW, targetH } = this.computeInternalSize(this.width, this.height);
        this.renderer.setSize(targetW, targetH, false);
        const canvas = this.renderer.domElement;
        canvas.style.width = this.width + 'px';
        canvas.style.height = this.height + 'px';
        if (this.bloomEffect) {
            this.bloomEffect.setSize(targetW, targetH);
        }

    // Update point-size scale so symbols remain visually consistent
        this.updatePointScale(this.width, this.height);
    if (!this.isMobileMode) this.setupGrid();
        // Update scaling anchors and recompute sizes
        this.lastMeasuredContainerHeight = this.height;
        if (this.referenceContainerHeight === null && this.height > 0) {
            this.referenceContainerHeight = this.height;
        }
        this.currentScreenSizeType = this.getScreenSizeType();
        this.updateSymbolSizesForScale();
        this.dlog('onWindowResize(): css', { w: this.width, h: this.height }, 'internal', { targetW, targetH }, 'pointScale', (this.particleSystem.material as THREE.ShaderMaterial).uniforms.uPointScale.value);
    }
    
    public dispose(): void {
      this.stop();
      window.removeEventListener('resize', this.boundOnWindowResize);
    document.removeEventListener('visibilitychange', this.boundOnVisibilityChange);
      if (this.bloomEffect) {
        this.bloomEffect.dispose();
      }
      if (this.renderer) {
        this.renderer.dispose();
        if (this.renderer.domElement.parentNode) {
            this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
        }
      }
      if (this.scene) {
        // Basic scene disposal
      }
    }

    private onVisibilityChange(): void {
        const visible = document.visibilityState === 'visible';
        this.isPageVisible = visible;
        if (visible) {
            this.dlog('visibilitychange -> visible: resetting metrics, checking RAF/particles');
            // Reset performance metrics to avoid stale downscale decisions
            this.frameTimes = [];
            this.avgFrameMs = 0;
            // Add brief cooldown to prevent immediate scaling on resume
            this.scaleCooldown = Math.max(this.scaleCooldown, Math.floor(this.SCALE_COOLDOWN_FRAMES / 2));
            // Ensure sizes and grid are correct after tab return
            try { this.onWindowResize(); } catch {}
            // If loop stopped for any reason, restart it
            if (this.animationFrameId === null) {
                // Reinitialize particle state for a clean start
                this.fullReset();
                if (this.isMobileMode) {
                    this.resetAllParticles();
                    this.rampTimer = 0;
                }
                this.clock = new THREE.Clock();
                this.animate();
                this.dlog('visibilitychange -> visible: RAF restarted');
            } else {
                // If running but no particles are active, kick spawning
                if (this.isMobileMode) {
                    if (this.particles.active.size === 0) {
                        this.rampTimer = 0;
                        this.resetAllParticles();
                        // spawn a small initial batch to make it visible immediately
                        this.initMobileParticles(Math.min(20, this.mobileParams.count));
                        this.dlog('visibilitychange -> visible: mobile particles kickstarted');
                    }
                } else {
                    if (this.particles.active.size === 0) {
                        this.onsetTimer = 0;
                        this.resetBlackoutGrid();
                        // grid-based spawning will resume automatically in updateGrid
                        this.dlog('visibilitychange -> visible: grid reset; waiting for spawns');
                    }
                }
            }
            // Defensive: ensure no residual fade and compositor is primed
            this.isFadingOut = false;
            this.fadeOutTimer = 0;
            if (this.particleSystem) {
                (this.particleSystem.material as THREE.ShaderMaterial).uniforms.globalOpacity.value = 1.0;
            }
            try { this.bloomEffect?.composer?.render(0.01); } catch {}
        } else {
            this.dlog('visibilitychange -> hidden: pausing perf sampling');
        }
    }

    public start(): void {
        if (this.animationFrameId === null) {
            this.fullReset();
            if (this.isMobileMode) {
                // Start empty on mobile and let ramp gradually spawn
                this.resetAllParticles();
                this.rampTimer = 0;
            }
            this.clock = new THREE.Clock();
            this.animate();
        }
    }
    
    public stop(): void {
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
        this.clock = null;
      }
    }

        // Force a clean restart of the loop and visual state
        public restart(): void {
            this.stop();
            this.fullReset();
            // Ensure fully opaque after resume
            if (this.particleSystem) {
                (this.particleSystem.material as THREE.ShaderMaterial).uniforms.globalOpacity.value = 1.0;
            }
            this.clock = new THREE.Clock();
            this.animate();
            this.dlog('restart(): forced reset + RAF restart');
        }

    public beginLeaveAnimation(): void {
      if (!this.isFadingOut) {
        this.isFadingOut = true;
        this.fadeOutTimer = 0;
    if (!this.isMobileMode) this.resetBlackoutGrid();
      }
    }

    private setupScene(): void {
    // CSS size from overlay container
    this.width = this.overlayContainer.clientWidth;
    this.height = this.overlayContainer.clientHeight;
    this.scene = new THREE.Scene();
        
    this.camera = new THREE.OrthographicCamera(-this.width / 2, this.width / 2, this.height / 2, -this.height / 2, 1, 1000);
        this.camera.position.z = 100;
        
    this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    // Manual scaling: setPixelRatio(1) and setSize to internal target, CSS to overlay size
    this.renderer.setPixelRatio(1);
    const { targetW, targetH } = this.computeInternalSize(this.width, this.height);
    this.renderer.setSize(targetW, targetH, false);
    const canvas = this.renderer.domElement;
        // Accessibility: this canvas is purely decorative
        try {
            canvas.setAttribute('aria-hidden', 'true');
            canvas.setAttribute('role', 'presentation');
            canvas.setAttribute('tabindex', '-1');
        } catch {}
    canvas.style.width = this.width + 'px';
    canvas.style.height = this.height + 'px';
    canvas.style.position = 'absolute';
    canvas.style.inset = '0';
    canvas.style.zIndex = '10';
    this.overlayContainer.appendChild(canvas);
    this.dlog('setupScene(): renderer appended. DOM canvas size', { w: canvas.style.width, h: canvas.style.height });
    }

    private fullReset(): void {
        this.isFadingOut = false;
        this.fadeOutTimer = 0;
        this.onsetTimer = 0;
        this.rampTimer = 0;
        if(this.particleSystem) {
            this.particleSystem.material.uniforms.globalOpacity.value = 1.0;
        }
    if (!this.isMobileMode) this.resetBlackoutGrid();
    // Always clear particles so mobile also deletes symbols on leave
    this.resetAllParticles();
    }

    // Compute internal render target dimensions with 1440p cap and internalScale
    private computeInternalSize(cssW: number, cssH: number): { targetW: number; targetH: number } {
        const aspect = cssW / Math.max(1, cssH);
        let targetW = cssW;
        let targetH = cssH;
        if (cssW >= cssH) {
            if (cssW > this.MAX_INTERNAL_DIM) { targetW = this.MAX_INTERNAL_DIM; targetH = Math.round(targetW / aspect); }
        } else {
            if (cssH > this.MAX_INTERNAL_DIM) { targetH = this.MAX_INTERNAL_DIM; targetW = Math.round(targetH * aspect); }
        }
        targetW = Math.max(1, Math.round(targetW * this.internalScale));
        targetH = Math.max(1, Math.round(targetH * this.internalScale));
        return { targetW, targetH };
    }

    // Keep point sprites' visual size stable under internal resolution scaling
    private updatePointScale(cssW: number, cssH: number): void {
        if (!this.particleSystem) return;
        const { targetW, targetH } = this.computeInternalSize(cssW, cssH);
        const scaleX = cssW / Math.max(1, targetW);
        const scaleY = cssH / Math.max(1, targetH);
        const pointScale = Math.min(scaleX, scaleY);
        (this.particleSystem.material as THREE.ShaderMaterial).uniforms.uPointScale.value = pointScale;
    }

    // Metrics
    public getMetrics() { return { internalScale: this.internalScale, avgFrameMs: this.avgFrameMs }; }
    public enableMetrics(v: boolean) { this.metricsEnabled = v; }

    private resetBlackoutGrid(): void {
        if (!this.blackoutMesh) return;
        for (const cell of this.grid.cells) {
            cell.state = this.STATE.IDLE;
            cell.timer = 0;
            cell.opacity = 0;
        }
        this.blackoutMesh.count = 0;
        this.blackoutMesh.instanceMatrix.needsUpdate = true;
        (this.blackoutMesh.geometry.attributes.instanceOpacity as THREE.InstancedBufferAttribute).needsUpdate = true;
    }

    private resetAllParticles(): void {
        if (!this.particleSystem) return;

        const positions = (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).array as Float32Array;
        
        this.particles.active.forEach(p => {
            p.active = false;
            positions[p.index * 3 + 1] = -99999; // Move off-screen
            this.particles.pool.push(p);
        });
        this.particles.active.clear();

        (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;
    }

    private createSymbolTexture(): void {
        const symbolsPerRow = 8;
        const symbolSize = 64;
        const rows = Math.ceil(this.SYMBOLS.length / symbolsPerRow);
        
        const canvas = document.createElement('canvas');
        canvas.width = symbolsPerRow * symbolSize;
        canvas.height = rows * symbolSize;
        
        const ctx = canvas.getContext('2d')!;
        ctx.font = `bold ${symbolSize * 0.8}px monospace`;
        ctx.fillStyle = '#FFFFFF';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (let i = 0; i < this.SYMBOLS.length; i++) {
            const x = (i % symbolsPerRow) * symbolSize + symbolSize / 2;
            const y = Math.floor(i / symbolsPerRow) * symbolSize + symbolSize / 2;
            ctx.fillText(this.SYMBOLS[i], x, y);
        }
        
        this.symbolsTexture = new THREE.CanvasTexture(canvas);
    }

    private createBlackoutMesh(): void {
        const quadGeom = new THREE.PlaneGeometry(this.CELL_SIZE, this.CELL_SIZE);
        quadGeom.setAttribute('instanceOpacity', new THREE.InstancedBufferAttribute(new Float32Array(200 * 200), 1));
        
        const material = new THREE.ShaderMaterial({
            uniforms: { color: { value: this.BLACKOUT_COLOR } },
            vertexShader: `
                attribute float instanceOpacity;
                varying float vOpacity;
                void main() {
                    vOpacity = instanceOpacity;
                    gl_Position = projectionMatrix * instanceMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                varying float vOpacity;
                void main() {
                    gl_FragColor = vec4(color, vOpacity);
                }
            `,
            transparent: true,
        });

        this.blackoutMesh = new THREE.InstancedMesh(quadGeom, material, 150 * 200);
        this.scene.add(this.blackoutMesh);
    }

    private createParticleSystem(): void {
    const geometry = new THREE.BufferGeometry();
        const cap = this.MAX_ACTIVE_PARTICLES;
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(cap * 3), 3));
        geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(new Float32Array(cap * 3), 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(new Float32Array(cap), 1));
        geometry.setAttribute('symbolIndex', new THREE.Float32BufferAttribute(new Float32Array(cap), 1));
        geometry.setAttribute('particleOpacity', new THREE.Float32BufferAttribute(new Float32Array(cap), 1));

    // Allocate intrinsic size factors array for unified scaling recomputation
    this.baseSizeFactors = new Float32Array(cap);

        const material = new THREE.ShaderMaterial({
            uniforms: {
                symbolsTexture: { value: this.symbolsTexture },
                globalOpacity: { value: 1.0 },
                uPointScale: { value: 1.0 },
            },
            vertexShader: `
                attribute float size;
                attribute vec3 customColor;
                attribute float symbolIndex;
                attribute float particleOpacity;
                uniform float uPointScale;
                varying vec3 vColor;
                varying float vSymbolIndex;
                varying float vOpacity;
                void main() {
                    vColor = customColor;
                    vSymbolIndex = symbolIndex;
                    vOpacity = particleOpacity;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size * uPointScale;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
        fragmentShader: `
                uniform sampler2D symbolsTexture;
                uniform float globalOpacity;
                varying vec3 vColor;
                varying float vSymbolIndex;
                varying float vOpacity;
                void main() {
                    float symbolsPerRow = 8.0;
                    float totalRows = ${Math.ceil(this.SYMBOLS.length / 8)}.0;
                    vec2 symbolCoord = gl_PointCoord;
                    symbolCoord.x = (symbolCoord.x + mod(vSymbolIndex, symbolsPerRow)) / symbolsPerRow;
                    symbolCoord.y = (symbolCoord.y + floor(vSymbolIndex / symbolsPerRow)) / totalRows;
                    
                    vec4 tex = texture2D(symbolsTexture, symbolCoord);
            if (tex.a < 0.2) discard;
                    
                    gl_FragColor = vec4(vColor, tex.a * vOpacity * ${this.PARTICLE_BASE_OPACITY} * globalOpacity);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        this.particleSystem = new THREE.Points(geometry, material);
        this.scene.add(this.particleSystem);

                const symbolIndices = (geometry.attributes.symbolIndex as THREE.BufferAttribute).array as Float32Array;
                for (let i = 0; i < cap; i++) {
            symbolIndices[i] = Math.floor(Math.random() * this.SYMBOLS.length);
        }
    (geometry.attributes.symbolIndex as THREE.BufferAttribute).needsUpdate = true;
                for (let i = 0; i < cap; i++) {
                    this.particles.pool.push({
                        index: i, active: false, originalPos: new THREE.Vector2(),
                        amplitude: 0, timeOffset: 0, speed: 0, lifetime: 0, age: 0, size: 0,
                        color: new THREE.Color(), symbolIndex: 0, gridCellIndex: -1,
                        lastSymbolChange: 0, symbolChangeInterval: 0
                    });
                }

                        // Mobile: don't pre-spawn here; ramp will handle spawning after start()
                        this.dlog('createParticleSystem(): created geometry + material. pool size:', this.particles.pool.length, 'active size:', this.particles.active.size, 'mobileMode:', this.isMobileMode);
    }

        // --- Mobile simplified particle spawning: float in from left ---
        private initMobileParticles(desiredCount?: number): void {
            const positions = (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).array as Float32Array;
            const opacities = (this.particleSystem.geometry.attributes.particleOpacity as THREE.BufferAttribute).array as Float32Array;
            const colors = (this.particleSystem.geometry.attributes.customColor as THREE.BufferAttribute).array as Float32Array;
            const sizes = (this.particleSystem.geometry.attributes.size as THREE.BufferAttribute).array as Float32Array;
            const desired = Math.min((desiredCount ?? this.mobileParams.count), this.MAX_ACTIVE_PARTICLES);
            const current = this.particles.active.size;
            let toSpawn = Math.max(0, desired - current);
            if (toSpawn <= 0) { this.dlog('initMobileParticles(): current meets or exceeds desired; skipping', { current, desired }); return; }
            if (this.particles.pool.length <= 0) { this.dlog('initMobileParticles(): pool empty; cannot spawn'); return; }
            toSpawn = Math.min(toSpawn, this.particles.pool.length);
            const rightX = this.width / 2 - 2; // place just inside the screen for immediate visibility
            const unifiedScale = this.getUnifiedSymbolScale(); // retained for debug instrumentation
            for (let i = 0; i < toSpawn; i++) {
                const p = this.particles.pool.pop();
                if (!p) { this.dlog('initMobileParticles(): pool underflow at i=', i); break; }
                p.active = true;
                p.originalPos.set(rightX, (Math.random() - 0.5) * this.height);
                // assign lifetime first, then compute speed; start new particles at age 0
                p.lifetime = this.mobileParams.lifetime.min + Math.random() * (this.mobileParams.lifetime.max - this.mobileParams.lifetime.min);
                p.age = 0;
                // derive base speed so that by fadeStartLifetimeFraction of lifetime, particle reaches ~fadeStartScreenFraction of screen width
                const baseSpeed = (this.width * this.mobileParams.fadeStartScreenFraction) / Math.max(0.001, (p.lifetime * this.mobileParams.fadeStartLifetimeFraction));
                const jitter = 0.7 + Math.random() * 0.6; // ~±30%
                p.speed = baseSpeed * this.mobileParams.speedFactor * jitter; // px/sec
                p.amplitude = this.mobileParams.amplitude.min + Math.random() * (this.mobileParams.amplitude.max - this.mobileParams.amplitude.min); // vertical drift amplitude
                p.timeOffset = Math.random() * Math.PI * 2;
                const rawBase = this.mobileParams.size.min + Math.random() * (this.mobileParams.size.max - this.mobileParams.size.min);
                const { size: finalSize } = this.computeFinalSize(rawBase);
                p.size = finalSize;
                if (this.baseSizeFactors) this.baseSizeFactors[p.index] = rawBase;
                p.symbolIndex = Math.floor(Math.random() * this.SYMBOLS.length);
                p.color.copy(this.getSymbolColor());
                p.lastSymbolChange = 0;
                p.symbolChangeInterval = 1.5 + Math.random() * 1.5;
                this.particles.active.set(p.index, p);
                positions[p.index * 3] = p.originalPos.x;
                positions[p.index * 3 + 1] = p.originalPos.y;
                positions[p.index * 3 + 2] = 1;
                colors[p.index * 3] = p.color.r; colors[p.index * 3 + 1] = p.color.g; colors[p.index * 3 + 2] = p.color.b;
                sizes[p.index] = p.size;
                this.lastSpawnComputedSize = p.size;
                this.lastSpawnRawBase = rawBase;
                this.lastSpawnScreenRatio = this.SCREEN_SYMBOL_RATIO[this.currentScreenSizeType];
                this.lastSpawnScale = unifiedScale;
                opacities[p.index] = 0;
            }
            (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.customColor as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.size as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.particleOpacity as THREE.BufferAttribute).needsUpdate = true;
            // removed noisy sampling log
        }

        private updateParticlesMobile(deltaTime: number): void {
            const positions = (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).array as Float32Array;
            const opacities = (this.particleSystem.geometry.attributes.particleOpacity as THREE.BufferAttribute).array as Float32Array;
            const sizes = (this.particleSystem.geometry.attributes.size as THREE.BufferAttribute).array as Float32Array;
            const symbolIndices = (this.particleSystem.geometry.attributes.symbolIndex as THREE.BufferAttribute).array as Float32Array;
            let needsUpdate = false;

                        this.particles.active.forEach(p => {
                p.age += deltaTime;
                                // movement from right to left with slight vertical drift
                const x = p.originalPos.x - p.speed * p.age;
                const y = p.originalPos.y + Math.sin(p.age * 2 + p.timeOffset) * p.amplitude;
                positions[p.index * 3] = x;
                positions[p.index * 3 + 1] = y;
                positions[p.index * 3 + 2] = 1;

                                // fade in/out: combine lifetime and screen fraction triggers
                                const fadeIn = Math.min(1, p.age / Math.max(0.001, this.mobileParams.fadeInDuration));
                                const fadeStartLifetime = p.lifetime * this.mobileParams.fadeStartLifetimeFraction;
                                const distFromRight = (this.width / 2) - x;
                                const screenThreshold = this.width * this.mobileParams.fadeStartScreenFraction;
                                const fadeProgressScreen = this.mobileParams.fadeStartScreenFraction <= 0 ? 0 : Math.max(0, (distFromRight - screenThreshold) / Math.max(1, (this.width - screenThreshold)));
                                const hasPassedLifetimeFade = p.age >= fadeStartLifetime;
                                const shouldFade = hasPassedLifetimeFade || fadeProgressScreen > 0;
                                let fadeOut = 1;
                                if (shouldFade) {
                                    const tLife = (p.age - fadeStartLifetime) / Math.max(0.001, this.mobileParams.fadeOutDuration);
                                    const t = Math.max(0, Math.min(1, Math.max(tLife, fadeProgressScreen)));
                                    fadeOut = 1 - t;
                                }
                                opacities[p.index] = Math.min(fadeIn, fadeOut);

                // occasional symbol change
                p.lastSymbolChange += deltaTime;
                if (p.lastSymbolChange > p.symbolChangeInterval) {
                    symbolIndices[p.index] = Math.floor(Math.random() * this.SYMBOLS.length);
                    p.lastSymbolChange = 0;
                }

                // recycle when lifetime ends or out of bounds
                if (p.age >= p.lifetime || x < -this.width / 2 - 30) {
                    // reuse particle: respawn near left
                    p.active = true;
                    p.originalPos.set(this.width / 2 - 2, (Math.random() - 0.5) * this.height);
                    // assign lifetime first, then compute speed; reset age
                    p.lifetime = this.mobileParams.lifetime.min + Math.random() * (this.mobileParams.lifetime.max - this.mobileParams.lifetime.min);
                    p.age = 0;
                    const baseSpeed2 = (this.width * this.mobileParams.fadeStartScreenFraction) / Math.max(0.001, (p.lifetime * this.mobileParams.fadeStartLifetimeFraction));
                    const jitter2 = 0.7 + Math.random() * 0.6;
                    p.speed = baseSpeed2 * this.mobileParams.speedFactor * jitter2;
                    p.amplitude = this.mobileParams.amplitude.min + Math.random() * (this.mobileParams.amplitude.max - this.mobileParams.amplitude.min);
                    p.timeOffset = Math.random() * Math.PI * 2;
                    const rawBase2 = this.mobileParams.size.min + Math.random() * (this.mobileParams.size.max - this.mobileParams.size.min);
                    const unifiedScale2 = this.getUnifiedSymbolScale();
                    const { size: finalSize2 } = this.computeFinalSize(rawBase2);
                    p.size = finalSize2;
                    if (this.baseSizeFactors) this.baseSizeFactors[p.index] = rawBase2;
                    sizes[p.index] = p.size;
                    this.lastSpawnComputedSize = p.size;
                    this.lastSpawnRawBase = rawBase2;
                    this.lastSpawnScreenRatio = this.SCREEN_SYMBOL_RATIO[this.currentScreenSizeType];
                    this.lastSpawnScale = unifiedScale2;
                    opacities[p.index] = 0;
                    needsUpdate = true;
                } else {
                    needsUpdate = true;
                }
            });

            if (needsUpdate) {
                (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;
                (this.particleSystem.geometry.attributes.size as THREE.BufferAttribute).needsUpdate = true;
                (this.particleSystem.geometry.attributes.symbolIndex as THREE.BufferAttribute).needsUpdate = true;
                (this.particleSystem.geometry.attributes.particleOpacity as THREE.BufferAttribute).needsUpdate = true;
                // removed periodic mobile sampling log
            }
        }

    private getSymbolColor(): THREE.Color {
        return this.SYMBOL_COLORS[Math.floor(Math.random() * this.SYMBOL_COLORS.length)];
    }

    private setupGrid(): void {
        this.imageRect = this.image.getBoundingClientRect();
        if (!this.imageRect || !this.imageRect.width) return;
        
        this.grid.cols = Math.floor(this.imageRect.width / this.CELL_SIZE);
        this.grid.rows = Math.floor(this.imageRect.height / this.CELL_SIZE);
        this.grid.cells = [];
        
        for (let i = 0; i < this.grid.cols * this.grid.rows; i++) {
            this.grid.cells.push({ state: this.STATE.IDLE, timer: 0, opacity: 0 });
        }
    }

    private updateGrid(deltaTime: number): void {
        if (this.particles.active.size >= this.MAX_ACTIVE_PARTICLES) return;
        
        this.onsetTimer = Math.min(this.ONSET_DURATION, this.onsetTimer + deltaTime);
        const onsetMultiplier = this.ONSET_DURATION > 0 ? this.onsetTimer / this.ONSET_DURATION : 1;
        const spawnCols = Math.floor(this.grid.cols * this.SPAWN_AREA_WIDTH);

        for (let i = 0; i < this.grid.cells.length; i++) {
            const cell = this.grid.cells[i];
            const fadeSpeed = deltaTime / this.BLACKOUT_FADE_DURATION;

            if (cell.state === this.STATE.ACTIVE) {
                cell.opacity = Math.min(1.0, cell.opacity + fadeSpeed);
            } else {
                cell.opacity = Math.max(0.0, cell.opacity - fadeSpeed);
            }

            if (cell.state === this.STATE.IDLE) {
                const col = i % this.grid.cols;
                if (col < spawnCols) {
                    const normalizedX = col / spawnCols;
                    const probability = this.BASE_CHANCE * onsetMultiplier * Math.exp(-this.PROBABILITY_DECAY_FACTOR * normalizedX) * deltaTime * 60;
                    if (Math.random() < probability) {
                        cell.state = this.STATE.ACTIVE;
                        this.spawnParticleForCell(i);
                    }
                }
            } else if (cell.state === this.STATE.REGENERATING) {
                cell.timer += deltaTime;
                if (cell.timer >= this.REGENERATION_TIME && cell.opacity <= 0) {
                    cell.state = this.STATE.IDLE;
                    cell.timer = 0;
                }
            }
        }
    }

    private spawnParticleForCell(cellIndex: number): void {
        if (this.particles.pool.length === 0 || !this.imageRect) return;

        const particle = this.particles.pool.pop()!;
        particle.active = true;
        particle.gridCellIndex = cellIndex;

        const col = cellIndex % this.grid.cols;
        const row = Math.floor(cellIndex / this.grid.cols);
        const xOnImage = col * this.CELL_SIZE + this.CELL_SIZE / 2;
        const yOnImage = row * this.CELL_SIZE + this.CELL_SIZE / 2;
        const x = this.imageRect.left + xOnImage - this.width / 2;
        const y = -(this.imageRect.top + yOnImage) + this.height / 2;
        
        particle.originalPos.set(x, y);
        const speedVariation = (Math.random() * 2 - 1) * this.PARTICLE_SPEED_VARIATION;
        particle.speed = this.PARTICLE_SPEED * (1 + speedVariation);
        particle.amplitude = this.AMPLITUDE.min + Math.random() * (this.AMPLITUDE.max - this.AMPLITUDE.min);
        particle.timeOffset = Math.random() * Math.PI * 2;
        particle.lifetime = this.PARTICLE_LIFETIME.min + Math.random() * (this.PARTICLE_LIFETIME.max - this.PARTICLE_LIFETIME.min);
        particle.age = 0;
    const rawBase = this.CELL_SIZE * (1 + 1.1 * Math.random());
    const unifiedScale = this.getUnifiedSymbolScale();
    const { size: finalSize } = this.computeFinalSize(rawBase);
    particle.size = finalSize;
    if (this.baseSizeFactors) this.baseSizeFactors[particle.index] = rawBase;
    this.lastSpawnComputedSize = particle.size;
    this.lastSpawnRawBase = rawBase;
    this.lastSpawnScreenRatio = this.SCREEN_SYMBOL_RATIO[this.currentScreenSizeType];
    this.lastSpawnScale = unifiedScale;
        particle.symbolIndex = Math.floor(Math.random() * this.SYMBOLS.length);
        particle.color.copy(this.getSymbolColor());
        particle.lastSymbolChange = 0;
        const variation = 1 + (Math.random() * 2 - 1) * this.SYMBOL_CHANGE_VARIATION;
        particle.symbolChangeInterval = this.SYMBOL_CHANGE_INTERVAL * variation;

        this.particles.active.set(particle.index, particle);
    }

    private updateParticles(deltaTime: number): void {
        const positions = (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).array as Float32Array;
        const opacities = (this.particleSystem.geometry.attributes.particleOpacity as THREE.BufferAttribute).array as Float32Array;
        const colors = (this.particleSystem.geometry.attributes.customColor as THREE.BufferAttribute).array as Float32Array;
        const sizes = (this.particleSystem.geometry.attributes.size as THREE.BufferAttribute).array as Float32Array;
        const symbolIndices = (this.particleSystem.geometry.attributes.symbolIndex as THREE.BufferAttribute).array as Float32Array;
        let needsUpdate = false;

        this.particles.active.forEach(p => {
            p.age += deltaTime;
            if (p.age >= p.lifetime && !this.isFadingOut) {
                this.grid.cells[p.gridCellIndex].state = this.STATE.REGENERATING;
                p.active = false;
                this.particles.active.delete(p.index);
                this.particles.pool.push(p);
                positions[p.index * 3 + 1] = -99999;
                opacities[p.index] = 0;
                needsUpdate = true;
                return;
            }

            if (p.age < this.PARTICLE_FADE_IN_DURATION) {
                opacities[p.index] = p.age / this.PARTICLE_FADE_IN_DURATION;
            } else if (p.age > p.lifetime - this.PARTICLE_FADEOUT_DURATION && !this.isFadingOut) {
                opacities[p.index] = (p.lifetime - p.age) / this.PARTICLE_FADEOUT_DURATION;
            } else {
                opacities[p.index] = 1.0;
            }

            p.lastSymbolChange += deltaTime;
            if(p.lastSymbolChange > p.symbolChangeInterval) {
                symbolIndices[p.index] = Math.floor(Math.random() * this.SYMBOLS.length);
                p.lastSymbolChange = 0;
            }

            const offsetX = -p.age * p.speed * p.amplitude;
            const offsetY = Math.sin(p.age * 1.5 + p.timeOffset) * 10;

            positions[p.index * 3] = p.originalPos.x + offsetX;
            positions[p.index * 3 + 1] = p.originalPos.y + offsetY;
            positions[p.index * 3 + 2] = 1;
            p.color.toArray(colors, p.index * 3);
            sizes[p.index] = p.size;
            needsUpdate = true;
        });
        
        if (needsUpdate) {
            (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.customColor as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.size as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.symbolIndex as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.particleOpacity as THREE.BufferAttribute).needsUpdate = true;
        }
    }
    
    private updateBlackout(): void {
        if (!this.imageRect) return;

        const dummy = new THREE.Object3D();
        const opacities = (this.blackoutMesh.geometry.attributes.instanceOpacity as THREE.InstancedBufferAttribute).array as Float32Array;
        let instanceIdx = 0;

        for (let i = 0; i < this.grid.cells.length; i++) {
            if (this.grid.cells[i].opacity > 0) {
                const col = i % this.grid.cols;
                const row = Math.floor(i / this.grid.cols);
                const xOnImage = col * this.CELL_SIZE + this.CELL_SIZE / 2;
                const yOnImage = row * this.CELL_SIZE + this.CELL_SIZE / 2;
                const x = this.imageRect.left + xOnImage - this.width / 2;
                const y = -(this.imageRect.top + yOnImage) + this.height / 2;
                
                dummy.position.set(x, y, 0);
                dummy.updateMatrix();
                
                this.blackoutMesh.setMatrixAt(instanceIdx, dummy.matrix);
                opacities[instanceIdx] = this.grid.cells[i].opacity;
                instanceIdx++;
            }
        }
        
        this.blackoutMesh.count = instanceIdx;
        this.blackoutMesh.instanceMatrix.needsUpdate = true;
        (this.blackoutMesh.geometry.attributes.instanceOpacity as THREE.InstancedBufferAttribute).needsUpdate = true;
    }
    // ================= Symbol Scaling Helpers =================
    private getScreenSizeType(): typeof this.currentScreenSizeType {
        const width = this.overlayContainer.clientWidth;
        if (width <= this.SCREEN_SIZES.mobile.maxWidth) return 'mobile';
        if (width >= this.SCREEN_SIZES.tablet.minWidth && width <= this.SCREEN_SIZES.tablet.maxWidth) return 'tablet';
        if (width >= this.SCREEN_SIZES.laptop.minWidth && width <= this.SCREEN_SIZES.laptop.maxWidth) return 'laptop';
        if (width >= this.SCREEN_SIZES.desktop.minWidth && width <= this.SCREEN_SIZES.desktop.maxWidth) return 'desktop';
        if (width >= this.SCREEN_SIZES.large.minWidth && width <= this.SCREEN_SIZES.large.maxWidth) return 'large';
        return 'ultrawide';
    }
    private getAnchoredScale(): number {
        if (this.referenceContainerHeight && this.lastMeasuredContainerHeight > 0) {
            const raw = this.referenceContainerHeight / this.lastMeasuredContainerHeight; // inverse so if container grows symbols scale up
            return Math.min(1.6, Math.max(0.65, raw));
        }
        return 1.0;
    }
    private getUnifiedSymbolScale(): number {
        const anchored = this.getAnchoredScale();
        const ratio = this.SCREEN_SYMBOL_RATIO[this.currentScreenSizeType] ?? 1.0;
        this.cachedDPR = (typeof window !== 'undefined' ? window.devicePixelRatio : 1) || 1;
        // We want higher devicePixelRatio screens (denser) to allow modest enlargement so perceived size matches large low-DPI displays.
        // densityExponent controls curve aggression. Clamp overall effect.
        let densityScale = 1.0;
        if (this.enableDensityCompensation) {
            densityScale = Math.pow(this.cachedDPR / this.densityBaseDPR, this.densityExponent);
            densityScale = Math.min(1.8, Math.max(0.7, densityScale));
        }
        return anchored * ratio * this.globalSymbolSizeMul * densityScale;
    }
    private computeFinalSize(rawBase: number): { size: number; clamped: boolean } {
        const unifiedScale = this.getUnifiedSymbolScale();
        let size = rawBase * unifiedScale;
        let clamped = false;
        if (this.gpuPointSizeRange && this.particleSystem) {
            const maxPoint = this.gpuPointSizeRange[1];
            const uPointScale = (this.particleSystem.material as THREE.ShaderMaterial).uniforms.uPointScale.value || 1.0;
            const maxAttr = maxPoint / Math.max(0.0001, uPointScale);
            if (size > maxAttr) { size = maxAttr; clamped = true; }
        }
        this.lastClampOccurred = clamped;
        return { size, clamped };
    }
    private updateSymbolSizesForScale(): void {
        if (!this.particleSystem || !this.baseSizeFactors) return;
        const sizesAttr = this.particleSystem.geometry.getAttribute('size') as THREE.BufferAttribute;
        const sizes = sizesAttr.array as Float32Array;
        this.particles.active.forEach(p => {
            const base = this.baseSizeFactors![p.index];
            if (base > 0) {
                const { size } = this.computeFinalSize(base);
                p.size = size;
                sizes[p.index] = size;
            }
        });
        sizesAttr.needsUpdate = true;
    }
    public setGlobalSymbolSizeMultiplier(m: number) {
        this.globalSymbolSizeMul = Math.max(0.05, m);
        this.updateSymbolSizesForScale();
    }
    public setScreenSymbolRatio(screen: typeof this.currentScreenSizeType, ratio: number) {
        if (ratio > 0 && screen in this.SCREEN_SYMBOL_RATIO) {
            this.SCREEN_SYMBOL_RATIO[screen] = ratio;
            this.updateSymbolSizesForScale();
        }
    }
    public setDensityCompensation(enabled: boolean) {
        this.enableDensityCompensation = enabled;
        this.updateSymbolSizesForScale();
    }
    public setDensityExponent(exp: number) {
        this.densityExponent = Math.max(0, Math.min(2, exp));
        this.updateSymbolSizesForScale();
    }
    public getSymbolDebugInfo() {
        return {
            currentScreen: this.currentScreenSizeType,
            ratio: this.SCREEN_SYMBOL_RATIO[this.currentScreenSizeType],
            anchoredScale: this.getAnchoredScale(),
            unifiedScale: this.getUnifiedSymbolScale(),
            globalMul: this.globalSymbolSizeMul,
            dpr: this.cachedDPR,
            densityComp: this.enableDensityCompensation,
            densityExponent: this.densityExponent,
            gpuPointSizeRange: this.gpuPointSizeRange,
            lastClampOccurred: this.lastClampOccurred,
            lastSpawnComputedSize: this.lastSpawnComputedSize,
            lastSpawnRawBase: this.lastSpawnRawBase,
            lastSpawnScreenRatio: this.lastSpawnScreenRatio,
            lastSpawnScale: this.lastSpawnScale
        };
    }
  }

    // React to reduced-motion changes at runtime
    $: if ($prm) {
        // Stop visuals and ensure container is hidden
        if (effectInstance) {
            effectInstance.stop?.();
        }
        gsap.killTweensOf(mainContainer);
        gsap.set(mainContainer, { autoAlpha: 0 });
    }
</script>

<div class="main-container gpu-prewarm-target" bind:this={mainContainer}>
  <div class="image-pane">
    <img src={imageUrl} alt="Profile" bind:this={imageElement} style={`object-position: ${mobileMode ? mobileImageOffsetX : 50}% center;`}/>
  </div>
</div>

<div class="particle-overlay" bind:this={particleOverlayElement} aria-hidden="true" role="presentation"></div>

<style>
  .main-container {
    position: relative;
    z-index: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    visibility: hidden;
    opacity: 0;
  }
  .image-pane {
    position: relative;
    height: 100%;
    flex-shrink: 0;
    display: flex;
    justify-content: flex-end;
    align-items: center;
  }
  .image-pane img {
    height: 100vh;
    width: auto;
    display: block;
    object-fit: cover;
    object-position: center;
  }
    .particle-overlay {
        position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 10;
    pointer-events: none;
  }

    /* Mobile: ensure full-screen centered background image */
    @media (max-width: 768px) {
        .main-container { visibility: visible; opacity: 1; }
        .image-pane { position: fixed; inset: 0; z-index: 0; display: flex; justify-content: center; align-items: center; }
        .image-pane img { width: 100vw; height: 100dvh; object-fit: cover; object-position: center; }
    }
</style>
--- END OF FILE src\lib\components\AboutImageEffect.svelte ---

--- START OF FILE src\lib\components\BackButton.svelte ---
<script lang="ts">
	import { onMount } from 'svelte';
	import { page } from '$app/stores';
	import { ArrowLeft } from 'lucide-svelte';
	import { transitionStore } from '$lib/stores/transitionStore';
	export let to: string | undefined = undefined; // optional override
	export let label: string | undefined = undefined; // optional override label
	let showButton = false;
	$: locale = ($page.params?.lang === 'en' ? 'en' : ($page.params?.lang === 'de' ? 'de' : 'de'));
	$: targetHref = to ?? (locale ? `/${locale}` : '/');
	$: ariaLabel = label ?? (locale === 'en' ? 'Back to home' : 'Zurück zur Startseite');

	onMount(() => {
		const t = setTimeout(() => { showButton = true; }, 300);
		return () => clearTimeout(t);
	});

	function handleClick() { transitionStore.fadeToBlackAndNavigate(targetHref); }
</script>

<button class="back-button" class:visible={showButton} aria-label={ariaLabel} on:click={handleClick}>
	<ArrowLeft size={24} />
</button>

<style>
	.back-button { position: fixed; top: 2rem; left: 2rem; z-index: 1000; background-color: rgba(30,30,32,0.7); border: 1px solid rgba(255,255,255,0.1); color: white; backdrop-filter: blur(8px); width: 3rem; height: 3rem; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s ease-in-out; opacity: 0; transform: scale(0.8); pointer-events: none; }
	.back-button.visible { opacity: 1; transform: scale(1); pointer-events: auto; }
	.back-button:hover, .back-button:focus-visible { background-color: rgba(50,50,52,0.9); }
	.back-button:focus-visible { outline: none; box-shadow: 0 0 0 3px rgba(130,214,255,0.45), 0 0 0 6px rgba(130,214,255,0.15); }
	@media (max-width: 640px) { .back-button { top: 1rem; left: 1rem; width: 2.75rem; height: 2.75rem; } }
</style>

--- END OF FILE src\lib\components\BackButton.svelte ---

--- START OF FILE src\lib\components\HeroParticleEffect.svelte ---
<!-- src/lib/components/HeroParticleEffect.svelte -->
<script lang="ts">
  import { onMount, onDestroy, tick } from 'svelte';
  import { createEventDispatcher } from 'svelte';
  import *  as THREE from 'three';
  import { FontLoader, type Font } from 'three/examples/jsm/loaders/FontLoader.js';
  import { Environment as ParticleEnvironment } from '$lib/three/heroParticleLogic';
  import { preloadingStore, startLoadingTask, preloadAssets } from '$lib/stores/preloadingStore';
  import { renderProfile } from '$lib/stores/renderProfile';
  import { prefersReducedMotion as prm } from '$lib/stores/renderProfile';
  import { get } from 'svelte/store';

  export let activeSectionIndex: number;
  export let isTransitioning: boolean = false;
  export let transitionDuration: number = 1.1;
  export let isInitialLoad: boolean = false;

  const dispatch = createEventDispatcher();

  const HERO_SECTION_LOGICAL_INDEX = 0;
  const HERO_ASSETS_TASK_ID = 'heroEffectAssets';
  const HERO_INIT_TASK_ID = 'heroEffectInitialization';

  let threeContainerElement: HTMLDivElement | undefined;
  let particleSystemInstance: ParticleEnvironment | null = null;
  let loadedFontAsset: Font | null = null;
  let loadedParticleTextureMap: THREE.Texture | null = null;
  // Lightweight gated logger. Logs only if debug overlay is active (three consecutive 'd' presses) or if FORCE_DEBUG env flag (could be added later).
  function dlog(level: 'log' | 'warn' | 'error', ...args: any[]) {
    if (particleSystemInstance?.isDebugOverlayActive()) {
      // Prefix for easier filtering
      const prefix = '[HPE]';
      switch(level) {
        case 'log': console.log(prefix, ...args); break;
        case 'warn': console.warn(prefix, ...args); break;
        case 'error': console.error(prefix, ...args); break;
      }
    }
  }

  let isThreeJsLoopRunning = false;
  let areInteractionsBound = false;
  let animationLoopPauseTimeoutId: number | undefined;
  
  let initialOpacity = isInitialLoad ? '0' : '1';

  const FONT_ASSET_PATH = '/fonts/Inter_18pt_ExtraLight.json';
  const PARTICLE_TEXTURE_ASSET_PATH = 'https://res.cloudinary.com/dfvtkoboz/image/upload/v1605013866/particle_a64uzf.png';

  async function _preloadAssets() {
    const currentStatus = preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID);
    if (currentStatus === 'loaded' && loadedFontAsset && loadedParticleTextureMap) return;
    if (currentStatus === 'loading') return;

    startLoadingTask(HERO_ASSETS_TASK_ID);

    try {
      await preloadAssets([FONT_ASSET_PATH, PARTICLE_TEXTURE_ASSET_PATH]);
    } catch (error) {
  dlog('error', 'Asset preloading with preloadAssets failed:', error);
      preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'error', (error as Error).message);
      return;
    }

    const manager = new THREE.LoadingManager();
    manager.onLoad = () => preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'loaded');
    manager.onError = (url) => {
  dlog('error', `Error loading asset for Three.js: ${url}`);
      preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'error', `Failed to load ${url}`);
    };
    const fontLoader = new FontLoader(manager);
    const textureLoader = new THREE.TextureLoader(manager);

    try {
      const [font, texture] = await Promise.all([
        fontLoader.loadAsync(FONT_ASSET_PATH),
        textureLoader.loadAsync(PARTICLE_TEXTURE_ASSET_PATH)
      ]);
      loadedFontAsset = font;
      loadedParticleTextureMap = texture;
    } catch (error) {
  dlog('error', 'Asset loading promise for Three.js failed:', error);
      if (preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID) !== 'error') {
        preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'error', 'Asset loading failed.');
      }
    }
  }

  async function _ensureInstanceAndStartLoop() {
    if (preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID) !== 'loaded' || !loadedFontAsset || !loadedParticleTextureMap) {
  dlog('warn', 'Assets not ready for _ensureInstanceAndStartLoop.');
      await _preloadAssets(); 
      if (preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID) !== 'loaded') return; 
    }
    if (!threeContainerElement) {
  dlog('warn', 'DOM container not ready for _ensureInstanceAndStartLoop.');
      return;
    }

    if (!particleSystemInstance) {
      preloadingStore.updateTaskStatus(HERO_INIT_TASK_ID, 'loading');
      try {
  const mobile = get(renderProfile).isMobile;
        const options = mobile
          ? { initialInternalScale: 0.7, maxInternalDim: 960, amountScale: 1.0, antialias: true }
          : { initialInternalScale: 1.0, maxInternalDim: 1440, amountScale: 1.0, antialias: true };
        particleSystemInstance = new ParticleEnvironment(loadedFontAsset!, loadedParticleTextureMap!, threeContainerElement, options);
        preloadingStore.updateTaskStatus(HERO_INIT_TASK_ID, 'loaded');
  dlog('log', 'Created new Three.js instance.');
      } catch (error) {
  dlog('error', 'Error during ParticleEnvironment instantiation:', error);
        preloadingStore.updateTaskStatus(HERO_INIT_TASK_ID, 'error', 'Instantiation failed.');
        particleSystemInstance = null;
        return;
      }
    }

    if (particleSystemInstance && !particleSystemInstance.isLooping()) {
      particleSystemInstance.startAnimationLoop();
      isThreeJsLoopRunning = true;
  dlog('log', 'Three.js animation loop STARTED.');
    }
  }

  function _pauseThreeJsLoop() {
    if (particleSystemInstance && particleSystemInstance.isLooping()) {
      particleSystemInstance.stopAnimationLoop();
      isThreeJsLoopRunning = false;
  dlog('log', 'Three.js animation loop PAUSED.');
    }
  }

  function _bindInteractionEvents() {
    if (particleSystemInstance?.createParticles && !areInteractionsBound) {
      particleSystemInstance.createParticles.bindInteractionEvents();
      particleSystemInstance.createParticles.resetParticleState(); 
      areInteractionsBound = true;
  dlog('log', 'Interaction events BOUND and particle state RESET.');
    }
  }

  function _unbindInteractionEvents() {
    if (particleSystemInstance?.createParticles && areInteractionsBound) {
      particleSystemInstance.createParticles.unbindInteractionEvents();
      particleSystemInstance.createParticles.neutralizeLastMousePosition(); 
      areInteractionsBound = false;
  dlog('log', 'Interaction events UNBOUND and mouse position neutralized.');
    }
  }
  function _fadeInVisuals() {
    if (threeContainerElement) {
      if (isInitialLoad) {
        threeContainerElement.style.opacity = '0';
        requestAnimationFrame(() => {
          if (threeContainerElement) {
            threeContainerElement.style.opacity = '1';
          }
        });
      } else {
        threeContainerElement.style.opacity = '1';
      }
    }
  }

  function _fadeOutVisuals() {
    if (threeContainerElement) threeContainerElement.style.opacity = '0';
  }

  // --- EXPORTED METHODS FOR +page.svelte ---
  export async function onTransitionToHeroStart() {
  dlog('log', 'Method: onTransitionToHeroStart triggered.');
    clearTimeout(animationLoopPauseTimeoutId);
    if ($prm) {
      _unbindInteractionEvents();
      _fadeOutVisuals();
      _pauseThreeJsLoop();
      return;
    }
    await _ensureInstanceAndStartLoop();
    _fadeInVisuals();
    _unbindInteractionEvents();
  }

  export function onTransitionToHeroComplete() {
  dlog('log', 'Method: onTransitionToHeroComplete triggered.');
    if ($prm) return;
    _bindInteractionEvents();
  }

  export function onTransitionFromHeroStart() {
  dlog('log', 'Method: onTransitionFromHeroStart triggered.');
    _unbindInteractionEvents();
    _fadeOutVisuals();
    clearTimeout(animationLoopPauseTimeoutId);
    animationLoopPauseTimeoutId = window.setTimeout(() => {
      if (particleSystemInstance?.createParticles) {
        particleSystemInstance.createParticles.resetParticleState();
  dlog('log', 'Particle state RESET after fade out.');
      }
      _pauseThreeJsLoop();
    }, transitionDuration * 1000);
  }

  async function _handleSettledState() {
    if (activeSectionIndex === HERO_SECTION_LOGICAL_INDEX) {
  dlog('log', 'Settled on Hero.');
      clearTimeout(animationLoopPauseTimeoutId);
      if ($prm) {
        _unbindInteractionEvents();
        _fadeOutVisuals();
        _pauseThreeJsLoop();
        return;
      }
      await _ensureInstanceAndStartLoop();
      _fadeInVisuals();
      _bindInteractionEvents();
    } else {
  dlog('log', 'Settled off Hero.');
      _unbindInteractionEvents();
      _fadeOutVisuals();

      if (isThreeJsLoopRunning && particleSystemInstance?.isLooping() && animationLoopPauseTimeoutId === undefined) {
  dlog('log', '(SettledOff): Scheduling deferred pause and reset.');
        animationLoopPauseTimeoutId = window.setTimeout(() => {
          if (particleSystemInstance?.createParticles) {
            particleSystemInstance.createParticles.resetParticleState();
            dlog('log', '(SettledOff): Particle state RESET.');
          }
          _pauseThreeJsLoop();
          animationLoopPauseTimeoutId = undefined;
        }, transitionDuration * 1000);
      } else if (!isThreeJsLoopRunning && particleSystemInstance?.createParticles) {
  dlog('log', '(SettledOff): Loop already paused. Ensuring particle state is reset.');
        particleSystemInstance.createParticles.resetParticleState();
      }
    }
  }

  let isMountedAndInitialized = false;
  onMount(async () => {
    await tick(); 
    
    // Register the tasks this component is responsible for.
    if (!preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID)) {
      preloadingStore.registerTask(HERO_ASSETS_TASK_ID, 'pending');
    }
    if (!preloadingStore.getTaskStatus(HERO_INIT_TASK_ID)) {
      preloadingStore.registerTask(HERO_INIT_TASK_ID, 'pending');
    }

    // Await the asset loading before proceeding.
    await _preloadAssets();
    isMountedAndInitialized = true;
    
    // FIX: The reactive `$: ` block won't fire for the initial state,
    // so we must manually call the state handler on mount to ensure
    // the Three.js instance is created during the loading screen phase.
    if (!isTransitioning) {
      await _handleSettledState();
    }
    
    // Only after all assets are loaded and the instance is created,
    // we signal that this component is fully ready.
    dispatch('ready');
  });

  onDestroy(() => {
    clearTimeout(animationLoopPauseTimeoutId);
    _unbindInteractionEvents();
    if (particleSystemInstance?.createParticles) {
        particleSystemInstance.createParticles.resetParticleState();
    }
    _pauseThreeJsLoop();
    if (particleSystemInstance) {
      particleSystemInstance.dispose();
      particleSystemInstance = null;
  dlog('log', 'Three.js instance disposed.');
    }
  });

  // This reactive block handles all subsequent navigation after the initial load.
  $: if (isMountedAndInitialized && typeof activeSectionIndex === 'number') {
    if (!isTransitioning) {
        _handleSettledState();
    }
  }

  // React to reduced-motion preference changes at runtime
  $: if (isMountedAndInitialized) {
    if ($prm) {
      _unbindInteractionEvents();
      _fadeOutVisuals();
      _pauseThreeJsLoop();
    } else {
      // If user turns reduced-motion off while on hero, ensure visuals are ready on next settle
      if (activeSectionIndex === HERO_SECTION_LOGICAL_INDEX && !isTransitioning) {
        _handleSettledState();
      }
    }
  }

</script>

<div
  class="hero-particle-container"
  bind:this={threeContainerElement}
  id="magic"
  aria-hidden="true"
  role="presentation"
  style="opacity: {initialOpacity}; transition: opacity {transitionDuration}s ease-in-out;"
>
</div>

<style>
  .hero-particle-container {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    background-color: rgb(9 9 11);
    overflow: hidden;
    pointer-events: auto;
  }
</style>
--- END OF FILE src\lib\components\HeroParticleEffect.svelte ---

--- START OF FILE src\lib\components\KeyboardButtons.svelte ---
<!-- src/lib/components/KeyboardButtons.svelte -->

<script context="module" lang="ts">
  export type KeyboardButtonsInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
  };
</script>

<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import { gsap } from 'gsap';
  import type { SocialLink } from '$lib/data/siteConfig';
  import { page } from '$app/stores';

  const dispatch = createEventDispatcher();

  export let title: string;
  export let introduction: string;
  export let socialLinks: SocialLink[] = [];
  export let contactSectionIndex: number;
  export let navigateToSection: (index: number) => void;

  let wrapperElement: HTMLDivElement;
  let h2El: HTMLHeadingElement;
  let pEl: HTMLParagraphElement;
  let keyPositionElements: Element[] = [];

  onMount(() => {
    if (wrapperElement) {
        keyPositionElements = gsap.utils.toArray(wrapperElement.querySelectorAll('.key-position'));
    }
  });

  export function onEnterSection() {
    if (!h2El || !pEl || keyPositionElements.length === 0) return;

    // 1. Set the initial "hidden" state for all elements.
    gsap.set(h2El, { autoAlpha: 0, y: 30 });
    gsap.set(pEl, { autoAlpha: 0, y: 20 });
    // Give the buttons a consistent "slide-up" starting position.
    gsap.set(keyPositionElements, { autoAlpha: 0, y: 15 });

    // 2. Create the animation timeline.
    gsap.timeline({
      delay: 0.5,
      onComplete: () => {
        dispatch('animationComplete');
      }
    })
      // 3. Animate the elements in a staggered sequence.
      .to(h2El, { 
          autoAlpha: 1, 
          y: 0, 
          duration: 0.9, 
          ease: 'power3.out' 
      }, 0) // Headline starts at time 0.
      .to(pEl, { 
          autoAlpha: 1, 
          y: 0, 
          duration: 0.8, 
          ease: 'power3.out' 
      }, 0.1) // Paragraph starts 0.1s after the headline.
      .to(keyPositionElements, {
          autoAlpha: 1,
          y: 0,
          duration: 0.7,
          ease: 'power3.out',
          stagger: 0.08, // A quick stagger for the buttons.
        }, 
        0.25 // The button sequence starts 0.25s after the headline.
      );
  }

  export function onLeaveSection() {
    const allElements = [h2El, pEl, ...keyPositionElements];
    if (allElements.some(el => !el)) return;
    
    // Hard reset for interrupt-safety.
    gsap.killTweensOf(allElements);
    gsap.set(allElements, { autoAlpha: 0 });
  }

  const getLink = (name: string): string => {
    const link = socialLinks.find(l => l.name.toLowerCase() === name.toLowerCase());
    return link ? link.url : '#';
  };

  const handleContactClick = () => {
    if (typeof navigateToSection === 'function' && contactSectionIndex !== -1) {
      navigateToSection(contactSectionIndex);
    }
  };
</script>

<div class="about-text-block" bind:this={wrapperElement}>
  <h2 bind:this={h2El}>{title}</h2>
  <p bind:this={pEl}>{introduction}</p>

  <div class="keyboard-buttons-wrapper">
    {#if socialLinks.find(l => l.name.toLowerCase() === 'github')}
  <div class="key-position gpu-prewarm-target">
      <a aria-label="Github" class="key" target="_blank" rel="noopener noreferrer" href={getLink('GitHub')}>
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" color="currentColor"><path d="M10 20.568c-3.429 1.157-6.286 0-8-3.568"></path><path d="M10 22v-3.242c0-.598.184-1.118.48-1.588c.204-.322.064-.78-.303-.88C7.134 15.452 5 14.107 5 9.645c0-1.16.38-2.25 1.048-3.2c.166-.236.25-.354.27-.46c.02-.108-.015-.247-.085-.527c-.283-1.136-.264-2.343.16-3.43c0 0 .877-.287 2.874.96c.456.285.684.428.885.46s.469-.035 1.005-.169A9.5 9.5 0 0 1 13.5 3a9.6 9.6 0 0 1 2.343.28c.536.134.805.2 1.006.169c.2-.032.428-.175.884-.46c1.997-1.247 2.874-.96 2.874-.96c.424 1.087.443 2.294.16 3.43c-.07.28-.104.42-.084.526s.103.225.269.461c.668.95 1.048 2.04 1.048 3.2c0 4.462-2.364 5.807-5.177 6.643c-.367.101-.507.559-.303.88c.296.47.48.99.48 1.589V22"></path></g></svg>
      </a>
    </div>
    {/if}
    {#if socialLinks.find(l => l.name.toLowerCase() === 'linkedin')}
  <div class="key-position gpu-prewarm-target">
      <a aria-label="LinkedIn" class="key" target="_blank" rel="noopener noreferrer" href={getLink('LinkedIn')}>
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4.5 9.5H4c-.943 0-1.414 0-1.707.293S2 10.557 2 11.5V20c0 .943 0 1.414.293 1.707S3.057 22 4 22h.5c.943 0 1.414 0 1.707-.293S6.5 20.943 6.5 20v-8.5c0-.943 0-1.414-.293-1.707S5.443 9.5 4.5 9.5m2-5.25a2.25 2.25 0 1 1-4.5 0a2.25 2.25 0 0 1 4.5 0m5.826 5.25H11.5c-.943 0-1.414 0-1.707.293S9.5 10.557 9.5 11.5V20c0 .943 0 1.414.293 1.707S10.557 22 11.5 22h.5c.943 0 1.414 0 1.707-.293S14 20.943 14 20v-3.5c0-1.657.528-3 2.088-3c.78 0 1.412.672 1.412 1.5v4.5c0 .943 0 1.414.293 1.707s.764.293 1.707.293h.499c.942 0 1.414 0 1.707-.293c.292-.293.293-.764.293-1.706L22 14c0-2.486-2.364-4.5-4.703-4.5c-1.332 0-2.52.652-3.297 1.673c0-.63 0-.945-.137-1.179a1 1 0 0 0-.358-.358c-.234-.137-.549-.137-1.179-.137" color="currentColor"></path></svg>
      </a>
    </div>
    {/if}
    {#if socialLinks.find(l => l.name.toLowerCase() === 'email')}
  <div class="key-position gpu-prewarm-target">
      <a aria-label="Email" class="key" target="_blank" rel="noopener noreferrer" href={getLink('Email')}>
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" color="currentColor"><path d="m2 6l6.913 3.917c2.549 1.444 3.625 1.444 6.174 0L22 6"></path><path d="M2.016 13.476c.065 3.065.098 4.598 1.229 5.733c1.131 1.136 2.705 1.175 5.854 1.254c1.94.05 3.862.05 5.802 0c3.149-.079 4.723-.118 5.854-1.254c1.131-1.135 1.164-2.668 1.23-5.733c.02-.986.02-1.966 0-2.952c-.066-3.065-.099-4.598-1.23-5.733c-1.131-1.136-2.705-1.175-5.854-1.254a115 115 0 0 0-5.802 0c-3.149.079-4.723.118-5.854 1.254c-1.131 1.135-1.164 2.668-1.23 5.733a69 69 0 0 0 0 2.952"></path></g></svg>
      </a>
    </div>
    {/if}
  <div class="key-position key-position-cta gpu-prewarm-target">
      <button type="button" id="about-contact-me-btn" class="key call-to-action peer" on:click={handleContactClick}>
        <span class="call-to-action-content">{(($page.data as any)?.messages?.common?.about?.contactMe) ?? 'Contact Me'}</span>
      </button>
    </div>
  </div>
</div>

<style>
  .about-text-block { max-width: 860px; }
  .about-text-block > p { 
    font-size: clamp(1rem, 2.2vw, 1.15rem); 
    line-height: 1.8; 
    margin-bottom: 2.5rem; 
    color: rgb(212 212 216); 
    opacity: 0;
    visibility: hidden;
  }
  .about-text-block h2 {
    font-size: clamp(2.2rem, 4.5vw, 3rem);
    margin-bottom: 1.5rem;
    font-weight: 300;
    letter-spacing: -0.02em;
    color: rgb(245 245 247);
    opacity: 0;
    visibility: hidden;
  }
  .keyboard-buttons-wrapper svg { width: 1.75rem; height: 1.75rem; color: var(--keyboard-contrast); }
  .keyboard-buttons-wrapper { display: flex; align-items: flex-start; text-align: center; gap: calc(var(--keyboard-key-base-size) * 0.01); }
  .key-position { perspective: 800px; transform: rotateY(0.05turn) rotateX(-0.1turn); }
  .key.call-to-action { width: 140px; font-size: 13px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  .call-to-action-content { position: relative; }
  .call-to-action-content:after { position: absolute; content: ""; width: 0; left: 0; bottom: -4px; background: var(--keyboard-contrast); height: 1.5px; transition: 0.3s ease-out; }
  .key.call-to-action:hover .call-to-action-content:after { width: 100%;}
  .key { 
    position: relative; 
    width: var(--keyboard-key-base-size); 
    height: var(--keyboard-key-base-size); 
    font-size: calc(var(--keyboard-key-base-size) / 2.2); 
    border: 0.1rem solid var(--keyboard-background-3); 
    border-radius: calc(var(--keyboard-key-base-size) * 0.2); 
    background: var(--keyboard-background-2); 
    color: var(--keyboard-contrast); 
    box-shadow: 0.15rem 0.15rem 0 0 var(--keyboard-background-3), 0.3rem 0.3rem 0 0 var(--keyboard-background-3), 0.45rem 0.45rem 0 0 var(--keyboard-background-3), 0.6rem 0.6rem 0 0 var(--keyboard-background-3); 
    transition: transform 0.2s ease, box-shadow 0.2s ease; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    text-decoration: none; 
    transform-style: preserve-3d;
  }
  .key span { color: inherit; margin: 0; padding: 0; }
  .key:hover { cursor: pointer; transform: translate(0.3rem, 0.3rem); }
  .key:active { cursor: grabbing; transform: translate(0.8rem, 0.8rem); box-shadow: 0.1rem 0.1rem 0 0 var(--keyboard-background-3), 0.1rem 0.1rem 0 0 var(--keyboard-background-3), 0.2rem 0.2rem 0 0 var(--keyboard-background-3), 0.2rem 0.2rem 0 0 var(--keyboard-background-3); filter: blur(0.02rem); }
  @media (max-width: 640px) {
    .keyboard-buttons-wrapper {
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: flex-start; /* left align */
      align-items: flex-start;
      gap: calc(var(--keyboard-key-base-size) * 0.01);
    }
    /* Put CTA on its own line under the social row, left-aligned */
    .key-position-cta {
      flex-basis: 100%;
      display: flex;
      justify-content: flex-start;
      margin-top: 0.25rem;
    }
    .about-text-block { margin: 0 auto; }
    .about-text-block h2,
    .about-text-block > p { text-align: left; }
  }
</style>
--- END OF FILE src\lib\components\KeyboardButtons.svelte ---

--- START OF FILE src\lib\components\LanguageSwitcher.svelte ---
<script lang="ts">
  import { page } from '$app/stores';
  import { goto } from '$app/navigation';

  export let locale: 'en' | 'de';
  export let groupLabel: string = 'Language';
  // Labels stay for a11y/screen readers; visually we render flags
  export let labelEn: string = 'EN';
  export let labelDe: string = 'DE';
  export let switchToEnLabel: string = 'Switch to English';
  export let switchToDeLabel: string = 'Switch to German';

  function setCookie(name: string, value: string, days = 365) {
    const d = new Date();
    d.setTime(d.getTime() + days * 24 * 60 * 60 * 1000);
    const expires = 'expires=' + d.toUTCString();
    document.cookie = `${name}=${value};${expires};path=/;SameSite=Lax`;
  }

  function switchLocale(target: 'en' | 'de') {
    if (target === locale) return;
    setCookie('locale', target);
    const current = $page.url;
    const pathname = current.pathname;
    let newPath = '';

    // Helper: map special slugs between locales
    const mapSpecial = (restPath: string): string | null => {
      if (target === 'de') {
  if (restPath === '/privacy') return '/de/datenschutz';
  if (restPath === '/imprint') return '/de/impressum';
  if (restPath === '/accessibility') return '/de/barrierefreiheit';
      } else {
  if (restPath === '/datenschutz') return '/en/privacy';
  if (restPath === '/impressum') return '/en/imprint';
  if (restPath === '/barrierefreiheit') return '/en/accessibility';
      }
      return null;
    };

      if (pathname === '/') {
      // On root, go to target locale root
      newPath = `/${target}`;
    } else if (/^\/(en|de)(\/|$)/.test(pathname)) {
      // Strip current locale and map remainder
      const rest = pathname.replace(/^\/(en|de)/, '');
      const restPath = rest === '' ? '/' : rest; // ensure leading slash remains
      const special = mapSpecial(restPath);
      if (special) {
        newPath = special;
      } else {
        // Project detail pages: /{lang}/projects/{slug}
        const projectMatch = restPath.match(/^\/projects\/([^/]+)$/);
        if (projectMatch) {
          const slug = projectMatch[1];
          newPath = `/${target}/projects/${slug}`; // slugs assumed identical across locales
        } else {
          newPath = `/${target}${restPath}`;
        }
      }
    } else {
      // No locale segment: prefix target and keep rest
      newPath = `/${target}${pathname}`;
    }
  // Preserve hash (subsection deep link) for project detail pages
  const isProjectDetail = /\/(en|de)\/projects\//.test(newPath);
  const finalUrl = newPath + current.search + (isProjectDetail ? current.hash : current.hash);
  goto(finalUrl, { keepFocus: true });
  }
</script>

<div class="lang-switch" role="group" aria-label={groupLabel}>
  <button
    type="button"
    class="lang-btn flag-btn flag-us"
    class:active={locale === 'en'}
    aria-pressed={locale === 'en'}
    aria-label={switchToEnLabel}
    title={switchToEnLabel}
    on:click={() => switchLocale('en')}
  >
    <span class="sr-only">{labelEn}</span>
  </button>
  <button
    type="button"
    class="lang-btn flag-btn flag-de"
    class:active={locale === 'de'}
    aria-pressed={locale === 'de'}
    aria-label={switchToDeLabel}
    title={switchToDeLabel}
    on:click={() => switchLocale('de')}
  >
    <span class="sr-only">{labelDe}</span>
  </button>
</div>

<style>
  .lang-switch { display: inline-flex; gap: 0.3rem; margin-left: 0.5rem; /* default scalable size */ --flag-h: 1rem; }
  .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
  .lang-btn {
    position: relative;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: var(--flag-h);
    width: calc(var(--flag-h) * 1.5); /* 3:2 aspect ratio */
    border-radius: calc(var(--flag-h) * 0.25);
    border: none;
    box-shadow: 0 0.125rem 0.5rem rgba(0,0,0,0.35);
    cursor: pointer;
    transition: transform 160ms ease, box-shadow 200ms ease, border-color 160ms ease, filter 160ms ease;
    overflow: hidden;
  }
  .lang-btn:hover { transform: translateY(-1px) scale(1.03); box-shadow: 0 0.375rem 1rem rgba(0,0,0,0.5); filter: saturate(1.2) contrast(1.05); }
  .lang-btn:focus-visible { outline: 0.125rem solid rgba(255,255,255,0.6); outline-offset: 0.125rem; }
  .lang-btn.active { transform: translateY(-1px) scale(1.02); box-shadow: 0 0.375rem 1rem rgba(0,0,0,0.5); filter: saturate(1.25) contrast(1.05); }

  /* Flag fill variants */
  .flag-btn { background-size: cover; background-position: center; }

  /* Germany: black-red-gold stripes */
  .flag-de {
    background-image:
      linear-gradient(to bottom, #000 0 33.333%, #dd0000 33.333% 66.666%, #ffce00 66.666% 100%);
  }

  /* USA: 13 stripes with blue canton (stars simplified) */
  .flag-us {
    background-image:
      /* canton */
      linear-gradient(#3c3b6e, #3c3b6e),
      /* stripes */
      repeating-linear-gradient(to bottom, #b22234 0 7.692%, #fff 7.692% 15.384%);
    background-size:
      42% 53.8%, /* approx width:height for canton (7 stripes tall) */
      100% 100%;
    background-position:
      left top,
      left top;
    background-repeat: no-repeat;
  }
</style>

--- END OF FILE src\lib\components\LanguageSwitcher.svelte ---

--- START OF FILE src\lib\components\LegalFooter.svelte ---
<script lang="ts">
	import { page } from '$app/stores';
	import { transitionStore } from '$lib/stores/transitionStore';

		interface LegalLink {
		name: string;
		url: string;
	}

	export let legalLinks: LegalLink[] = [];

	function withLang(url: string) {
		// If already prefixed with a locale, keep as is.
		if (/^\/(en|de)(\/|$)/.test(url)) return url;
		// Only prefix root-relative paths
		if (url.startsWith('/')) {
			const lang = $page.params?.lang ?? 'de';
			return `/${lang}${url}`;
		}
		return url;
	}

	const handleNavigate = (url: string) => {
		transitionStore.fadeToBlackAndNavigate(withLang(url));
	};
  
	// Accessibility: small helper for keyboard activation on Enter/Space when needed
	const onKeyActivate = (e: KeyboardEvent, url: string) => {
		if (e.key === 'Enter' || e.key === ' ') {
			e.preventDefault();
			handleNavigate(url);
		}
	};
</script>

<footer class="legal-footer" aria-label={(($page.data as any)?.messages?.common?.a11y?.legalFooter ?? 'Legal information links')}>
	<div class="addons"><slot /></div>
	<nav class="legal-nav" aria-label={(($page.data as any)?.messages?.common?.a11y?.legalNav ?? 'Legal Links')}>
			{#each legalLinks as link (link.url)}
				<button
					type="button"
					class="legal-link"
					on:click={() => handleNavigate(link.url)}
					on:keydown={(e) => onKeyActivate(e, link.url)}
				>
					<span class="measure" aria-hidden="true">{link.name}</span>
					<span class="label">{link.name}</span>
				</button>
			{/each}
	</nav>
	<div class="legal-meta">© {new Date().getFullYear()}</div>
  
	<!-- Ensure overlay can cover this: z-index below TransitionOverlay's 99999 -->
</footer>

<style>
	/* Hover behavior matches ParallaxCard title: weight + letter-spacing with smooth timing */
		.legal-footer {
			position: fixed;
			top: 0.75rem;
			right: 0.75rem;
			display: flex;
			align-items: center;
			justify-content: flex-end;
			gap: 0.75rem;
			padding: 0.25rem 0.35rem;
			font-size: 0.8rem;
			color: rgba(255, 255, 255, 0.6);
			pointer-events: none; /* allow clicks through except on buttons */
			z-index: 9990;

		/* Typography transition parameters (scoped) */
		--legal-link-transition-duration: 0.8s;
		/* Space Grotesk weight range (variable): 300..700 */
		--legal-link-initial-weight: 500;
		--legal-link-hover-weight: 700;
		--legal-link-initial-tracking: 0.01em;
		--legal-link-hover-tracking: 0.03em;
		}
			.addons { pointer-events: auto; display: inline-flex; align-items: center; }

		.legal-nav { display: flex; gap: 0.5rem; align-items: center; }

		.legal-link {
				pointer-events: auto; /* re-enable for interactive elements */
				background: transparent;
				border: none;
				padding: 0.2rem 0.4rem;
				color: inherit;
				cursor: pointer;
				opacity: 0.8;
				display: grid; /* overlay label + measure to reserve max width */
				align-items: center;
				justify-items: end;
				white-space: nowrap;
				/* custom property for animatable weight */
				--legal-link-wght: var(--legal-link-initial-weight);
	}

			.legal-link:hover,
			.legal-link:focus-visible {
				color: #ffffff;
				opacity: 1;
				text-shadow: 0 0 4px rgba(255,255,255,0.25);
				outline: none;
			}

			/* Overlaid spans: measure reserves hover width; label animates smoothly */
			.legal-link .measure,
			.legal-link .label { grid-area: 1 / 1; }

			.legal-link .measure {
				visibility: hidden; /* not visible but participates in layout sizing */
				pointer-events: none;
				user-select: none;
				white-space: nowrap;
				font-weight: var(--legal-link-hover-weight);
				letter-spacing: var(--legal-link-hover-tracking);
			}

			/* Smooth variable-font weight where supported */
			@supports (font-variation-settings: 'wght' 500) {
				/* Register animatable custom property for weight */
				@property --legal-link-wght {
					syntax: '<number>';
					inherits: true;
					initial-value: 500;
				}

					.legal-link .label {
					/* Use variable font axis for smooth boldness */
					font-variation-settings: 'wght' var(--legal-link-wght);
					letter-spacing: var(--legal-link-initial-tracking);
					transition: 
						--legal-link-wght var(--legal-link-transition-duration) ease,
						letter-spacing var(--legal-link-transition-duration) ease,
						color 120ms ease,
						opacity 120ms ease,
						text-shadow 120ms ease;
						/* Modern brutalist sans to vibe with site */
						font-family: 'Space Grotesk', system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
				}

				.legal-link:hover .label,
				.legal-link:focus-visible .label {
					--legal-link-wght: var(--legal-link-hover-weight);
					letter-spacing: var(--legal-link-hover-tracking);
				}
			}

			/* Fallback when variable fonts not available: animate letter-spacing only, keep layout stable via measure */
			@supports not (font-variation-settings: 'wght' 500) {
				.legal-link .label {
					font-weight: var(--legal-link-initial-weight);
					letter-spacing: var(--legal-link-initial-tracking);
					transition:
						letter-spacing var(--legal-link-transition-duration) ease,
						color 120ms ease,
						opacity 120ms ease,
						text-shadow 120ms ease;
				}
				.legal-link:hover .label,
				.legal-link:focus-visible .label {
					letter-spacing: var(--legal-link-hover-tracking);
				}
			}

		.legal-meta {
			font-size: 0.7rem;
			color: rgba(255, 255, 255, 0.45);
			pointer-events: none;
			margin-left: 0.25rem;
		}

	@media (max-width: 640px) {
		.legal-footer { gap: 0.4rem; font-size: 0.75rem; top: 0.5rem; right: 0.5rem; }
	}
</style>


--- END OF FILE src\lib\components\LegalFooter.svelte ---

--- START OF FILE src\lib\components\LoadingScreen.svelte ---
<!-- src/lib/components/LoadingScreen.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { overallLoadingState, initialSiteLoadComplete, minimumLoadingDuration } from '$lib/stores/preloadingStore';
  import { page } from '$app/stores';
  import { get } from 'svelte/store';

  let showScreen = !get(initialSiteLoadComplete);
  let isFadingOut = false;
  let textElement: HTMLDivElement;
  let tickerInstance: Ticker | null = null;
  
  const fadeOutDuration = 800; // ms
  const fadeOutDelay = 200; // ms
  
  let loadingStartTime = Date.now();
  let minimumDurationTimer: number | undefined;
  
  // Ticker class for continuous matrix-like animation
  class Ticker {
    private done = false;
    private cycleCount = 8;
    private cycleCurrent = 0;
    private chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-_=+{}|[]\\;\':"<>?,./`~'.split('');
    private charsCount = this.chars.length;
    private letters: HTMLSpanElement[] = [];
    private letterCount = 0;
    private letterCurrent = 0;
    private animationFrameId: number | null = null;
    private originalText: string;
    private continuousMode = false;

    constructor(element: HTMLDivElement, text: string) {
      this.originalText = text;
      this.setupLetters(element);
    }

    private setupLetters(element: HTMLDivElement) {
      element.innerHTML = '';
      this.letters = [];
      for (let i = 0; i < this.originalText.length; i++) {
        const span = document.createElement('span');
        span.setAttribute('data-orig', this.originalText[i]);
        span.textContent = '-';
        span.style.display = 'inline-block';
        element.appendChild(span);
        this.letters.push(span);
      }
      this.letterCount = this.letters.length;
    }

    private getChar(): string {
      return this.chars[Math.floor(Math.random() * this.charsCount)];
    }

    public start(): void {
      this.loop();
    }
    
    private loop = (): void => {
      if (this.continuousMode) {
        // In continuous mode, randomly glitch some letters periodically
        this.letters.forEach((letter) => {
          const orig = letter.getAttribute('data-orig');
          if (orig !== ' ' && Math.random() < 0.1) { // 10% chance per frame
            letter.textContent = this.getChar();
            letter.style.opacity = String(0.5 + Math.random() * 0.5);
            
            setTimeout(() => {
              letter.textContent = orig || '';
              letter.style.opacity = '1';
            }, 100 + Math.random() * 200);
          }
        });
      } else {
        // Original progressive reveal animation
        this.letters.forEach((letter, index) => {
          if (index >= this.letterCurrent) {
            const orig = letter.getAttribute('data-orig');
            if (orig !== ' ') {
              letter.textContent = this.getChar();
              letter.style.opacity = String(Math.random());
            }
          }
        });

        if (this.cycleCurrent < this.cycleCount) {
          this.cycleCurrent++;
        } else if (this.letterCurrent < this.letterCount) {
          const currLetter = this.letters[this.letterCurrent];
          this.cycleCurrent = 0;
          currLetter.textContent = currLetter.getAttribute('data-orig') || '';
          currLetter.style.opacity = '1';
          currLetter.style.transform = 'translateX(0) scale(1)';
          currLetter.classList.add('done');
          this.letterCurrent++;
        } else {
          this.done = true;
          // Switch to continuous mode after initial reveal
          this.continuousMode = true;
          this.done = false;
        }
      }

      if (!this.done) {
        this.animationFrameId = requestAnimationFrame(this.loop);
      }
    };

    public destroy(): void {
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      this.done = true;
    }
  }

  function handleLoadingComplete() {
    if (isFadingOut) return;
    
    const elapsedTime = Date.now() - loadingStartTime;
    const remainingMinimumTime = Math.max(0, minimumLoadingDuration - elapsedTime);
    
    minimumDurationTimer = setTimeout(() => {
      if (tickerInstance) {
        tickerInstance.destroy();
      }
      isFadingOut = true;
      
      setTimeout(() => {
        showScreen = false;
      }, fadeOutDuration + fadeOutDelay);
    }, remainingMinimumTime);
  }

  const unsubInitialLoad = initialSiteLoadComplete.subscribe(completed => {
    if (completed && showScreen && !isFadingOut) {
      handleLoadingComplete();
    }
  });

  const unsubOverallState = overallLoadingState.subscribe(status => {
    if (get(initialSiteLoadComplete)) return;
    
    if (status === 'error' && textElement) {
      clearTimeout(minimumDurationTimer);
      if (tickerInstance) tickerInstance.destroy();
  const msg = (($page.data as any)?.messages?.common?.loading?.error) ?? 'ERROR LOADING';
  tickerInstance = new Ticker(textElement, msg);
      tickerInstance.start();
    }
  });

  onMount(() => {
    loadingStartTime = Date.now();
    if (!get(initialSiteLoadComplete) && textElement) {
      const msg = (($page.data as any)?.messages?.common?.loading?.loading) ?? 'LOADING...';
      tickerInstance = new Ticker(textElement, msg);
      tickerInstance.start();
    }
  });

  onDestroy(() => {
    if (tickerInstance) tickerInstance.destroy();
    clearTimeout(minimumDurationTimer);
    unsubOverallState();
    unsubInitialLoad();
  });
</script>

{#if showScreen}
  <div class="loading-overlay" class:fade-out={isFadingOut} style="--fade-duration: {fadeOutDuration}ms;">
    <div class="loading-content">
      <div class="word" bind:this={textElement}></div>
      <div class="scanline-overlay"></div>
    </div>
  </div>
{/if}

<style>
  .loading-overlay {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: radial-gradient(ellipse at center, #0a1a0a 0%, #000500 100%);
    display: flex; justify-content: center; align-items: center; z-index: 10000;
    opacity: 1; transition: opacity var(--fade-duration) cubic-bezier(0.4, 0, 0.2, 1);
  }
  .loading-overlay.fade-out { opacity: 0; pointer-events: none; }
  .loading-content { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
  .word {
    color: #fff; font-family: 'Source Code Pro', 'Courier New', monospace; font-weight: 400; font-size: clamp(1.5rem, 4vw, 2.5rem); text-transform: uppercase; letter-spacing: 0.15em;
    text-shadow: 0 0 10px rgba(50, 255, 50, 0.5), 0 0 20px rgba(100, 255, 100, 0.5), 0 0 30px rgba(50, 255, 50, 0.3), 0 0 40px rgba(100, 255, 100, 0.2);
    position: relative; z-index: 2; animation: flicker 4s linear infinite;
  }
  .word :global(span) { display: inline-block; transform: translateX(100%) scale(0.9); transition: transform 500ms cubic-bezier(0.4, 0, 0.2, 1); will-change: transform, opacity; }
  .word :global(.done) { color: #6f6; transform: translateX(0) scale(1) !important; }
  .scanline-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: repeating-linear-gradient( 0deg, transparent, transparent 2px, rgba(50, 255, 50, 0.03) 2px, rgba(50, 255, 50, 0.03) 4px ); background-size: 100% 4px; animation: scanline 8s linear infinite; pointer-events: none; z-index: 1; }
  .scanline-overlay::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient( 180deg, transparent 0%, rgba(50, 255, 50, 0.02) 50%, transparent 100% ); animation: scanline-move 3s linear infinite; }
  @keyframes scanline { 0% { background-position: 0 0; } 100% { background-position: 0 10px; } }
  @keyframes scanline-move { 0% { transform: translateY(-100%); } 100% { transform: translateY(100%); } }
  @keyframes flicker { 0%, 100% { opacity: 1; } 92% { opacity: 0.95; } 94% { opacity: 1; } 96% { opacity: 0.97; } }
  @media (max-width: 640px) { .word { font-size: 1.25rem; letter-spacing: 0.1em; } }
  @media (prefers-reduced-motion: reduce) { .word :global(span) { transition: none; } .scanline-overlay, .scanline-overlay::before { animation: none; } }
</style>
--- END OF FILE src\lib\components\LoadingScreen.svelte ---

--- START OF FILE src\lib\components\MobileNavDots.svelte ---
<!-- src/lib/components/MobileNavDots.svelte -->
<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import { onMount } from 'svelte';

  export let sections: { id: string; label?: string }[] = [];
  export let activeIndex = 0;

  const dispatch = createEventDispatcher<{ select: { index: number } }>();

  function onSelect(i: number) {
    dispatch('select', { index: i });
  }
</script>

<nav class="mobile-dots" aria-label="Section navigation">
  <ul>
    {#each sections as s, i}
      <li>
        <button
          class:active={i === activeIndex}
          aria-label={s.label ?? s.id}
          aria-current={i === activeIndex ? 'true' : undefined}
          on:click={() => onSelect(i)}
        ></button>
      </li>
    {/each}
  </ul>
</nav>

<style>
  .mobile-dots { position: fixed; right: max(8px, env(safe-area-inset-right)); top: 50%; transform: translateY(-50%); z-index: 5; }
  .mobile-dots ul { list-style: none; margin: 0; padding: 8px; display: flex; flex-direction: column; gap: 12px; }
  .mobile-dots li { margin: 0; padding: 0; }
  .mobile-dots button { 
    width: 8px; height: 8px; border-radius: 50%; border: none; 
    background: rgba(255,255,255,0.8); display: block; padding: 0; cursor: pointer; 
    transform-origin: center; transition: transform 220ms cubic-bezier(.2,.8,.2,1), background-color 180ms ease; 
  }
  .mobile-dots button.active { 
    transform: scale(1.7); 
    background: rgba(255,255,255,1);
  }
  @media (min-width: 769px) { .mobile-dots { display: none; } }
</style>

--- END OF FILE src\lib\components\MobileNavDots.svelte ---

--- START OF FILE src\lib\components\ParallaxCard.svelte ---
<!-- src/lib/components/ParallaxCard.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import type { ProjectCard } from '$lib/data/projectsData';
  import { page } from '$app/stores';

  export let cardData: ProjectCard;
  export let width: string = '240px';
  export let height: string = '320px';

  let cardWrapElement: HTMLDivElement;
  let elementWidth: number = 0;
  let elementHeight: number = 0;
  let rectLeft: number = 0;
  let rectTop: number = 0;
  let mouseX: number = 0; // relative to center
  let mouseY: number = 0; // relative to center
  let mouseLeaveDelay: number | null = null;
  let hasPointer = false;
  let rafId: number | null = null;
  let needsFrame = false;
  let lastPointerX = 0;
  let lastPointerY = 0;
  // Adaptive fidelity (lightweight moving average)
  let frameTimes: number[] = [];
  const FRAME_WINDOW = 50;
  const HIGH_MS = 19.5;
  const LOW_MS = 14.0;
  let quality = 1.0; // 1.0 high, 0.7 low
  let scaleCooldown = 0;
  const SCALE_COOLDOWN_FRAMES = 45;

  onMount(() => {
    if (!cardWrapElement) return;
    // Initial rect
    const rect = cardWrapElement.getBoundingClientRect();
    elementWidth = rect.width;
    elementHeight = rect.height;
    rectLeft = rect.left;
    rectTop = rect.top;

    // Observe size changes
    const ro = new ResizeObserver(entries => {
      for (const entry of entries) {
        if (entry.target === cardWrapElement) {
          const cr = entry.contentRect;
          elementWidth = cr.width;
          elementHeight = cr.height;
          // Left/top may change with layout; recalc bounding rect
          const r = cardWrapElement.getBoundingClientRect();
          rectLeft = r.left; rectTop = r.top;
        }
      }
    });
    ro.observe(cardWrapElement);

    // IntersectionObserver to gate work when offscreen
    const io = new IntersectionObserver((entries) => {
      entries.forEach(e => {
        if (e.target === cardWrapElement) {
          if (!e.isIntersecting) {
            detachPointer();
            cancelRaf();
            mouseX = 0; mouseY = 0;
          }
        }
      });
    }, { root: null, threshold: 0 });
    io.observe(cardWrapElement);

    // Cleanup
    onDestroy(() => { ro.disconnect(); io.disconnect(); cancelRaf(); });
  });

  onDestroy(() => {
    if (mouseLeaveDelay) clearTimeout(mouseLeaveDelay);
  });

  $: mousePX = mouseX / elementWidth;
  $: mousePY = mouseY / elementHeight;
  // Parallax amplitude scaled by quality for adaptive fidelity
  $: rX = !isNaN(mousePX) ? mousePX * (30 * quality) : 0;
  $: rY = !isNaN(mousePY) ? mousePY * (-30 * quality) : 0;
  $: tX = !isNaN(mousePX) ? mousePX * (-40 * quality) : 0;
  $: tY = !isNaN(mousePY) ? mousePY * (-40 * quality) : 0;
  $: cardStyle = `transform: rotateY(${rX}deg) rotateX(${rY}deg) translateZ(0);`;
  $: cardBgTransform = `transform: translate3d(${tX}px, ${tY}px, 0);`;
  $: cardBgImage = cardData.cardImage ? `background-image: url(${cardData.cardImage});` : '';

  function scheduleFrame() {
    if (rafId !== null) return; // already scheduled
    rafId = requestAnimationFrame(() => {
      rafId = null;
      // Update frame-time window
      const now = performance.now();
      const prev = (scheduleFrame as any)._prev || now;
      (scheduleFrame as any)._prev = now;
      const dtMs = Math.max(0.016, now - prev);
      frameTimes.push(dtMs);
      if (frameTimes.length > FRAME_WINDOW) frameTimes.shift();
      if (frameTimes.length === FRAME_WINDOW) {
        const avg = frameTimes.reduce((a,b)=>a+b,0)/frameTimes.length;
        if (scaleCooldown > 0) scaleCooldown--;
        let changed = false;
        if (scaleCooldown === 0) {
          if (avg > HIGH_MS && quality > 0.7) { quality = +(Math.max(0.7, quality - 0.1)).toFixed(2); changed = true; }
          else if (avg < LOW_MS && quality < 1.0) { quality = +(Math.min(1.0, quality + 0.1)).toFixed(2); changed = true; }
          if (changed) scaleCooldown = SCALE_COOLDOWN_FRAMES;
        }
      }
      if (!needsFrame) return;
      needsFrame = false;
      // Compute relative to cached rect and element size
      const cx = lastPointerX - rectLeft - elementWidth / 2;
      const cy = lastPointerY - rectTop - elementHeight / 2;
      mouseX = cx; mouseY = cy;
    });
  }

  function cancelRaf() { if (rafId !== null) { cancelAnimationFrame(rafId); rafId = null; } }

  function handlePointerMove(e: PointerEvent) {
    if (!cardWrapElement) return;
    lastPointerX = e.clientX; lastPointerY = e.clientY;
    needsFrame = true;
    scheduleFrame();
  }

  function attachPointer() {
    if (!cardWrapElement || hasPointer) return;
    hasPointer = true;
    cardWrapElement.addEventListener('pointermove', handlePointerMove);
    // Update cached rect on enter for accuracy
    const r = cardWrapElement.getBoundingClientRect();
    rectLeft = r.left; rectTop = r.top; elementWidth = r.width; elementHeight = r.height;
  }
  function detachPointer() {
    if (!cardWrapElement || !hasPointer) return;
    hasPointer = false;
    cardWrapElement.removeEventListener('pointermove', handlePointerMove);
  }

  function handleMouseEnter() {
    if (mouseLeaveDelay) clearTimeout(mouseLeaveDelay);
    attachPointer();
  }

  function handleMouseLeave() {
    mouseLeaveDelay = window.setTimeout(() => {
      mouseX = 0;
      mouseY = 0;
    }, 1000);
    detachPointer();
  }
</script>

<div
  class="card-wrap"
  style:width
  style:height
  on:mouseenter={handleMouseEnter}
  on:mouseleave={handleMouseLeave}
  bind:this={cardWrapElement}
  role="group"
  aria-label={(($page.data as any)?.messages?.common?.projects?.cardAriaPrefix ?? 'Interactive project card for') + ' ' + cardData.title}
>
  <div class="card" style={cardStyle}>
    <div class="card-bg" style="{cardBgTransform} {cardBgImage}" id="card-bg-{cardData.id}"></div>
    <div class="card-info">
      <h3 class="card-title">{cardData.title}</h3>
      {#if cardData.description}
        <p class="card-description">{cardData.description}</p>
      {/if}
    </div>
  </div>
</div>

<style>
  :root {
    /* === TUNING PARAMETERS START === */
    /* Positioning */
    --card-info-padding: 20px;
    --card-title-bottom-anchor: 15%;
    --card-description-bottom-anchor: 5%;
    
    /* Animation */
    --card-title-transition-duration: 0.8s;
    --card-title-hover-lift: -40px;
    /* FIX: New parameters to control font weight */
    --card-title-initial-weight: 500; /* Starting weight (e.g., 400=normal) */
    --card-title-hover-weight: 800;   /* Ending weight (e.g., 900=extra-bold) */

    --card-description-fade-duration: 1.5s;
    --card-description-slide-duration: 1.3s;
    --card-description-initial-offset: 100px;
    /* === TUNING PARAMETERS END === */
  }

  .card-wrap {
    margin: 10px;
    transform: perspective(800px);
    transform-style: preserve-3d;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
  will-change: transform;
  }

  .card-wrap:hover .card-title {
    font-weight: var(--card-title-hover-weight);
    letter-spacing: 0.03em;
    transform: translateY(var(--card-title-hover-lift));
  }
  
  .card-wrap:hover .card-description {
    opacity: 1;
    transform: translateY(0);
  }
  
  .card-wrap:hover .card-bg {
    transition: 0.6s cubic-bezier(0.23, 1, 0.32, 1), opacity 5s cubic-bezier(0.23, 1, 0.32, 1);
    opacity: 0.8;
  }
  .card-wrap:hover .card {
    transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1), box-shadow 2s cubic-bezier(0.23, 1, 0.32, 1);
    box-shadow: rgba(255, 255, 255, 0.2) 0 0 40px 5px, white 0 0 0 1px, rgba(0, 0, 0, 0.66) 0 30px 60px 0, inset #333 0 0 0 5px, inset white 0 0 0 6px;
  }

  .card {
    position: relative;
    width: 100%;
    height: 100%;
    background-color: #333;
    overflow: hidden;
    border-radius: 10px;
    transition: transform 1s cubic-bezier(0.445, 0.05, 0.55, 0.95), box-shadow 1s cubic-bezier(0.445, 0.05, 0.55, 0.95);
  will-change: transform;
  contain: paint;
  }

  .card-bg {
    opacity: 0.5;
    position: absolute;
    top: -20px;
    left: -20px;
    width: calc(100% + 40px);
    height: calc(100% + 40px);
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
    transition: 1s cubic-bezier(0.445, 0.05, 0.55, 0.95), opacity 5s 1s cubic-bezier(0.445, 0.05, 0.55, 0.95);
    pointer-events: none;
  will-change: transform, opacity;
  }

  .card-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    color: #fff;
    padding: var(--card-info-padding);
    text-align: center;
  }
  
  .card-title {
    position: absolute;
    left: var(--card-info-padding);
    right: var(--card-info-padding);
    bottom: var(--card-title-bottom-anchor);
    
    font-size: clamp(1.4rem, 10vw, 2rem);
    font-family: 'Playfair Display', serif;
    text-shadow: rgba(0, 0, 0, 0.5) 0 10px 10px;
    letter-spacing: 0.01em;
    transform: translateY(0);
    
    /* FIX: Use the new variable for the initial weight */
    font-weight: var(--card-title-initial-weight);
    
    transition: 
      font-weight var(--card-title-transition-duration) ease, 
      letter-spacing var(--card-title-transition-duration) ease,
      transform var(--card-title-transition-duration) cubic-bezier(0.23, 1, 0.32, 1);
  }
  
  .card-description {
    position: absolute;
    left: var(--card-info-padding);
    right: var(--card-info-padding);
    bottom: var(--card-description-bottom-anchor);

    opacity: 0;
    transform: translateY(var(--card-description-initial-offset));
    
    transition: 
      opacity var(--card-description-fade-duration) cubic-bezier(0.16, 1, 0.3, 1),
      transform var(--card-description-slide-duration) cubic-bezier(0.16, 1, 0.3, 1);
    
    text-shadow: black 0 2px 3px;
    font-size: 0.9rem;
    line-height: 1.5;
  }
</style>
--- END OF FILE src\lib\components\ParallaxCard.svelte ---

--- START OF FILE src\lib\components\TransitionOverlay.svelte ---
<!-- src/lib/components/TransitionOverlay.svelte -->
<script lang="ts">
  import { transitionStore } from '$lib/stores/transitionStore';
  import { fade } from 'svelte/transition';

  // --- MODIFICATION: Define the duration here to keep it in sync with the store ---
  const TRANSITION_DURATION = 90; // ms
</script>

{#if $transitionStore.visible}
  <div 
    class="transition-overlay"
    style="background-color: {$transitionStore.color};"
    transition:fade={{ duration: TRANSITION_DURATION }}
  ></div>
{/if}

<style>
  .transition-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 99999; /* Must be on top of everything */
    pointer-events: all; /* Block interactions during transition */
  }
</style>
--- END OF FILE src\lib\components\TransitionOverlay.svelte ---

--- START OF FILE src\lib\components\layouts\ProjectOneLayout.svelte ---
<!-- src/lib/components/layouts/ProjectOneLayout.svelte -->
<script lang="ts">
  import type { Project, ProjectCard, ProjectSubPageSection } from '$lib/data/projectsData';
  import { transitionStore } from '$lib/stores/transitionStore';
  import { page } from '$app/stores';
  import ParallaxCard from '$lib/components/ParallaxCard.svelte';
  import { renderProfile } from '$lib/stores/renderProfile';

  export let headline: string;
  export let summary: string;
  export let cards: ProjectCard[];
  export let slug: string;
  export let readMoreLinkText: string | undefined = undefined;
  export let readMoreFallbackLabel: string | undefined = undefined;
  export let backgrounds: Project['backgrounds'];
  // --- MODIFICATION: Added prop for subPageSections to enable intelligent preloading ---
  export let subPageSections: ProjectSubPageSection[];

  function handleCardClick(card: ProjectCard) {
    const lang = $page.params?.lang ?? 'de';
    let hash = '';
    if (card.aspectLink) {
      const targetId = card.aspectLink.replace(/^#/, '');
      const target = subPageSections.find(s => s.id === targetId);
      if (target && target.background.type === 'image') {
        const img = new Image();
        img.src = target.background.value;
        console.log(`[Preloader] Preloading background for '${targetId}': ${target.background.value}`);
      }
      // Keep hash for deep-linking the subsection
      hash = `#${targetId}`;
    }
    transitionStore.fadeToBlackAndNavigate(`/${lang}/projects/${slug}${hash}`);
  }

  function handleReadMoreClick() {
    // --- MODIFICATION: Preload the background for the FIRST sub-section (the overview). ---
    // The overview's background is the first image in the main `backgrounds` array.
    if (backgrounds && backgrounds.length > 0 && backgrounds[0].type === 'image') {
      const imageToPreload = new Image();
      imageToPreload.src = backgrounds[0].value;
      console.log(`[Preloader] Proactively loading background for project overview: ${backgrounds[0].value}`);
    }

  const lang = $page.params?.lang ?? 'de';
  transitionStore.fadeToBlackAndNavigate(`/${lang}/projects/${slug}`);
  }
</script>

<div class="layout-container">
  <div class="text-block">
    <h2 class="anim-headline">{headline}</h2>
    <p class="anim-summary">{summary}</p>
    {#if readMoreLinkText || readMoreFallbackLabel}
      <button class="read-more-btn anim-button" on:click={handleReadMoreClick}>
        <svg>
          <rect x="0" y="0" fill="none" width="100%" height="100%"/>
        </svg>
        <span>{readMoreLinkText ?? readMoreFallbackLabel}</span>
      </button>
    {/if}
  </div>

  <div class="cards-block">
    {#each cards as card, i (card.id)}
      <div class="card-wrapper anim-card" style="--card-index: {i};">
  <button type="button" class="card-click-target" on:click={() => handleCardClick(card)} aria-label={(($page.data as any)?.messages?.common?.projects?.viewDetailsPrefix ?? 'View details for') + ' ' + card.title}>
          <ParallaxCard
            cardData={card}
            width={$renderProfile.isMobile ? '100%' : '240px'}
            height={$renderProfile.isMobile ? 'auto' : '320px'}
          />
        </button>
      </div>
    {/each}
  </div>
</div>

<style>
  .layout-container {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  .text-block {
    position: absolute;
    bottom: 12vh;
    left: max(calc(env(safe-area-inset-left, 0px) + 8vw), 3rem);
    width: 40%;
    max-width: 550px;
    z-index: 2;
  }

  h2 {
    font-size: clamp(2.2rem, 5vw, 3.8rem);
    font-weight: 300;
    margin-bottom: 1.5rem;
    letter-spacing: -0.02em;
    line-height: 1.1;
    text-shadow: 0 3px 15px rgba(0,0,0,0.3);
  }

  p {
    font-size: clamp(1rem, 1.8vw, 1.15rem);
    color: rgb(212 212 216);
    line-height: 1.8;
    margin-bottom: 2.5rem;
    text-shadow: 0 2px 8px rgba(0,0,0,0.5);
  }

  .read-more-btn {
    position: relative;
    padding: 0.875rem 2rem;
    min-width: 220px;
    
    background-color: transparent;
    
    font-family: 'Source Code Pro', monospace;
    font-weight: 300;
    font-size: 1rem;
    color: white;
    text-transform: uppercase;
    letter-spacing: 0.05em;

    border: none;
    cursor: pointer;
    
    transition: box-shadow 0.6s ease, font-weight 0.6s ease, letter-spacing 0.6s ease;
  }

  .read-more-btn span {
    position: relative;
    z-index: 1;
  }

  .read-more-btn svg {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
  }

  .read-more-btn rect {
    fill: none;
    stroke: rgba(255, 255, 255, 0.7);
    stroke-width: 1px;
    stroke-dasharray: 400;
    stroke-dashoffset: 400;
    transition: stroke-dashoffset 0.8s cubic-bezier(0.19, 1, 0.22, 1), 
                stroke-width 0.4s ease,
                stroke 0.4s ease;
  }

  .read-more-btn:hover {
    box-shadow: 0 0 25px -5px rgba(255, 255, 255, 0.6);
    font-weight: 700;
    letter-spacing: 0.1em;
  }

  .read-more-btn:hover rect {
    stroke-width: 2px;
    stroke-dashoffset: 0;
    stroke: rgba(255, 255, 255, 1);
  }

  .cards-block {
    position: absolute;
    top: 50%;
    right: max(6vw, 2rem);
    transform: translateY(-50%);
    width: 50%;
    z-index: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 2rem;
  }
  
  .card-click-target {
    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    border-radius: 10px;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
  }

  .card-click-target :global(.card) {
    box-shadow: inset #333 0 0 0 5px, inset rgba(255, 255, 255, 0.5) 0 0 0 6px;
  }

  .card-click-target:hover {
    transform: translateY(-8px) scale(1.02);
  }

  .card-click-target:hover :global(.card),
  .card-click-target:focus-visible :global(.card) {
    box-shadow: 
      rgba(255, 255, 255, 0.2) 0 0 40px 5px, 
      rgba(0, 0, 0, 0.66) 0 30px 60px 0, 
      inset #333 0 0 0 5px,
      inset white 0 0 0 6px;
  }

  .card-click-target:focus-visible :global(.card) {
    box-shadow: 
      rgba(255, 255, 255, 0.2) 0 0 40px 5px, 
      rgba(0, 0, 0, 0.66) 0 30px 60px 0, 
      inset #333 0 0 0 5px,
      inset rgb(99 102 241) 0 0 0 7px;
  }

  /* Mobile-only reflow: keep desktop unchanged */
  @media (max-width: 768px) {
    .layout-container {
      height: auto;
      min-height: 100vh;
    }
    .text-block {
      position: static;
      left: auto;
      bottom: auto;
      width: auto;
      max-width: none;
      padding: 2rem 4vw 1rem;
    }
    .cards-block {
      position: static;
      top: auto;
      right: auto;
      transform: none;
      width: 100%;
      /* Use variables to keep columns within viewport including gap */
      --grid-gap: 4vw;
      --grid-pad: 4vw;
      padding: 0 var(--grid-pad) 2rem;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, calc((100% - var(--grid-gap)) / 2)));
      column-gap: var(--grid-gap);
      row-gap: var(--grid-gap);
      align-items: start;
      justify-items: stretch;
      box-sizing: border-box;
      overflow-x: hidden;
    }
    .card-wrapper {
      width: 100%;
    }
    .card-click-target {
      display: block;
      width: 100%;
    }
    /* Remove inner ParallaxCard margins to avoid squishing */
    .cards-block :global(.card-wrap) {
  margin: 0;
  width: 100%;
  aspect-ratio: 2 / 3; /* keeps a tall card while allowing full cell width */
      box-sizing: border-box;
    }
  }
</style>
--- END OF FILE src\lib\components\layouts\ProjectOneLayout.svelte ---

--- START OF FILE src\lib\components\sections\AboutSection.svelte ---
<!-- src/lib/components/sections/AboutSection.svelte -->
<script context="module" lang="ts">
  export type AboutSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    initializeEffect?: () => Promise<void>;
    // Add the new optional method to its type definition
    onTransitionComplete?: () => void;
  };
</script>

<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import { siteConfig } from '$lib/data/siteConfig';

  import KeyboardButtons from '$lib/components/KeyboardButtons.svelte';
  import AboutImageEffect from '$lib/components/AboutImageEffect.svelte';
  import type { KeyboardButtonsInstance } from '$lib/components/KeyboardButtons.svelte';
  import type { AboutImageEffectInstance } from '$lib/components/AboutImageEffect.svelte';
  import { renderProfile } from '$lib/stores/renderProfile';

  const dispatch = createEventDispatcher();

  type AboutSectionData = typeof siteConfig.aboutSection;
  export let data: AboutSectionData;
  export let contactSectionIndex: number;
  export let navigateToSection: (index: number) => void;

  let keyboardButtonsInstance: KeyboardButtonsInstance | null = null;
  let aboutImageEffectInstance: AboutImageEffectInstance | null = null;

  // This is called by the preload manager while the section is off-screen.
  export async function initializeEffect() {
    if (aboutImageEffectInstance?.initializeEffect) {
      await aboutImageEffectInstance.initializeEffect();
    }
  }

  // This is called at the START of the page transition.
  // It should only contain lightweight animations.
  export function onEnterSection(): void {
    if (keyboardButtonsInstance) {
      keyboardButtonsInstance.onEnterSection();
    }
    if (aboutImageEffectInstance) {
      // The image effect's onEnterSection just starts a simple fade-in.
      aboutImageEffectInstance.onEnterSection();
    }
  }
  
  // FIX: This is called at the END of the page transition.
  // It's for heavy, layout-dependent animations.
  export function onTransitionComplete() {
    if (aboutImageEffectInstance?.onTransitionComplete) {
      // This starts the particle rendering, which depends on the final layout.
      aboutImageEffectInstance.onTransitionComplete();
    }
  }

  // This is called when navigating away from the section.
  export function onLeaveSection(): void {
    if (keyboardButtonsInstance) {
      keyboardButtonsInstance.onLeaveSection();
    }
    if (aboutImageEffectInstance) {
      aboutImageEffectInstance.onLeaveSection();
    }
  }

  function handleAnimationComplete() {
    dispatch('animationComplete');
  }
</script>

<div class="about-section-wrapper">
  <div class="about-content-wrapper">
    <KeyboardButtons 
      bind:this={keyboardButtonsInstance}
      title={data.title}
      introduction={data.introduction}
      socialLinks={data.socialLinks}
      {contactSectionIndex}
      {navigateToSection}
      on:animationComplete={handleAnimationComplete}
    />
  </div>

  <AboutImageEffect
    bind:this={aboutImageEffectInstance}
    imageUrl={data.imageUrl}
  mobileMode={$renderProfile.isMobile}
  />
</div>

<style>
  .about-section-wrapper {
    width: 100%;
    height: 100%;
    padding: 0;
    text-align: left;
    background-color: transparent;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
  }

  .about-content-wrapper {
    position: relative;
    z-index: 3;
    flex-grow: 1;
    height: 100%;
    display: flex;
    justify-content: flex-start;
    align-items: center;
    padding: 3rem max(calc(env(safe-area-inset-left, 0px) + 6vw), 3rem);
    padding-right: 2rem;
    box-sizing: border-box;
  }
  
  @media (max-width: 768px) {
    .about-section-wrapper { 
      flex-direction: column;
      justify-content: center;
  padding: 2rem; 
  align-items: stretch;
    }

    .about-content-wrapper { 
  justify-content: flex-start; 
  text-align: left; 
      padding: 1rem 1rem 2rem;
      width: 100%;
      flex-grow: 0;
      z-index: 2;
    }

    .about-section-wrapper :global(.image-pane) {
      justify-content: center;
    }

    .about-section-wrapper :global(.image-pane img) {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
    }
  }
</style>
--- END OF FILE src\lib\components\sections\AboutSection.svelte ---

--- START OF FILE src\lib\components\sections\ContactEffect.svelte ---
<!-- src/lib/components/sections/ContactEffect.svelte -->
<script context="module" lang="ts">
  // Public instance API for the orchestrator to call.
  export type ContactEffectInstance = {
    initializeEffect: () => Promise<void>;
    onEnterSection: () => void;
    onLeaveSection: () => void;
    onTransitionComplete: () => void;
    onUnload: () => void;
  };
</script>

<script lang="ts">
  import { onMount, onDestroy, tick } from 'svelte';
  import * as THREE from 'three';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
  import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
  import { FXAAShader } from 'three/examples/jsm/shaders/FXAAShader.js';
  import { GammaCorrectionShader } from 'three/examples/jsm/shaders/GammaCorrectionShader.js';
  import { gsap } from 'gsap';
  import { prefersReducedMotion as prm } from '$lib/stores/renderProfile';
  import type { ShaderMaterial } from 'three';

  let container: HTMLDivElement;
  let effectInstance: RaymarchingEffect | null = null;
  let isInitialized = false;

  // -----------------------------
  // Animation Lifecycle API
  // -----------------------------
  export async function initializeEffect(): Promise<void> {
    if (isInitialized) return;
    await tick();
    if (!container) return;

    effectInstance = new RaymarchingEffect(container);
    await effectInstance.init();
    isInitialized = true;
  }

  export function onEnterSection(): void {
    if (!container) return;
    gsap.set(container, { autoAlpha: 0 });
  }

  export function onTransitionComplete(): void {
    if ($prm) return;
    if (effectInstance) {
      effectInstance.neutralizeState(0);
      effectInstance.startAnimationLoop();
      gsap.to(container, { autoAlpha: 1, duration: 1.2, ease: 'power2.inOut' });
    }
  }

  export function onLeaveSection(): void {
    if (!container) return;
    gsap.killTweensOf(container);

    if (effectInstance) {
      effectInstance.neutralizeState(0.45);
    }

    gsap.to(container, {
      autoAlpha: 0,
      duration: 0.7,
      ease: 'power2.out',
      onComplete: () => {
        if (effectInstance) {
          effectInstance.stopAnimationLoop();
        }
        gsap.set(container, { autoAlpha: 0 });
      }
    });
  }

  export function onUnload(): void {
    if (container) {
      gsap.killTweensOf(container);
    }

    if (effectInstance) {
      effectInstance.dispose();
      effectInstance = null;
    }
    isInitialized = false;
  }

  onMount(() => {
    // Initialization deferred to the animation lifecycle API.
  });

  onDestroy(() => {
    onUnload();
  });

  // Runtime reaction to reduced-motion preference
  $: if ($prm) {
    if (effectInstance) effectInstance.stopAnimationLoop();
    if (container) {
      gsap.killTweensOf(container);
      gsap.set(container, { autoAlpha: 0 });
    }
  }

  // -----------------------------
  // RaymarchingEffect class
  // -----------------------------
  class RaymarchingEffect {
    private container: HTMLElement;

    // ThreeJS core
    private renderer!: THREE.WebGLRenderer;
    private scene!: THREE.Scene;
    private camera!: THREE.OrthographicCamera;
    private material!: ShaderMaterial;
    private quad!: THREE.Mesh;

    // Post-processing
    private bloomComposer!: EffectComposer;
    private finalComposer!: EffectComposer;
    private bloomPass!: UnrealBloomPass;

    // Animation & input
    private clock: THREE.Clock;
    private animationFrameId: number | null = null;
    private isLooping = false;
    private boundOnMouseMove: (e: MouseEvent) => void;
  private boundOnMouseDown: (e: MouseEvent) => void;
  private boundOnTouchStart: (e: TouchEvent) => void;
  private boundOnTouchMove: (e: TouchEvent) => void;
  private boundOnTouchEnd: (e: TouchEvent) => void;
    private boundOnResize: () => void;
    private mousePos = new THREE.Vector2(0.5, 0.5);   // smoothed pointer (for shader)
    private targetMouse = new THREE.Vector2(0.5, 0.5); // raw pointer target

    // ----- PARAMETERS (grouped & commented for easy tuning) -----
    // Visual / lighting defaults (moody)
    private readonly AMBIENT_INTENSITY = 0.05;
    private readonly DIFFUSE_INTENSITY = 0.4;
    private readonly SPECULAR_INTENSITY = 2.0;
    private readonly SPECULAR_POWER = 8.0;
    private readonly FRESNEL_POWER = 1.0;
    private readonly CONTRAST = 1.2;
    private readonly FOG_DENSITY = 0.15;

    // Motion & spheres
    private SPHERE_COUNT = 6; // 4 for max performance
    private readonly MAX_SPHERES = 12; // keep consistent with shader define
    private readonly BLEND_SMOOTHNESS = 0.35;
    private readonly ANIMATION_SPEED = 0.9;
    private readonly CAMERA_DISTANCE = 3.0;
    private readonly MOVEMENT_PATTERN = 0;
    private readonly MOVEMENT_SPEED = 0.9;
    private readonly MOVEMENT_SCALE = 1.0;
    private readonly INDIVIDUAL_ROTATION = true;
    private readonly MOUSE_PROXIMITY_EFFECT = true;
    private readonly MOUSE_SMOOTHNESS = 0.12; // how quickly mousePos lerps to targetMouse

    // Movement smoothing / inertia (frame-rate independent)
    private readonly SCALE_SMOOTHING_RATE = 4.0;   // higher = faster response, lower = heavier inertia
    private readonly POSITION_SMOOTHING_RATE = 9.0;

    // Movement extents
    private readonly MIN_MOVEMENT_SCALE_ON_HOVER = 0.1;
    private readonly MAX_MOVEMENT_SCALE_ON_HOVER = 1.6;

    // LOD / Perf tuning
    private baseMaxSteps = 80;
    private minMaxSteps = 28;
    private pixelRatioCap = 2;
    private reducedPixelRatio = 1.0;

    // CPU -> GPU sphere buffer (x, y, z, radius) for each sphere
    private sphereData: Float32Array;
    private sphereParams: Array<{
      speed: number;
      radius: number;
      orbitBase: number;
      phase: number;
      rotOffset: number;
      pos: THREE.Vector3;        // current smoothed position
      targetPos: THREE.Vector3;  // instantaneous target position
    }>;

    // internal smoothing state
    private smoothedScale = this.MOVEMENT_SCALE;

    // Internal state
    private isDisposed = false;

    private internalScale = 1.0; // dynamic internal resolution scale (1.0 = up to 1440p cap)
    private readonly MAX_INTERNAL_DIM = 1440; // 1440p cap (applies to larger viewport dimension)

    // frame time tracking for performance scaling
    private frameTimes: number[] = [];
    private readonly FRAME_WINDOW = 40; // number of frames for moving average
    private readonly TARGET_FRAME_MS = 16.6; // 60fps budget
    private readonly HIGH_THRESHOLD = 19.5; // trigger downscale if avg above
    private readonly LOW_THRESHOLD = 14.0;  // trigger upscale if avg below
    private readonly SCALE_FLOOR = 0.6;
    private readonly SCALE_CEIL = 1.0;
    private scaleCooldown = 0; // frames until next allowed scale change
    private readonly SCALE_COOLDOWN_FRAMES = 45;

    // sphere count tiering
    private sphereTierCooldown = 0;
    private readonly SPHERE_TIER_COOLDOWN_FRAMES = 240; // 4s at 60fps
    private readonly SPHERE_TIERS = [6,4,3]; // descending complexity

    constructor(container: HTMLElement) {
      this.container = container;
      this.clock = new THREE.Clock();
      this.boundOnMouseMove = this.onMouseMove.bind(this);
  this.boundOnMouseDown = this.onMouseDown.bind(this);
  this.boundOnTouchStart = this.onTouchStart.bind(this);
  this.boundOnTouchMove = this.onTouchMove.bind(this);
  this.boundOnTouchEnd = this.onTouchEnd.bind(this);
      this.boundOnResize = this.onWindowResize.bind(this);

      // prepare typed arrays and params
      this.sphereData = new Float32Array(this.MAX_SPHERES * 4);
      this.sphereParams = [];
      for (let i = 0; i < this.MAX_SPHERES; i++) {
        this.sphereParams.push({
          speed: 0.55 + i * 0.12,
          radius: 0.12 + (i % 3) * 0.06,
          orbitBase: 0.45 + (i % 5) * 0.14,
          phase: i * Math.PI * 0.21,
          rotOffset: Math.random() * Math.PI * 2,
          pos: new THREE.Vector3(),
          targetPos: new THREE.Vector3()
        });
      }
    }

    // init is async because we attempt to dynamically import the optimized shader (fallback handled)
    public async init(): Promise<void> {
      this.scene = new THREE.Scene();
      this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
      this.camera.position.z = 1;

      this.setupRenderer();
      const frag = await this.loadShaderWithFallback();
      this.setupMaterial(frag);

      const geometry = new THREE.PlaneGeometry(2, 2);
      this.quad = new THREE.Mesh(geometry, this.material);
      this.scene.add(this.quad);

      this.setupPostProcessing();
      this.onWindowResize(); // sync sizes and uniforms

      // warm GPU/state
      try { this.finalComposer.render(); } catch (e) { /* noop */ }

  window.addEventListener('mousemove', this.boundOnMouseMove, { passive: true });
  // Mouse click locks the position as well (desktop parity with tap)
  window.addEventListener('mousedown', this.boundOnMouseDown, { passive: true });
  // Touch support: react continuously while dragging a finger
  window.addEventListener('touchstart', this.boundOnTouchStart, { passive: true });
  window.addEventListener('touchmove', this.boundOnTouchMove, { passive: true });
  window.addEventListener('touchend', this.boundOnTouchEnd, { passive: true });
  window.addEventListener('touchcancel', this.boundOnTouchEnd, { passive: true });
      window.addEventListener('resize', this.boundOnResize);
    }

    // Load the optimized shader (legacy fallback removed).
    private async loadShaderWithFallback(): Promise<string> {
      const mod = await import('$lib/three/contactRaymarching_optimized.glsl?raw');
      return (mod && (mod.default ?? mod)) as string;
    }

    private setupRenderer(): void {
      this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      // compute capped size
      const cssW = this.container.clientWidth;
      const cssH = this.container.clientHeight;
      const scale = this.internalScale;
      const aspect = cssW / Math.max(1, cssH);
      let targetW = cssW;
      let targetH = cssH;
      // cap the larger dimension at MAX_INTERNAL_DIM while preserving aspect
      if (cssW >= cssH) {
        if (cssW > this.MAX_INTERNAL_DIM) {
          targetW = this.MAX_INTERNAL_DIM;
          targetH = Math.round(targetW / aspect);
        }
      } else {
        if (cssH > this.MAX_INTERNAL_DIM) {
          targetH = this.MAX_INTERNAL_DIM;
          targetW = Math.round(targetH * aspect);
        }
      }
      targetW = Math.max(1, Math.round(targetW * scale));
      targetH = Math.max(1, Math.round(targetH * scale));
      const effectivePixelRatio = Math.min(window.devicePixelRatio || 1, this.pixelRatioCap);
      this.renderer.setPixelRatio(1); // keep manual scaling control via target sizes
      this.renderer.setSize(targetW, targetH, false);
      this.renderer.setClearColor(0x000000, 0);
      try {
        // @ts-ignore
        this.renderer.outputColorSpace = (THREE as any).SRGBColorSpace ?? (THREE as any).sRGBEncoding;
      } catch (e) { /* ignore */ }
      this.container.appendChild(this.renderer.domElement);
      // ensure canvas stretches to container while content rendered at lower res
      const canvas = this.renderer.domElement;
      // Accessibility: canvas is decorative; hide from AT
      try {
        canvas.setAttribute('aria-hidden', 'true');
        canvas.setAttribute('role', 'presentation');
        canvas.setAttribute('tabindex', '-1');
      } catch {}
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.style.objectFit = 'contain';
      canvas.style.display = 'block';
      canvas.style.margin = '0 auto';
    }

    private setupMaterial(fragmentShaderCode: string): void {
      const initialSteps = this.computeAdaptiveMaxSteps(this.SPHERE_COUNT);
      const sphereUniformArray = this.sphereData;

      // Uniforms: keep names compatible with optimized shader.
      const uniforms: Record<string, any> = {
        uTime: { value: 0.0 },
        uResolution: { value: new THREE.Vector2(this.container.clientWidth, this.container.clientHeight) },
        uSphereCount: { value: this.SPHERE_COUNT },

        // Lighting / look
        uAmbientIntensity: { value: this.AMBIENT_INTENSITY },
        uDiffuseIntensity: { value: this.DIFFUSE_INTENSITY },
        uSpecularIntensity: { value: this.SPECULAR_INTENSITY },
        uSpecularPower: { value: this.SPECULAR_POWER },
        uFresnelPower: { value: this.FRESNEL_POWER },
        uContrast: { value: this.CONTRAST },

        // Colors & lights
        uBackgroundColor: { value: new THREE.Color(0x050505) },
        uSphereColor: { value: new THREE.Color(0x000000) }, // dark spheres by default
        uLightColor: { value: new THREE.Color(0xffffff) },
        uLightPosition: { value: new THREE.Vector3(1.0, 1.0, 1.0) },

        // Blend / smoothing
        uSmoothness: { value: this.BLEND_SMOOTHNESS },

        // Fog & camera
        uFogDensity: { value: this.FOG_DENSITY },
        uCameraDistance: { value: this.CAMERA_DISTANCE },

        // Movement & interaction (kept for CPU-driven motion)
        uAnimationSpeed: { value: this.ANIMATION_SPEED },
        uMovementPattern: { value: this.MOVEMENT_PATTERN },
        uMovementSpeed: { value: this.MOVEMENT_SPEED },
        uMovementScale: { value: this.MOVEMENT_SCALE },
        uIndividualRotation: { value: this.INDIVIDUAL_ROTATION },
        uMousePosition: { value: new THREE.Vector2(0.5, 0.5) },
        uMouseProximityEffect: { value: this.MOUSE_PROXIMITY_EFFECT },
        uMinMovementScale: { value: this.MIN_MOVEMENT_SCALE_ON_HOVER },
        uMaxMovementScale: { value: this.MAX_MOVEMENT_SCALE_ON_HOVER },

        // Packed sphere data (x, y, z, r)
        uSpheres: { value: sphereUniformArray },

        // runtime step control
        uMaxSteps: { value: initialSteps }
      };

      this.material = new THREE.ShaderMaterial({
        uniforms,
        vertexShader: `
          out vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: fragmentShaderCode,
        glslVersion: THREE.GLSL3,
        transparent: true
      }) as ShaderMaterial;

      // compile-time defines for shader array sizes & step bounds (keeps in sync with JS)
      this.material.defines = this.material.defines || {};
      this.material.defines.MAX_SPHERES = String(this.MAX_SPHERES);
      this.material.defines.MAX_STEPS = String(initialSteps);
      // tunable shadow steps (compile-time). If you change, shader recompile required.
      this.material.defines.SHADOW_STEPS = String(16);
      this.material.needsUpdate = true;

      // keep typed-array reference for uSpheres (no heavy allocation at runtime)
      this.material.uniforms.uSpheres.value = sphereUniformArray;
    }

    private setupPostProcessing(): void {
      const cssW = this.container.clientWidth;
      const cssH = this.container.clientHeight;
      const aspect = cssW / Math.max(1, cssH);
      // compute internal target size consistent with renderer (reuse resize logic subset)
      let baseW = cssW >= cssH ? Math.min(cssW, this.MAX_INTERNAL_DIM) : Math.round(Math.min(cssH, this.MAX_INTERNAL_DIM) * aspect);
      let baseH = cssW >= cssH ? Math.round(baseW / aspect) : Math.min(cssH, this.MAX_INTERNAL_DIM);
      baseW = Math.max(1, Math.round(baseW * this.internalScale));
      baseH = Math.max(1, Math.round(baseH * this.internalScale));

      const halfW = Math.max(1, Math.round(baseW * 0.5));
      const halfH = Math.max(1, Math.round(baseH * 0.5));

      const renderTarget = new THREE.WebGLRenderTarget(baseW, baseH, { format: THREE.RGBAFormat });
      const bloomRenderTarget = new THREE.WebGLRenderTarget(halfW, halfH, { format: THREE.RGBAFormat });

      const renderScene = new RenderPass(this.scene, this.camera);
      this.bloomPass = new UnrealBloomPass(new THREE.Vector2(halfW, halfH), 0.30, 0.5, 0.20);

      this.bloomComposer = new EffectComposer(this.renderer, bloomRenderTarget);
      this.bloomComposer.renderToScreen = false;
      this.bloomComposer.addPass(renderScene);
      this.bloomComposer.addPass(this.bloomPass);

      this.finalComposer = new EffectComposer(this.renderer, renderTarget);
      this.finalComposer.addPass(renderScene);

      // Compose bloom + base while preserving transparency (apply bloom only where base has alpha)
      const finalPass = new ShaderPass(
        new THREE.ShaderMaterial({
          uniforms: {
            baseTexture: { value: null },
            bloomTexture: { value: bloomRenderTarget.texture }
          },
          vertexShader: `varying vec2 vUv; void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
          fragmentShader: `
            uniform sampler2D baseTexture;
            uniform sampler2D bloomTexture;
            varying vec2 vUv;
            void main() {
              vec4 baseColor = texture2D(baseTexture, vUv);
              vec4 bloomColor = texture2D(bloomTexture, vUv);
              // preserve transparency: blend bloom only where base exists
              gl_FragColor = vec4(baseColor.rgb + bloomColor.rgb * baseColor.a, baseColor.a);
            }
          `,
          transparent: true,
          depthWrite: false
        }),
        "baseTexture"
      );

      const fxaaPass = new ShaderPass(FXAAShader);
      fxaaPass.material.uniforms['resolution'].value.set(1 / this.container.clientWidth, 1 / this.container.clientHeight);
      const gammaCorrectionPass = new ShaderPass(GammaCorrectionShader);

      this.finalComposer.addPass(finalPass);
      this.finalComposer.addPass(fxaaPass);
      this.finalComposer.addPass(gammaCorrectionPass);

      // hook up finalPass baseTexture to composer target (if available)
      finalPass.uniforms.baseTexture.value = this.finalComposer.renderTarget2?.texture ?? null;
    }

    // Public controls
    public startAnimationLoop(): void {
      if (this.isLooping) return;
      this.isLooping = true;
      this.clock.start();
      this.animate();
    }

    public stopAnimationLoop(): void {
      if (!this.isLooping) return;
      this.isLooping = false;
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      this.clock.stop();
    }

    // Smoothly reset interactive state (mouse) and clock
    public neutralizeState(duration = 0.6): void {
      gsap.killTweensOf(this.targetMouse);
      gsap.to(this.targetMouse, {
        x: 0.5,
        y: 0.5,
        duration,
        ease: 'power2.out'
      });
      // reset clock to avoid abrupt jumps in procedural movement
      this.clock = new THREE.Clock();
    }

    // core animate loop
    private animate(): void {
      if (!this.isLooping || this.isDisposed) return;
      this.animationFrameId = requestAnimationFrame(() => this.animate());
      this.render();
    }

    // primary render path: update CPU sphere buffer, uniforms, run composer
    private render(): void {
      // compute delta (frame-rate independent smoothing)
      const dt = Math.min(0.05, this.clock.getDelta()); // clamp dt to avoid spikes
      const frameMs = dt * 1000.0;
      // performance tracking (dynamic scaling)
      this.frameTimes.push(frameMs);
      if (this.frameTimes.length > this.FRAME_WINDOW) this.frameTimes.shift();
      if (this.scaleCooldown > 0) this.scaleCooldown--;
      if (this.frameTimes.length === this.FRAME_WINDOW && this.scaleCooldown === 0) {
        const avg = this.frameTimes.reduce((a,b)=>a+b,0) / this.frameTimes.length;
        let changed = false;
        if (avg > this.HIGH_THRESHOLD && this.internalScale > this.SCALE_FLOOR) {
          this.internalScale = Math.max(this.SCALE_FLOOR, +(this.internalScale - 0.1).toFixed(2));
          changed = true;
        } else if (avg < this.LOW_THRESHOLD && this.internalScale < this.SCALE_CEIL) {
          this.internalScale = Math.min(this.SCALE_CEIL, +(this.internalScale + 0.1).toFixed(2));
          changed = true;
        }
        if (changed) {
          this.scaleCooldown = this.SCALE_COOLDOWN_FRAMES;
          this.onWindowResize();
        }
        this.adjustSphereTier(avg); // <-- NEW TIERING LOGIC CALL
      }
      const elapsed = this.clock.getElapsedTime() * this.ANIMATION_SPEED;
      // Smooth mouse target -> smoothed mouse for shader
      this.mousePos.x += (this.targetMouse.x - this.mousePos.x) * (1.0 - Math.exp(-this.MOUSE_SMOOTHNESS * 60.0 * dt));
      this.mousePos.y += (this.targetMouse.y - this.mousePos.y) * (1.0 - Math.exp(-this.MOUSE_SMOOTHNESS * 60.0 * dt));

      if (this.material && this.material.uniforms) {
        this.material.uniforms.uTime.value = elapsed;
        const mp: THREE.Vector2 = this.material.uniforms.uMousePosition.value as THREE.Vector2;
        if (mp) { mp.x = this.mousePos.x; mp.y = this.mousePos.y; }

        this.material.uniforms.uSphereCount.value = Math.min(this.SPHERE_COUNT, this.MAX_SPHERES);
        this.material.uniforms.uResolution.value.set(this.container.clientWidth, this.container.clientHeight);
      }

      // update sphere positions (CPU) using smoothedScale and per-sphere lerp
      this.updateSphereData(elapsed, dt);

      // render (bloom composer + final composer pipeline)
      try {
        if (this.bloomComposer) this.bloomComposer.render();
        if (this.finalComposer) this.finalComposer.render();
        else this.renderer.render(this.scene, this.camera);
      } catch (e) {
        console.warn('ContactEffect: render exception', e);
      }
    }

    // CPU-side sphere motion (fast), writes into this.sphereData
    private updateSphereData(t: number, dt: number): void {
      // 1) compute immediate targetScale based on mouse distance from center
      let targetScale = this.MOVEMENT_SCALE;
      if (this.MOUSE_PROXIMITY_EFFECT) {
        const dx = this.targetMouse.x - 0.5;
        const dy = this.targetMouse.y - 0.5;
        let distToCenter = Math.hypot(dx, dy) * 2.0;
        distToCenter = Math.min(Math.max(distToCenter, 0.0), 1.0);
        // IMPORTANT: inverted mapping — farther pointer => LARGER orbit
        targetScale = this.MIN_MOVEMENT_SCALE_ON_HOVER + (this.MAX_MOVEMENT_SCALE_ON_HOVER - this.MIN_MOVEMENT_SCALE_ON_HOVER) * distToCenter;
      }

      // 2) smooth overall scale (frame-rate independent)
      const scaleAlpha = 1.0 - Math.exp(-this.SCALE_SMOOTHING_RATE * dt);
      this.smoothedScale += (targetScale - this.smoothedScale) * scaleAlpha;

      // 3) per-sphere compute instantaneous target position using smoothedScale,
      //    then smooth each sphere's position toward its target via lerp using POSITION_SMOOTHING_RATE
      const posAlpha = 1.0 - Math.exp(-this.POSITION_SMOOTHING_RATE * dt);
      const count = Math.min(this.SPHERE_COUNT, this.MAX_SPHERES);
      let idx = 0;

      for (let i = 0; i < this.MAX_SPHERES; i++) {
        if (i < count) {
          const sp = this.sphereParams[i];
          const speed = sp.speed;
          const radius = sp.radius;
          const orbit = sp.orbitBase * this.smoothedScale;
          const phase = sp.phase;

          // compute raw target (same movement patterns as before)
          let tx = 0, ty = 0, tz = 0;
          if (this.MOVEMENT_PATTERN === 0) {
            tx = Math.sin(t * speed + phase) * orbit;
            ty = Math.cos(t * (speed * 0.72) + phase * 1.2) * (orbit * 0.55);
            tz = Math.sin(t * (speed * 0.48) + phase * 0.9) * (orbit * 0.9);
          } else if (this.MOVEMENT_PATTERN === 1) {
            const wave = Math.sin(t * 0.5) * 0.5;
            tx = Math.sin(t * 0.2 + i * 0.5) * orbit;
            ty = Math.sin(t * 0.3 + i * 0.7 + wave) * orbit * 0.5;
            tz = Math.cos(t * 0.4 + i * 0.6) * orbit * 0.7;
          } else if (this.MOVEMENT_PATTERN === 2) {
            tx = Math.sin(t * speed * 1.1 + Math.sin(t * 0.4) * 2.0) * orbit;
            ty = Math.cos(t * speed * 0.9 + Math.sin(t * 0.5) * 1.5) * orbit * 0.8;
            tz = Math.sin(t * speed * 0.7 + Math.sin(t * 0.6) * 1.8) * orbit * 0.6;
          } else {
            const pulse = (Math.sin(t * 0.8) * 0.5 + 0.5) * 0.5 + 0.5;
            tx = Math.sin(t * speed + phase) * orbit * pulse;
            ty = Math.cos(t * (speed * 0.7) + phase * 1.3) * (orbit * 0.6) * pulse;
            tz = Math.sin(t * (speed * 0.5) + phase * 0.9) * (orbit * 0.8) * pulse;
          }

          // optional local rotation
          if (this.INDIVIDUAL_ROTATION) {
            const rs = t * (0.15 + i * 0.04) + sp.rotOffset;
            const c = Math.cos(rs);
            const s = Math.sin(rs);
            const rx = tx * c + tz * s;
            const rz = -tx * s + tz * c;
            tx = rx; tz = rz;
          }

          // set instantaneous target and lerp current pos toward it
          sp.targetPos.set(tx, ty, tz);
          sp.pos.lerp(sp.targetPos, posAlpha);

          // pack into sphereData typed array
          this.sphereData[idx++] = sp.pos.x;
          this.sphereData[idx++] = sp.pos.y;
          this.sphereData[idx++] = sp.pos.z;
          this.sphereData[idx++] = sp.radius;
        } else {
          // unused slot marker
          this.sphereData[idx++] = 0;
          this.sphereData[idx++] = 0;
          this.sphereData[idx++] = 0;
          this.sphereData[idx++] = -9999.0;
        }
      }

      // push to GPU uniform (no allocation)
      if (this.material?.uniforms?.uSpheres) {
        this.material.uniforms.uSpheres.value = this.sphereData;
      }

      // Update uMaxSteps adaptively if desired (optionally throttle recompile)
      const newSteps = this.computeAdaptiveMaxSteps(this.SPHERE_COUNT);
      if (this.material) {
        // runtime uniform (fast)
        if (this.material.uniforms.uMaxSteps) this.material.uniforms.uMaxSteps.value = newSteps;
        // update define (rare) if different
        if (String(this.material.defines?.MAX_STEPS) !== String(newSteps)) {
          this.material.defines = this.material.defines || {};
          this.material.defines.MAX_STEPS = String(newSteps);
          this.material.needsUpdate = true;
        }
      }
    }

    // compute adaptive max steps based on sphere count to reduce raymarch cost
    private computeAdaptiveMaxSteps(sphereCount: number): number {
      const clamp = (v: number, a: number, b: number) => Math.max(a, Math.min(b, v));
      const reduction = Math.floor((sphereCount / this.MAX_SPHERES) * (this.baseMaxSteps - this.minMaxSteps));
      let steps = this.baseMaxSteps - reduction;
      // additional scaling reduction when internalScale < 1
      if (this.internalScale < 0.95) {
        const scaleFactor = 0.5 + 0.5 * this.internalScale; // at 0.6 => 0.8, at 1.0 =>1.0
        steps = Math.round(steps * scaleFactor);
      }
      return clamp(steps, this.minMaxSteps, this.baseMaxSteps);
    }

    // Interaction
    private onMouseMove(e: MouseEvent) {
      const rect = this.container.getBoundingClientRect();
  const nx = Math.min(1, Math.max(0, (e.clientX - rect.left) / rect.width));
  const ny = 1.0 - Math.min(1, Math.max(0, (e.clientY - rect.top) / rect.height)); // match shader Y orientation
      this.targetMouse.x = nx;
      this.targetMouse.y = ny;

      // quick immediate update to uniform for snappy feel
      if (this.material && this.material.uniforms && this.material.uniforms.uMousePosition) {
        const mp: THREE.Vector2 = this.material.uniforms.uMousePosition.value as THREE.Vector2;
        if (mp) {
          mp.x = this.targetMouse.x;
          mp.y = this.targetMouse.y;
        }
      }
    }

    private onMouseDown(e: MouseEvent) {
      const rect = this.container.getBoundingClientRect();
      const nx = Math.min(1, Math.max(0, (e.clientX - rect.left) / rect.width));
      const ny = 1.0 - Math.min(1, Math.max(0, (e.clientY - rect.top) / rect.height));
      this.targetMouse.set(nx, ny);
      const mp: THREE.Vector2 | undefined = this.material?.uniforms?.uMousePosition?.value as THREE.Vector2 | undefined;
      if (mp) { mp.set(this.targetMouse.x, this.targetMouse.y); }
    }

    // Touch handlers to support dragging on mobile/tablet
    private onTouchStart(e: TouchEvent) {
      if (!e.touches || e.touches.length === 0) return;
      const t = e.touches[0];
      const rect = this.container.getBoundingClientRect();
  const nx = Math.min(1, Math.max(0, (t.clientX - rect.left) / rect.width));
  const ny = 1.0 - Math.min(1, Math.max(0, (t.clientY - rect.top) / rect.height));
      this.targetMouse.set(nx, ny);
      // immediate uniform push
      const mp: THREE.Vector2 | undefined = this.material?.uniforms?.uMousePosition?.value as THREE.Vector2 | undefined;
      if (mp) { mp.set(this.targetMouse.x, this.targetMouse.y); }
    }

    private onTouchMove(e: TouchEvent) {
      if (!e.touches || e.touches.length === 0) return;
      const t = e.touches[0];
      const rect = this.container.getBoundingClientRect();
  const nx = Math.min(1, Math.max(0, (t.clientX - rect.left) / rect.width));
  const ny = 1.0 - Math.min(1, Math.max(0, (t.clientY - rect.top) / rect.height));
      this.targetMouse.set(nx, ny);
      // immediate uniform push for responsiveness during drag
      const mp: THREE.Vector2 | undefined = this.material?.uniforms?.uMousePosition?.value as THREE.Vector2 | undefined;
      if (mp) { mp.set(this.targetMouse.x, this.targetMouse.y); }
    }

    private onTouchEnd(_e: TouchEvent) {
  // Hold last position on touch release (no automatic recenter)
  // A new tap/drag will move and re-lock the position.
    }

    // Resize handling and LOD adjustments
    private onWindowResize(): void {
      if (!this.renderer) return;
      const cssW = this.container.clientWidth;
      const cssH = this.container.clientHeight;
      const aspect = cssW / Math.max(1, cssH);
      let targetW = cssW;
      let targetH = cssH;
      if (cssW >= cssH) {
        if (cssW > this.MAX_INTERNAL_DIM) {
          targetW = this.MAX_INTERNAL_DIM;
          targetH = Math.round(targetW / aspect);
        }
      } else {
        if (cssH > this.MAX_INTERNAL_DIM) {
          targetH = this.MAX_INTERNAL_DIM;
          targetW = Math.round(targetH * aspect);
        }
      }
      targetW = Math.max(1, Math.round(targetW * this.internalScale));
      targetH = Math.max(1, Math.round(targetH * this.internalScale));
      this.renderer.setSize(targetW, targetH, false);
      const canvas = this.renderer.domElement;
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      // update composers if present
      if (this.bloomComposer) this.bloomComposer.setSize(targetW, targetH);
      if (this.finalComposer) this.finalComposer.setSize(targetW, targetH);
      const fxaaPass = (this.finalComposer?.passes || []).find((p: any) => p?.material?.uniforms?.resolution) as ShaderPass | undefined;
      if (fxaaPass) {
        fxaaPass.material.uniforms['resolution'].value.set(1 / targetW, 1 / targetH);
      }
      if (this.material?.uniforms?.uResolution) {
        (this.material.uniforms.uResolution.value as THREE.Vector2).set(targetW, targetH);
      }
      const newSteps = this.computeAdaptiveMaxSteps(this.SPHERE_COUNT);
      if (this.material) {
        if (this.material.uniforms.uMaxSteps) this.material.uniforms.uMaxSteps.value = newSteps;
        if (String(this.material.defines?.MAX_STEPS) !== String(newSteps)) {
          this.material.defines = this.material.defines || {};
          this.material.defines.MAX_STEPS = String(newSteps);
          this.material.needsUpdate = true;
        }
      }
    }

    public setSphereCount(count: number): void {
      this.SPHERE_COUNT = Math.max(0, Math.min(count, this.MAX_SPHERES));
      if (this.material?.uniforms?.uSphereCount) this.material.uniforms.uSphereCount.value = this.SPHERE_COUNT;
      this.onWindowResize();
    }

    private adjustSphereTier(avgFrameMs: number) {
      if (this.sphereTierCooldown > 0) { this.sphereTierCooldown--; return; }
      if (this.internalScale > this.SCALE_FLOOR + 0.001) return; // only when already at scale floor
      if (avgFrameMs > this.HIGH_THRESHOLD + 1.5) {
        // reduce complexity
        for (let i = 0; i < this.SPHERE_TIERS.length; i++) {
          if (this.SPHERE_COUNT > this.SPHERE_TIERS[i]) {
            this.setSphereCount(this.SPHERE_TIERS[i]);
            this.sphereTierCooldown = this.SPHERE_TIER_COOLDOWN_FRAMES;
            break;
          }
        }
      } else if (avgFrameMs < this.LOW_THRESHOLD - 1.0) {
        // restore complexity upward
        for (let i = this.SPHERE_TIERS.length - 1; i >= 0; i--) {
          if (this.SPHERE_COUNT < this.SPHERE_TIERS[i]) {
            this.setSphereCount(this.SPHERE_TIERS[i]);
            this.sphereTierCooldown = this.SPHERE_TIER_COOLDOWN_FRAMES;
            break;
          }
        }
      }
    }

    // Dispose and clean everything
    public dispose(): void {
      this.isDisposed = true;
      this.stopAnimationLoop();
      window.removeEventListener('mousemove', this.boundOnMouseMove);
  window.removeEventListener('mousedown', this.boundOnMouseDown as any);
  window.removeEventListener('touchstart', this.boundOnTouchStart as any);
  window.removeEventListener('touchmove', this.boundOnTouchMove as any);
  window.removeEventListener('touchend', this.boundOnTouchEnd as any);
  window.removeEventListener('touchcancel', this.boundOnTouchEnd as any);
      window.removeEventListener('resize', this.boundOnResize);

      try {
        if (this.quad) {
          this.quad.geometry?.dispose();
          (this.quad.material as THREE.Material)?.dispose();
          this.scene.remove(this.quad);
        }
      } catch (e) { /* ignore */ }

      try {
        (this.bloomComposer as any)?.dispose?.();
        (this.finalComposer as any)?.dispose?.();
      } catch (e) { /* ignore */ }

      try {
        if (this.renderer) {
          this.renderer.forceContextLoss();
          const canvas = this.renderer.domElement;
          if (canvas && canvas.parentNode) canvas.parentNode.removeChild(canvas);
          // @ts-ignore
          this.renderer.domElement = null;
          // @ts-ignore
          this.renderer.context = null;
          // @ts-ignore
          this.renderer = null;
        }
      } catch (e) { /* ignore */ }
    }
  }
</script>

<!-- container for the canvas. The effect creates and appends the canvas internally -->
<div class="contact-effect-container" bind:this={container} aria-hidden="true" role="presentation"></div>

<style>
  .contact-effect-container {
    position: absolute;
    inset: 0;
    z-index: 0;
    visibility: hidden; /* orchestrator toggles via gsap autoAlpha */
    opacity: 0;
    pointer-events: none;
  }
  /* ensure canvas fills parent */
  /* Use :global(canvas) because the canvas element is created dynamically in JS and doesn't get the Svelte scoping attribute. */
  .contact-effect-container :global(canvas) {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>

--- END OF FILE src\lib\components\sections\ContactEffect.svelte ---

--- START OF FILE src\lib\components\sections\ContactSection.svelte ---
<!-- src/lib/components/sections/ContactSection.svelte -->
<script context="module" lang="ts">
  // The public API now includes all optional methods to support the full lifecycle.
  export type ContactSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    initializeEffect?: () => Promise<void>;
    onTransitionComplete?: () => void;
    onUnload?: () => void;
  };
</script>

<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import { gsap } from 'gsap';
  import { siteConfig } from '$lib/data/siteConfig';
  
  // 1. Import the new effect component and its instance type.
  import ContactEffect from './ContactEffect.svelte';
  import type { ContactEffectInstance } from './ContactEffect.svelte';

  const dispatch = createEventDispatcher();

  type ContactSectionData = typeof siteConfig.contactSection;
  export let data: ContactSectionData;
  export let emailLabel: string | undefined;

  // 2. Create a binding for the child component instance.
  let contactEffectInstance: ContactEffectInstance | null = null;
  
  let sectionWrapper: HTMLElement;
  let animatableUiElements: Element[] = [];

  onMount(() => {
    if (sectionWrapper) {
      // Select only the UI elements for the GSAP animation.
      animatableUiElements = gsap.utils.toArray(sectionWrapper.querySelectorAll('.anim-ui-element'));
    }
  });

  // --- Animation Lifecycle API Implementation (with Proxying) ---

  export async function initializeEffect() {
    // Proxy the call to the child effect component.
    if (contactEffectInstance?.initializeEffect) {
      await contactEffectInstance.initializeEffect();
    }
  }

  export function onEnterSection(): void {
    // A. Trigger the fade-in of the background effect.
    contactEffectInstance?.onEnterSection();

    // B. Animate the surrounding UI elements in parallel.
    if (animatableUiElements.length === 0) return;
    gsap.set(animatableUiElements, { autoAlpha: 0, y: 30 });

    gsap.to(animatableUiElements, {
      autoAlpha: 1,
      y: 0,
      duration: 1.2,
      stagger: 0.2,
      delay: 0.5, // Start UI animation slightly after the section starts transitioning in.
      ease: 'power3.out',
      onComplete: () => {
        dispatch('animationComplete');
      }
    });
  }

  export function onTransitionComplete() {
    // Proxy the call to start the heavy rendering loop.
    contactEffectInstance?.onTransitionComplete();
  }

  export function onLeaveSection(): void {
    // A. Trigger the fade-out of the background effect.
    contactEffectInstance?.onLeaveSection();

    // B. Immediately reset the surrounding UI elements.
    if (animatableUiElements.length === 0) return;
    gsap.killTweensOf(animatableUiElements);
    gsap.set(animatableUiElements, { autoAlpha: 0 });
  }
  
  export function onUnload() {
    // Proxy the call to dispose of the effect's GPU resources.
    contactEffectInstance?.onUnload();
  }
</script>

<div class="contact-section-wrapper" bind:this={sectionWrapper}>
  <!-- 
    The ContactEffect component is placed here. It will create its own
    absolutely positioned canvas that sits behind the content-overlay.
  -->
  <ContactEffect bind:this={contactEffectInstance} />

  <!-- 
    This overlay holds all the UI content and arranges it around the effect.
  -->
  <div class="content-overlay">
    <div class="text-column anim-ui-element">
      <h2>{data.title}</h2>
      <p>{data.outroMessage}</p>
    </div>

    <div class="links-column">
      <a href="mailto:{data.email}" class="contact-link anim-ui-element">
        <span>{emailLabel ?? 'Email Me'}</span>
        <svg width="13px" height="10px" viewBox="0 0 13 10">
          <path d="M1,5 L11,5"></path>
          <polyline points="8 1 12 5 8 9"></polyline>
        </svg>
      </a>
      {#if data.additionalLinks}
        {#each data.additionalLinks as link}
          <a href={link.url} target="_blank" rel="noopener noreferrer" class="contact-link anim-ui-element">
            <span>{link.name}</span>
            <svg width="13px" height="10px" viewBox="0 0 13 10">
              <path d="M1,5 L11,5"></path>
              <polyline points="8 1 12 5 8 9"></polyline>
            </svg>
          </a>
        {/each}
      {/if}
    </div>
  </div>
</div>

<style>
  .contact-section-wrapper {
    width: 100%;
    height: 100%;
    position: relative;
    overflow: hidden;
    background-color: transparent; /* The effect provides the background */
  }

  .content-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* Sits on top of the effect's canvas */
    
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 3rem max(calc(env(safe-area-inset-left, 0px) + 8vw), 3rem);
    box-sizing: border-box;
    pointer-events: none; /* Allows mouse interaction with the background effect */
  }

  /* Columns for the layout */
  .text-column, .links-column {
    pointer-events: auto; /* Re-enable pointer events for the content itself */
    opacity: 0; /* Start hidden for GSAP */
    visibility: hidden;
  }

  .text-column {
    text-align: left;
    max-width: 450px;
  }
  
  .links-column {
    text-align: right;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 1.5rem;
  }

  h2 {
    font-size: clamp(2.5rem, 5vw, 3.5rem);
    margin-bottom: 1.5rem;
    font-weight: 300;
    letter-spacing: -0.02em;
    color: rgb(245 245 247);
  }

  p {
    font-size: clamp(1rem, 2.2vw, 1.15rem);
    line-height: 1.8;
    color: rgb(212 212 216);
  }
  
  /* Styling for the new contact buttons */
  .contact-link {
    font-family: 'Source Code Pro', monospace;
    font-size: 1.1rem;
    font-weight: 300;
    color: #c7c7c7;
    text-decoration: none;
    position: relative;
    display: inline-flex;
    align-items: center;
    transition: color 0.3s ease;
  }
  
  .contact-link:hover {
    color: #ffffff;
  }

  .contact-link span {
    display: block;
    transition: transform 0.3s ease;
  }

  .contact-link:hover span {
    transform: translateX(-8px);
  }

  .contact-link svg {
    margin-left: 10px;
    stroke: #ffffff;
    stroke-width: 2;
    fill: none;
    stroke-dasharray: 18;
    stroke-dashoffset: 18;
    transition: stroke-dashoffset 0.4s ease, transform 0.3s ease;
  }

  .contact-link:hover svg {
    stroke-dashoffset: 0;
  }

  /* Responsive adjustments for smaller screens */
  @media (max-width: 768px) {
    .content-overlay {
      flex-direction: column;
      justify-content: center;
      text-align: center;
      gap: 3rem;
    }
    .text-column, .links-column {
      text-align: center;
      align-items: center;
      max-width: 90%;
    }
  }
</style>
--- END OF FILE src\lib\components\sections\ContactSection.svelte ---

--- START OF FILE src\lib\components\sections\HeroSection.svelte ---
<!-- src/lib/components/sections/HeroSection.svelte -->
<script context="module" lang="ts">
  import type { SvelteComponent } from 'svelte';

  // The instance type must now be a superset, including our standard API
  // and the specific Hero API for the orchestrator to use.
  export interface HeroSectionInstance {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    // We still expose the underlying component's methods for fine-grained control
    // during the initial site reveal sequence in +page.svelte.
    onTransitionToHeroStart: () => Promise<void>;
    onTransitionToHeroComplete: () => void;
    onTransitionFromHeroStart: () => void;
  }

  // A more specific type for the internal HeroParticleEffect component instance.
  interface HeroParticleEffectComponent extends SvelteComponent {
    onTransitionToHeroStart: () => Promise<void>;
    onTransitionToHeroComplete: () => void;
    onTransitionFromHeroStart: () => void;
  }
</script>

<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import HeroParticleEffect from '$lib/components/HeroParticleEffect.svelte';

  const dispatch = createEventDispatcher();

  // Props that will be passed down from the orchestrator (+page.svelte)
  export let activeSectionIndex: number;
  export let isTransitioning: boolean;
  export let transitionDuration: number;
  export let isInitialLoad: boolean;

  // Binding for the child particle effect component
  let heroParticleEffectInstance: HeroParticleEffectComponent | null = null;
  
  // --- Standard Animation API Implementation ---

  /**
   * This is the "enter" function for standard section-to-section navigation.
   * It proxies the generic call to the specific method on the particle effect component.
   */
  export function onEnterSection(): void {
    heroParticleEffectInstance?.onTransitionToHeroStart();
  }

  /**
   * This is the "leave" function for standard section-to-section navigation.
   * It proxies the generic call to the specific method on the particle effect component.
   */
  export function onLeaveSection(): void {
    heroParticleEffectInstance?.onTransitionFromHeroStart();
  }


  // --- Exposing the underlying API for fine-grained control ---
  // These are needed for the initial site load/reveal sequence in +page.svelte,
  // which has slightly different logic than a standard section transition.

  export function onTransitionToHeroStart(): Promise<void> {
    return heroParticleEffectInstance?.onTransitionToHeroStart() ?? Promise.resolve();
  }

  export function onTransitionToHeroComplete(): void {
    heroParticleEffectInstance?.onTransitionToHeroComplete();
  }

  export function onTransitionFromHeroStart(): void {
    heroParticleEffectInstance?.onTransitionFromHeroStart();
  }

</script>

<!-- 
  This wrapper contains the HeroParticleEffect. It ensures the effect is
  always present in the DOM, ready to be animated. The `div` itself
  doesn't need styling as the particle effect creates its own full-screen canvas.
-->
<div class="hero-section-wrapper">
  <HeroParticleEffect
    bind:this={heroParticleEffectInstance}
    {activeSectionIndex}
    {isTransitioning}
    {transitionDuration}
    {isInitialLoad}
    on:ready={() => dispatch('ready')}
  />
</div>

<style>
  .hero-section-wrapper {
    /* 
      This wrapper needs to occupy the full space of its parent <section>
      to ensure the particle effect's container (which is appended inside it)
      can correctly calculate its dimensions.
    */
    width: 100%;
    height: 100%;
    position: relative;
  }
</style>
--- END OF FILE src\lib\components\sections\HeroSection.svelte ---

--- START OF FILE src\lib\components\sections\ProjectSection.svelte ---
<!-- src/lib/components/sections/ProjectSection.svelte -->
<script context="module" lang="ts">
  export type ProjectSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
  };
</script>

<script lang="ts">
  import { createEventDispatcher, onDestroy } from 'svelte';
  import { gsap } from 'gsap';
  import type { Project } from '$lib/data/projectsData';

  const dispatch = createEventDispatcher();

  export let project: Project;

  let sectionWrapperEl: HTMLElement;
  let bgLayerA: HTMLDivElement;
  let bgLayerB: HTMLDivElement;

  // --- State for Image Cycling ---
  let currentImageIndex = 0;
  let activeLayer: 'A' | 'B' = 'A';
  let cycleTimer: number | undefined;
  let isCycling = false;

  function preloadNextImage() {
    if (project.backgrounds.length < 2) return;
    const nextIndex = (currentImageIndex + 1) % project.backgrounds.length;
    const nextImageSrc = project.backgrounds[nextIndex].value;
    const img = new Image();
    img.src = nextImageSrc;
  }

  /**
   * REWRITTEN & CORRECTED: Handles the core cross-fade and continuous zoom logic.
   * This version ensures the outgoing layer continues its zoom during the fade.
   */
  function transitionToNextImage() {
    if (project.backgrounds.length < 2 || !isCycling) return;

    // 1. Identify layers and get the next image in the sequence.
    const layers = { A: bgLayerA, B: bgLayerB };
    const visibleLayer = layers[activeLayer];
    const hiddenLayer = activeLayer === 'A' ? layers.B : layers.A;
    
    currentImageIndex = (currentImageIndex + 1) % project.backgrounds.length;
    const nextImageSrc = project.backgrounds[currentImageIndex].value;
    
    // --- PRELOADING FIX ---
    // Start preloading the *next* image immediately, so it's ready for the subsequent transition.
    // This prevents a loading-induced stutter on the next cycle.
    preloadNextImage();

    // 2. Get animation timing parameters from CSS.
    const totalLifetime = parseFloat(getComputedStyle(sectionWrapperEl).getPropertyValue('--image-total-lifetime'));
    const crossfadeDuration = parseFloat(getComputedStyle(sectionWrapperEl).getPropertyValue('--image-crossfade-duration'));
    
    // 3. The zoom must last for the image's entire visible lifetime PLUS its fade-out duration.
    const totalZoomDuration = totalLifetime + crossfadeDuration;
    
    // 4. Calculate the delay until the *next* transition is triggered.
    const nextTransitionDelay = (totalLifetime - crossfadeDuration) * 1000;

    // 5. Set up the INCOMING (hidden) layer.
    gsap.set(hiddenLayer, { 
      backgroundImage: `url(${nextImageSrc})`, 
      scale: 1, 
      opacity: 0 
    });

    // 6. Animate the INCOMING layer.
    gsap.to(hiddenLayer, {
      scale: 'var(--image-zoom-amount)',
      ease: 'none',
      duration: totalZoomDuration
    });
    gsap.to(hiddenLayer, {
      opacity: 1,
      ease: 'power2.inOut',
      duration: crossfadeDuration
    });

    // 7. Animate the OUTGOING layer.
    gsap.to(visibleLayer, {
      opacity: 0,
      ease: 'power2.inOut',
      duration: crossfadeDuration,
      onComplete: () => {
        gsap.killTweensOf(visibleLayer);
        gsap.set(visibleLayer, { opacity: 0 });
        activeLayer = activeLayer === 'A' ? 'B' : 'A';
        cycleTimer = window.setTimeout(transitionToNextImage, nextTransitionDelay);
      }
    });
  }

  export function onEnterSection() {
    const initialImageSrc = project.backgrounds[currentImageIndex].value;
    const layers = { A: bgLayerA, B: bgLayerB };
    const visibleLayer = layers[activeLayer];
    const hiddenLayer = activeLayer === 'A' ? layers.B : layers.A;
    gsap.set(visibleLayer, { backgroundImage: `url(${initialImageSrc})`, opacity: 1, scale: 1 });
    gsap.set(hiddenLayer, { opacity: 0 });

    if (project.backgrounds.length > 1 && !isCycling) {
      isCycling = true;
      preloadNextImage();
      
      const entryZoomDuration = parseFloat(getComputedStyle(sectionWrapperEl).getPropertyValue('--entry-zoom-duration'));
      cycleTimer = window.setTimeout(transitionToNextImage, entryZoomDuration * 1000);
    }
    
    const headline = sectionWrapperEl.querySelector('.anim-headline');
    const summary = sectionWrapperEl.querySelector('.anim-summary');
    const cards = gsap.utils.toArray(sectionWrapperEl.querySelectorAll('.anim-card'));
    const button = sectionWrapperEl.querySelector('.anim-button');
    
    if (headline) gsap.set(headline, { autoAlpha: 0, y: 50 });
    if (summary) gsap.set(summary, { autoAlpha: 0, y: 40 });
    if (cards.length > 0) gsap.set(cards, { autoAlpha: 0, scale: 0.95, y: 20 });
    if (button) gsap.set(button, { autoAlpha: 0, y: 10, scale: 0.95 });
    
    const tl = gsap.timeline({
      delay: 0.2,
      onComplete: () => { dispatch('animationComplete'); }
    });

    if (headline) tl.to(headline, { autoAlpha: 1, y: 0, duration: 0.9, ease: 'power3.out' }, 'start');
    if (summary) tl.to(summary, { autoAlpha: 1, y: 0, duration: 0.8, ease: 'power3.out' }, 'start+=0.15');
    if (cards.length > 0) tl.to(cards, { autoAlpha: 1, scale: 1, y: 0, duration: 1.2, stagger: 0.1, ease: 'expo.out' }, 'start+=0.25');
    if (button) tl.to(button, { autoAlpha: 1, y: 0, scale: 1, duration: 1.2, ease: 'expo.out' }, 'start+=0.4');
  }

  export function onLeaveSection() {
    isCycling = false;
    clearTimeout(cycleTimer);
    
    gsap.killTweensOf([bgLayerA, bgLayerB]);

    const animatableElements = gsap.utils.toArray(sectionWrapperEl.querySelectorAll('.anim-headline, .anim-summary, .anim-card, .anim-button'));
    if (animatableElements.length > 0) {
      gsap.killTweensOf(animatableElements);
      gsap.set(animatableElements, { autoAlpha: 0 });
    }
  }
  
  onDestroy(() => {
    clearTimeout(cycleTimer);
    gsap.killTweensOf([bgLayerA, bgLayerB]);
  });
</script>

<div class="project-section-wrapper" bind:this={sectionWrapperEl}>
  <div class="background-zoom-target">
    <div class="bg-layer bg-layer-a" bind:this={bgLayerA}></div>
    <div class="bg-layer bg-layer-b" bind:this={bgLayerB}></div>
  </div>

  <div class="content-host">
    <slot></slot>
  </div>
</div>

<style>
  :root {
    /* The duration of the dramatic zoom when the section first scrolls into view */
    --entry-zoom-duration: 5s;
    
    /* The total time an image is on screen (visible time + fade time) */
    --image-total-lifetime: 8s;
    
    /* How long the cross-fade between images takes */
    --image-crossfade-duration: 2.5s;
    
    /* How much each image zooms in during its continuous linear cycle */
    --image-zoom-amount: 1.15;
  }

  .project-section-wrapper {
    width: 100%;
    height: 100%;
    color: rgb(245 245 247);
    z-index: 2;
    background-color: transparent;
    position: relative;
    overflow: hidden;
  }

  .background-zoom-target {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    transform: scale(1); /* Target for the orchestrator's initial dramatic zoom */
  }

  .bg-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    transform: scale(1); /* Target for the component's internal linear zoom */
  }

  .background-zoom-target::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(to top, rgba(9, 9, 11, 0.6), rgba(9, 9, 11, 0.2) 60%, transparent 100%);
    z-index: 1;
  }
  
  .content-host {
    position: relative;
    z-index: 2;
    width: 100%;
    height: 100%;
  }
</style>
--- END OF FILE src\lib\components\sections\ProjectSection.svelte ---

--- START OF FILE src\lib\data\projectsData.ts ---
// src/lib/data/projectsData.ts

// --- MODIFICATION START: The ProjectCard no longer holds the sub-section's background. ---
// It is now only responsible for its own appearance and linking.
export interface ProjectCard {
  id: string; // Unique ID for this card, e.g., 'p1_capability'
  title: string;
  cardImage?: string; // Path to the small, optimized image for the main page card
  description?: string; // Short description for the card
  aspectLink?: string; // Anchor link for the subpage section, e.g., '#capability'
}
// --- MODIFICATION END ---

// This interface is the definitive source for a sub-section's content and background.
export interface ProjectSubPageSection {
    id: string; // Corresponds to aspectLink from a card, used for scrolling
    title: string;
    content: string; // Can be HTML or Markdown, we'll decide how to render it
    background: {
      type: 'image' | 'video' | 'color';
      value: string; // The URL for this specific section's background
    };
}

// This is the main project interface, which holds all data for a project.
export interface Project {
  id: string;
  slug: string;
  headline: string;
  headlineAnimation?: {
    type?: string;
    duration?: number;
    delay?: number;
    stagger?: number;
    ease?: string;
  };
  summary: string;
  backgrounds: { // The list of images to cycle through on the main page
    type: 'image';
    value: string;
  }[];
  tags?: string[];
  cards: ProjectCard[];
  subPageSections: ProjectSubPageSection[];
  readMoreLinkText?: string;
}

export type Locale = 'en' | 'de';

export function getProjects(locale: Locale): Project[] {
  const isDE = locale === 'de';

  const projectOne: Project = {
    id: 'project-one',
    slug: 'BURA',
    headline: isDE ? 'BURA \n Langstrecken-Aufklärungs-UAV' : 'BURA \n Long Range Recon UAV',
    summary: isDE
      ? 'Ein vollständig 3D-gedrucktes UAV für Langstrecken- und mehrstündige Aufklärungsmissionen.'
      : 'A fully 3D-Printed UAV designed for long-range, multi-hour reconnaissance missions.',
    backgrounds: [
      { type: 'image', value: '/images/projects/project-one/Drone_Sunset.webp' },
      { type: 'image', value: '/images/projects/project-one/clouds.webp' },
      { type: 'image', value: '/images/projects/project-one/Me_and_Drone.webp' },
      { type: 'image', value: '/images/projects/project-one/Drone_close_clouds.webp' }
    ],
    tags: isDE
      ? ['3D‑Druck', 'UAV‑Design', 'Luft- und Raumfahrttechnik', 'Elektronik']
      : ['3D Printing', 'UAV Design', 'Aerospace Engineering', 'Electronics'],
    cards: [
      {
        id: 'p1_capability',
        title: isDE ? 'Fähigkeiten' : 'Capability',
        cardImage: '/images/projects/project-one/card1_cropped.webp',
        description: isDE
          ? 'Ausgefeilte Sensorik für fortgeschrittene autonome Funktionen'
          : 'Elaborate Sensor Array for advanced autonomous capabilities',
        aspectLink: '#capability'
      },
      {
        id: 'p1_3d_printing',
        title: isDE ? '3D‑Druck' : '3D-Printing',
        cardImage: '/images/projects/project-one/card2_cropped.webp',
        description: isDE
          ? 'Vollständig 3D‑gedruckt mit LW‑PLA und ASA'
          : 'Fully 3D-printed Airframe with LW-PLA and ASA',
        aspectLink: '#3d-printing'
      },
      {
        id: 'p1_testing',
        title: isDE ? 'Tests' : 'Testing',
        cardImage: '/images/projects/project-one/card3_cropped.webp',
        description: isDE
          ? 'Analyse der Leistungsdaten und Flugeigenschaften'
          : 'Analyzing model performance and flight characteristics',
        aspectLink: '#testing'
      }
    ],
    subPageSections: [
      {
        id: 'capability',
        title: isDE ? 'Autonome Fähigkeiten' : 'Advanced Autonomous Capabilities',
        content: isDE
          ? 'Detaillierte Vorstellung der Sensorsuite mit hochauflösender Kamera, GPS und Echtzeit-Datenlinks – Grundlage für anspruchsvolle autonome Flüge und Datenerfassung. (Coming soon)'
          : 'Detailed walkthrough of the sensor suite, including a high-resolution camera, GPS and real-time data links, enabling sophisticated autonomous flight and data collection. (Coming soon)',
        background: { type: 'image', value: '/images/projects/project-one/sub_bg_1.webp' }
      },
      {
        id: '3d-printing',
        title: isDE ? 'Fertigung' : 'Manufacturing',
        content: isDE
          ? 'Erläuterung des Designs mit Lightweight PLA (LW‑PLA) für Strukturbauteile und ASA für robuste, strukturelle Teile optimiert für Langlebigkeit und optimale Flugzeit. (Coming soon)'
          : 'Explanation of the design process using lightweight PLA (LW-PLA) for structural components and ASA for durable structural surfaces, optimizing for both strength and flight time. (Coming soon)',
        background: { type: 'image', value: '/images/projects/project-one/sub_bg_2.webp' }
      },
      {
        id: 'testing',
        title: isDE ? 'Feldtests & Validierung' : 'Field Testing & Validation',
        content: isDE
          ? 'Präsentation der Flugtestergebnisse, darunter Ausdauer, Reichweite und Nutzlast (Coming Soon). Das UAV demonstrierte über 2 Stunden Flugzeit und eine Reichweite von über 20 km.'
          : 'Presentation of flight test data, including endurance, range, and payload capacity metrics (Coming Soon). The UAV successfully demonstrated over 2 hours of flight time and a range of more than 20 km.',
        background: { type: 'image', value: '/images/projects/project-one/sub_bg_3.webp' }
      }
    ],
    readMoreLinkText: isDE ? 'Mehr erfahren' : 'Explore More'
  };

  const projectTwo: Project = {
    id: 'project-two',
    slug: 'Project2',
    headline: isDE ? 'Projekt 2' : 'Project 2',
    summary: isDE ? 'Platzhaltertext für ein zweites Projekt (kommt bald)' : 'Placeholder text for a second project (coming soon)',
    backgrounds: [
      { type: 'image', value: '/images/projects/project-two/background.jpg' },
      { type: 'image', value: '/images/projects/project-two/background2.jpg' }
    ],
    tags: isDE ? ['Platzhalter', 'Konzept', 'Demo'] : ['Placeholder', 'Concept', 'Demo'],
    cards: [
      { id: 'p2_section_a', title: isDE ? 'Abschnitt A' : 'Section A', cardImage: '/images/projects/project-two/card-data-small.webp', description: isDE ? 'Platzhalter' : 'Placeholder', aspectLink: '#section-a' },
      { id: 'p2_section_b', title: isDE ? 'Abschnitt B' : 'Section B', cardImage: '/images/projects/project-two/card-design-small.webp', description: isDE ? 'Platzhalter' : 'Placeholder', aspectLink: '#section-b' },
      { id: 'p2_section_c', title: isDE ? 'Abschnitt C' : 'Section C', cardImage: '/images/projects/project-two/card-insights-small.webp', description: isDE ? 'Platzhalter' : 'Placeholder', aspectLink: '#section-c' }
    ],
    subPageSections: [
      { id: 'section-a', title: isDE ? 'Abschnitt A' : 'Section A', content: isDE ? 'Platzhalterinhalt A. Lorem ipsum dolor sit amet.' : 'Placeholder content A. Lorem ipsum dolor sit amet.', background: { type: 'image', value: '/images/projects/project-two/card-data.jpg' } },
      { id: 'section-b', title: isDE ? 'Abschnitt B' : 'Section B', content: isDE ? 'Platzhalterinhalt B. Consectetur adipiscing elit.' : 'Placeholder content B. Consectetur adipiscing elit.', background: { type: 'image', value: '/images/projects/project-two/card-design.jpg' } },
      { id: 'section-c', title: isDE ? 'Abschnitt C' : 'Section C', content: isDE ? 'Platzhalterinhalt C. Sed do eiusmod tempor.' : 'Placeholder content C. Sed do eiusmod tempor.', background: { type: 'image', value: '/images/projects/project-two/card-insights.jpg' } }
    ],
    readMoreLinkText: isDE ? 'Mehr erfahren' : 'Explore More'
  };

  return [projectOne, projectTwo];
}

// Backward-compatible default export (English)
export const projects: Project[] = getProjects('en');
--- END OF FILE src\lib\data\projectsData.ts ---

--- START OF FILE src\lib\data\siteConfig.ts ---
// src/lib/data/siteConfig.ts

export interface ParticleEffectConfig {
  type: string; // e.g., 'default', 'starryNight', etc.
  //options?: any; // This will hold the actual tsParticles JSON config
}

export interface SocialLink {
  name: string; // e.g., 'LinkedIn', 'GitHub', 'Email'
  url: string;
  icon?: string; // Optional: path to an icon or an icon library class name
}

export interface LegalLink {
  name: string; // e.g., 'Impressum', 'Datenschutz', 'Barrierefreiheit'
  url: string;  // e.g., '/impressum'
}

export const siteConfig = {
  title: "Your Name - Data Scientist Portfolio",
  author: "Your Name",
  description: "A portfolio showcasing data science projects and expertise.",

  heroSection: {
    greeting: "Hello, I'm",
    name: "Miká Müller", // Or however you want to display it
    particleEffect: {
      type: 'defaultGreetingParticles', // We'll define this later
    } as ParticleEffectConfig,
  },

  aboutSection: {
    title: "About Me", // MODIFIED
    introduction: "I am a data scientist specializing in building end-to-end systems that derive actionable intelligence from real-world sensor data. The projects below demonstrate my capability in integrating custom hardware, robust software, and advanced perception models to solve complex operational challenges.",
    imageUrl: "/images/profile.webp", // MODIFIED - ensure this image exists in static/images
    imageParticleEffect: {
      type: 'imageAuraParticles', // We'll define this later
    } as ParticleEffectConfig,
    socialLinks: [ // Existing links, will be used by KeyboardButtons
      { name: "GitHub", url: "https://github.com/coming_soon" }, // Replace with your actual URL
      { name: "LinkedIn", url: "https://www.linkedin.com/in/coming_soon/" }, // Replace with your actual URL
      { name: "Email", url: "mailto:mika38159@gmail.com" }, // Replace with your actual email
    ] as SocialLink[],
  },

  contactSection: {
    title: "Get in Touch",
    outroMessage: "I'm always excited to discuss new projects, collaborations, or opportunities. Feel free to reach out!",
    email: "youremail@example.com", // Replace with your actual email
    additionalLinks: [
        { name: "View My Resume", url: "/resume.pdf" } // Place resume in `static` folder
    ]
  },

  // Centralized legal links for global footer
  legalLinks: [
    { name: 'Impressum', url: '/impressum' },
    { name: 'Datenschutz', url: '/datenschutz' },
    { name: 'Barrierefreiheit', url: '/barrierefreiheit' },
  ] as LegalLink[],

  defaultHeadlineAnimation: {
    type: 'fadeInUp',
    duration: 0.8,
    delay: 0.2,
    stagger: 0.1,
  },
};
--- END OF FILE src\lib\data\siteConfig.ts ---

--- START OF FILE src\lib\debug\DebugManager.ts ---

--- END OF FILE src\lib\debug\DebugManager.ts ---

--- START OF FILE src\lib\debug\README.md ---

--- END OF FILE src\lib\debug\README.md ---

--- START OF FILE src\lib\effects\effectConfig.ts ---

--- END OF FILE src\lib\effects\effectConfig.ts ---

--- START OF FILE src\lib\i18n\namespaces.ts ---
// src/lib/i18n/namespaces.ts
// Namespace list and helpers for loading message files

export type Namespace =
  | 'common'
  | 'layout'
  | 'hero'
  | 'about'
  | 'contact'
  | 'projects'
  | 'project-bura'
  | 'legal';

export const CORE_NAMESPACES: Namespace[] = ['common', 'layout'];

export function nsPath(locale: string, ns: Namespace) {
  return `/src/lib/i18n/locales/${locale}/${ns}.json`;
}

--- END OF FILE src\lib\i18n\namespaces.ts ---

--- START OF FILE src\lib\i18n\README.md ---
# i18n structure

This folder contains locale files for English (en) and German (de). We use namespaces to keep bundles small and lazy-load what's needed per route.

- locales/
  - en/
    - common.json (global UI, language switcher, legal labels)
    - layout.json (head meta, skip links)
  - de/
    - common.json
    - layout.json
- namespaces.ts (namespace type and helpers)

Next steps:
1. Wire SSR locale detection (cookie + Accept-Language) and expose `locale` via +layout.server.ts.
2. Add a language switcher (EN/DE) that sets the cookie, runs the fade transition, and navigates to the target locale URL.
3. Migrate UI strings into `common.json` and page meta into `layout.json`.
4. Add more namespaces (hero, about, contact, projects, project-bura, legal) and migrate the rest incrementally.
5. Introduce `[lang=lang]` route segment and redirect `/` to the chosen locale.

--- END OF FILE src\lib\i18n\README.md ---

--- START OF FILE src\lib\i18n\locales\de\common.json ---
{
  "legal": {
    "impressum": "Impressum",
    "datenschutz": "Datenschutz",
    "barrierefreiheit": "Barrierefreiheit"
  },
  "language": {
    "groupLabel": "Sprache",
    "en": "EN",
    "de": "DE",
    "switchToEn": "Zu Englisch wechseln",
    "switchToDe": "Zu Deutsch wechseln"
  },
  "about": {
    "title": "Über mich",
    "introduction": "Ich bin Data Scientist, spezialisiert auf die Entwicklung von End-to-End-Systemen, die aus realen Sensordaten handlungsrelevante Informationen gewinnen. Die nachfolgenden Projekte demonstrieren meine Kompetenz in der Integration von maßgeschneiderter Hardware, robuster Software und fortschrittlichen Wahrnehmungsmodellen zur Lösung komplexer operativer Herausforderungen.",
    "contactMe": "Kontakt aufnehmen"
  },
  "contact": {
    "title": "Kontakt",
    "outroMessage": "Ich freue mich über neue Projekte, Kooperationen oder Möglichkeiten. Melden Sie sich gern!",
    "emailLabel": "E-Mail senden",
    "resumeLabel": "Lebenslauf ansehen"
  },
  "loading": {
    "loading": "LADEN...",
    "error": "FEHLER BEIM LADEN"
  },
  "hero": {
    "greeting": "Hallo, ich bin",
    "name": "Ihr Name",
    "introduction": "Ein Data Scientist mit Leidenschaft für Erkenntnisse und intelligente Lösungen."
  },
  "projects": {
    "readMore": "Mehr erfahren",
    "viewDetailsPrefix": "Details anzeigen für",
    "cardAriaPrefix": "Interaktive Projektkarte für"
  },
  "a11y": {
    "backHome": "Zurück zur Startseite",
    "legalFooter": "Links zu rechtlichen Informationen",
    "legalNav": "Rechtliche Links"
  }
}

--- END OF FILE src\lib\i18n\locales\de\common.json ---

--- START OF FILE src\lib\i18n\locales\de\layout.json ---
{
  "meta": {
    "siteTitle": "Ihr Name - Portfolio",
    "siteDescription": "Ein Portfolio mit Projekten und Expertise."
  },
  "a11y": {
    "skipToContent": "Zum Hauptinhalt springen"
  }
}

--- END OF FILE src\lib\i18n\locales\de\layout.json ---

--- START OF FILE src\lib\i18n\locales\en\common.json ---
{
  "legal": {
    "impressum": "Imprint",
    "datenschutz": "Privacy",
    "barrierefreiheit": "Accessibility"
  },
  "language": {
    "groupLabel": "Language",
    "en": "EN",
    "de": "DE",
    "switchToEn": "Switch to English",
    "switchToDe": "Switch to German"
  },
  "about": {
    "title": "About Me",
  "introduction": "I am a data scientist specializing in building end-to-end systems that derive actionable intelligence from real-world sensor data. The projects below demonstrate my capability in integrating custom hardware, robust software, and advanced perception models to solve complex operational challenges.",
  "contactMe": "Contact Me"
  },
  "contact": {
    "title": "Get in Touch",
    "outroMessage": "I'm always excited to discuss new projects, collaborations, or opportunities. Feel free to reach out!",
    "emailLabel": "Email me",
    "resumeLabel": "View my resume"
  },
  "loading": {
    "loading": "LOADING...",
    "error": "ERROR LOADING"
  },
  "hero": {
    "greeting": "Hello, I'm",
    "name": "Your Name",
    "introduction": "A data scientist passionate about insights and intelligent solutions."
  },
  "projects": {
  "readMore": "Read more",
  "viewDetailsPrefix": "View details for",
  "cardAriaPrefix": "Interactive project card for"
  },
  "a11y": {
    "backHome": "Back to home",
    "legalFooter": "Legal information links",
    "legalNav": "Legal Links"
  }
}

--- END OF FILE src\lib\i18n\locales\en\common.json ---

--- START OF FILE src\lib\i18n\locales\en\layout.json ---
{
  "meta": {
    "siteTitle": "Your Name - Portfolio",
    "siteDescription": "A portfolio showcasing projects and expertise."
  },
  "a11y": {
    "skipToContent": "Skip to main content"
  }
}

--- END OF FILE src\lib\i18n\locales\en\layout.json ---

--- START OF FILE src\lib\server\locale.ts ---
// src/lib/server/locale.ts
import type { Cookies } from '@sveltejs/kit';

export const SUPPORTED = ['en', 'de'] as const;
export type Locale = typeof SUPPORTED[number];
export const DEFAULT_LOCALE: Locale = 'en';

export function pickFromAcceptLanguage(header: string | null): Locale | undefined {
  if (!header) return undefined;
  const lowered = header.toLowerCase();
  if (lowered.includes('de')) return 'de';
  if (lowered.includes('en')) return 'en';
  return undefined;
}

const GERMAN_COUNTRIES = new Set(['DE', 'AT', 'CH', 'LI', 'LU']);

export function localeFromCountryCode(code: string | null | undefined): Locale | undefined {
  if (!code) return undefined;
  const upper = code.trim().slice(0, 2).toUpperCase();
  if (!upper) return undefined;
  return GERMAN_COUNTRIES.has(upper) ? 'de' : 'en';
}

export function extractCountryCodeFromHeaders(get: (name: string) => string | null): string | undefined {
  // Common CDN/host headers
  // Cloudflare: CF-IPCountry, Vercel: x-vercel-ip-country, Fastly: Fastly-GeoIP-Country-Code | X-Fastly-Country-Code
  // Generic/Custom: X-Country-Code, X-Geo-Country; Netlify: x-nf-geo (JSON string)
  const candidates = [
    'cf-ipcountry',
    'x-vercel-ip-country',
    'fastly-geoip-country-code',
    'x-fastly-country-code',
    'x-country-code',
    'x-geo-country'
  ];
  for (const name of candidates) {
    const v = get(name);
    if (v && v.trim()) return v.trim();
  }

  // Netlify specific header (JSON string)
  const nf = get('x-nf-geo');
  if (nf) {
    try {
      const data = JSON.parse(nf);
      const code = data?.country?.code || data?.country?.toString?.();
      if (code) return String(code);
    } catch {
      // ignore parsing errors
    }
  }
  return undefined;
}

export function decideLocale(opts: {
  urlLocale?: string | null;
  cookieLocale?: string | null;
  acceptLanguage?: string | null;
  countryCode?: string | null;
}): Locale {
  // 1) Explicit URL wins
  const url = (opts.urlLocale || '').toLowerCase();
  if (SUPPORTED.includes(url as Locale)) return url as Locale;

  // 2) Cookie next
  const cookie = (opts.cookieLocale || '').toLowerCase();
  if (SUPPORTED.includes(cookie as Locale)) return cookie as Locale;

  // 3) Accept-Language next
  const fromAL = pickFromAcceptLanguage(opts.acceptLanguage ?? null);
  if (fromAL) return fromAL;

  // 4) GeoIP country (final fallback)
  const fromGeo = localeFromCountryCode(opts.countryCode ?? undefined);
  if (fromGeo) return fromGeo;

  // 5) Default
  return DEFAULT_LOCALE;
}

export function syncLocaleCookie(cookies: Cookies, locale: Locale) {
  if (cookies.get('locale') !== locale) {
    cookies.set('locale', locale, {
      path: '/',
      httpOnly: false,
      sameSite: 'lax',
      maxAge: 60 * 60 * 24 * 365
    });
  }
}

export function setVaryHeaders(setHeaders: (headers: Record<string, string>) => void) {
  // Ensure caches consider language and geo headers
  const varyValues = [
    'Accept-Language',
    'Cookie',
    'CF-IPCountry',
    'X-Country-Code',
    'X-Geo-Country',
    'X-Vercel-IP-Country',
    'Fastly-GeoIP-Country-Code',
    'X-Fastly-Country-Code',
    'X-NF-Geo'
  ];
  setHeaders({ Vary: varyValues.join(', ') });
}

--- END OF FILE src\lib\server\locale.ts ---

--- START OF FILE src\lib\stores\preloadingStore.ts ---
// src/lib/stores/preloadingStore.ts
import { writable, derived, get } from 'svelte/store';

export type TaskStatus = 'idle' | 'pending' | 'loading' | 'loaded' | 'error';
export type AssetStatus = 'idle' | 'loading' | 'loaded' | 'error';

export interface PreloadTask {
  id: string;
  status: TaskStatus;
  progress?: number;
  message?: string;
  priority?: number;
}

// This store tracks individual asset URLs to prevent re-downloads
const assetLoadingStatus = writable<Record<string, AssetStatus>>({});

// This store tracks tasks for the initial site loading screen
const tasks = writable<Record<string, PreloadTask>>({});

// Configuration for the initial loading screen
export const minimumLoadingDuration = 1780; // Minimum time to show loading screen (ms)

/**
 * Tracks whether the initial, full-site loading sequence has completed.
 * Once true, the main loading screen should not reappear.
 */
export const initialSiteLoadComplete = writable<boolean>(false);

/**
 * Overall loading progress from 0 to 1 for the initial loading screen
 */
export const loadingProgress = derived(tasks, $tasks => {
  const allTasksArray = Object.values($tasks);
  if (allTasksArray.length === 0) return 0;
  
  let totalWeight = 0;
  let weightedProgress = 0;
  
  allTasksArray.forEach(task => {
    const weight = task.priority || 1;
    totalWeight += weight;
    
    let taskProgress = 0;
    switch (task.status) {
      case 'loaded': taskProgress = 1; break;
      case 'error': taskProgress = 1; break;
      case 'loading': taskProgress = task.progress || 0.5; break;
      default: taskProgress = 0; break;
    }
    
    weightedProgress += taskProgress * weight;
  });
  
  return totalWeight > 0 ? weightedProgress / totalWeight : 0;
});

export const preloadingStore = {
  subscribe: tasks.subscribe,
  
  registerTask: (taskId: string, initialStatus: TaskStatus = 'pending', priority: number = 1) => {
    tasks.update(currentTasks => {
      if (!currentTasks[taskId] || currentTasks[taskId].status === 'idle' || currentTasks[taskId].status === 'error') {
        currentTasks[taskId] = { 
          id: taskId, 
          status: initialStatus,
          priority,
          progress: initialStatus === 'loading' ? 0.5 : undefined
        };
      } else {
        currentTasks[taskId].priority = priority;
      }
      return currentTasks;
    });
  },
  
  updateTaskStatus: (taskId: string, status: TaskStatus, message?: string) => {
    tasks.update(currentTasks => {
      if (currentTasks[taskId]) {
        if (currentTasks[taskId].status !== 'loaded' || status !== 'loading') {
          currentTasks[taskId].status = status;
          if (message) currentTasks[taskId].message = message;
          if (status === 'loaded' || status === 'error') {
            currentTasks[taskId].progress = 1;
          }
        }
      } else {
        currentTasks[taskId] = { 
          id: taskId, 
          status: status, 
          message: message,
          progress: status === 'loaded' ? 1 : 0
        };
      }
      return currentTasks;
    });
  },
  
  updateTaskProgress: (taskId: string, progress: number) => {
    tasks.update(currentTasks => {
      if (currentTasks[taskId]) {
        currentTasks[taskId].progress = Math.max(0, Math.min(1, progress));
      }
      return currentTasks;
    });
  },
  
  getTaskStatus: (taskId: string): TaskStatus | undefined => {
    const currentTasks = get(tasks);
    return currentTasks[taskId]?.status;
  },
  
  resetTasks: () => {
    tasks.set({});
    initialSiteLoadComplete.set(false);
    assetLoadingStatus.set({});
  },

  getAssetStatus: (url: string): AssetStatus => {
    return get(assetLoadingStatus)[url] || 'idle';
  },

  setAssetStatus: (url: string, status: AssetStatus) => {
    assetLoadingStatus.update(current => {
      current[url] = status;
      return current;
    });
  }
};

export const overallLoadingState = derived(tasks, $tasks => {
  const allTasksArray = Object.values($tasks);

  if (allTasksArray.length === 0) return 'idle';
  if (allTasksArray.some(task => task.status === 'error')) return 'error';
  if (allTasksArray.every(task => task.status === 'loaded')) return 'loaded';
  if (allTasksArray.some(task => task.status === 'loading' || task.status === 'pending')) return 'loading';
  return 'idle';
});

export const startLoadingTask = (taskId: string, priority: number = 1) => {
  preloadingStore.registerTask(taskId, 'loading', priority);
};

/**
 * A robust, generic function to preload an array of assets (images, fonts, etc.).
 * It updates the central asset status store to prevent re-downloads.
 * @param urls An array of asset URLs to load.
 * @returns A promise that resolves when all assets are loaded, or rejects on the first error.
 */
export async function preloadAssets(urls: string[]): Promise<void> {
  const promises: Promise<unknown>[] = [];

  for (const url of urls) {
    const status = preloadingStore.getAssetStatus(url);
    if (status === 'loaded' || status === 'loading') {
      continue;
    }
    
    preloadingStore.setAssetStatus(url, 'loading');

    const promise = new Promise((resolve, reject) => {
      // Basic image preloader
      if (/\.(jpg|jpeg|png|webp|gif|svg)$/i.test(url)) {
        const img = new Image();
        img.src = url;
        img.onload = () => {
          preloadingStore.setAssetStatus(url, 'loaded');
          resolve(url);
        };
        img.onerror = () => {
          preloadingStore.setAssetStatus(url, 'error');
          reject(new Error(`Failed to load image: ${url}`));
        };
      } 
      // Basic font preloader (for .json from FontLoader)
      else if (/\.json$/i.test(url)) {
        fetch(url)
          .then(response => {
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return response.json();
          })
          .then(() => {
            preloadingStore.setAssetStatus(url, 'loaded');
            resolve(url);
          })
          .catch(error => {
            preloadingStore.setAssetStatus(url, 'error');
            reject(new Error(`Failed to load font data: ${url} - ${error.message}`));
          });
      }
      // Add other file types (videos, etc.) here if needed
      else {
        console.warn(`Preloading not implemented for file type: ${url}`);
        resolve(url); // Resolve unsupported types immediately
      }
    });
    promises.push(promise);
  }

  await Promise.all(promises);
}
--- END OF FILE src\lib\stores\preloadingStore.ts ---

--- START OF FILE src\lib\stores\renderProfile.ts ---
// src/lib/stores/renderProfile.ts
import { readable, writable, derived, get } from 'svelte/store';
import { browser } from '$app/environment';
import { page } from '$app/stores';

type RenderProfile = {
  isMobile: boolean;
  hasCoarsePointer: boolean;
  prefersReducedMotion: boolean;
  // Internal: debug/override flags
  forceMobile?: boolean | null;
};

const initial: RenderProfile = {
  isMobile: false,
  hasCoarsePointer: false,
  prefersReducedMotion: false,
  forceMobile: null
};

const state = writable<RenderProfile>(initial);

// Media query helpers
function mql(query: string): MediaQueryList | null {
  if (!browser || typeof window.matchMedia !== 'function') return null;
  try { return window.matchMedia(query); } catch { return null; }
}

// Set up listeners only in browser
if (browser) {
  const mqMobile = mql('(max-width: 768px)');
  const mqCoarse = mql('(pointer: coarse)');
  const mqReduced = mql('(prefers-reduced-motion: reduce)');

  const compute = (override: boolean | null = (get(state).forceMobile ?? null)) => {
    const isMobileWidth = mqMobile ? mqMobile.matches : false;
    const coarse = mqCoarse ? mqCoarse.matches : false;
    const reduced = mqReduced ? mqReduced.matches : false;
    // Default detection: width or coarse pointer implies mobile
    const detectedMobile = isMobileWidth || coarse;
    state.update((s) => ({
      ...s,
      isMobile: override === null ? detectedMobile : !!override,
      hasCoarsePointer: coarse,
      prefersReducedMotion: reduced
    }));
  };

  // Initial compute
  compute();

  // Listeners
  const onChange = () => compute();
  mqMobile?.addEventListener('change', onChange);
  mqCoarse?.addEventListener('change', onChange);
  mqReduced?.addEventListener('change', onChange);

  // Resize fallback for UAs not updating MQLs reliably
  const onResize = () => compute();
  window.addEventListener('orientationchange', onResize);
  window.addEventListener('resize', onResize);

  // Clean-up in HMR scenarios
  if (import.meta && (import.meta as any).hot) {
    (import.meta as any).hot.dispose(() => {
      mqMobile?.removeEventListener('change', onChange);
      mqCoarse?.removeEventListener('change', onChange);
      mqReduced?.removeEventListener('change', onChange);
      window.removeEventListener('orientationchange', onResize);
      window.removeEventListener('resize', onResize);
    });
  }
}

// Expose derived store synced with ?mobile=1/0 override
export const renderProfile = derived([state, page], ([$state, $page]) => {
  if (!browser) return $state; // SSR safe
  const sp = $page?.url?.searchParams;
  const mobileParam = sp?.get('mobile');
  let forceMobile: boolean | null = null;
  if (mobileParam === '1' || mobileParam === 'true') forceMobile = true;
  if (mobileParam === '0' || mobileParam === 'false') forceMobile = false;
  if (forceMobile !== $state.forceMobile) {
    // Update override and recompute
    state.update((s) => ({ ...s, forceMobile }));
    // Computation will run on next tick for browser listeners; also do a direct apply
    if (browser) {
      const mqMobile = mql('(max-width: 768px)');
      const mqCoarse = mql('(pointer: coarse)');
      const mqReduced = mql('(prefers-reduced-motion: reduce)');
      const isMobileWidth = mqMobile ? mqMobile.matches : false;
      const coarse = mqCoarse ? mqCoarse.matches : false;
      const reduced = mqReduced ? mqReduced.matches : false;
      const detectedMobile = isMobileWidth || coarse;
      state.set({
        isMobile: forceMobile === null ? detectedMobile : !!forceMobile,
        hasCoarsePointer: coarse,
        prefersReducedMotion: reduced,
        forceMobile
      });
    }
  }
  return get(state);
});

export const isMobile = derived(renderProfile, ($p) => $p.isMobile);
export const prefersReducedMotion = derived(renderProfile, ($p) => $p.prefersReducedMotion);

--- END OF FILE src\lib\stores\renderProfile.ts ---

--- START OF FILE src\lib\stores\sectionStateStore.ts ---
// src/lib/stores/sectionStateStore.ts
import { writable } from 'svelte/store';

/**
 * Defines the possible lifecycle states for a main page section.
 * - IDLE: Not loaded, not a neighbor of the active section.
 * - PRELOADING: Assets are being fetched and/or effects are being initialized.
 * - READY: Fully prepared for a seamless transition.
 * - ACTIVE: Currently visible to the user.
 * - COOLDOWN: No longer a neighbor, can be unloaded to free resources.
 */
export type SectionState = 'IDLE' | 'PRELOADING' | 'READY' | 'ACTIVE' | 'COOLDOWN';

/**
 * A writable store that holds an array of states, one for each section
 * in the main portfolio page.
 */
export const sectionStates = writable<SectionState[]>([]);
--- END OF FILE src\lib\stores\sectionStateStore.ts ---

--- START OF FILE src\lib\stores\transitionStore.ts ---
// src/lib/stores/transitionStore.ts
import { writable } from 'svelte/store';
import { goto } from '$app/navigation';

interface TransitionState {
  visible: boolean;
  color: string;
}

const { subscribe, update } = writable<TransitionState>({
  visible: false,
  color: '#000000', // Default to black for our fade effect
});

// --- MODIFICATION: Reduced transition duration for a "snappier" feel ---
const TRANSITION_DURATION = 90; // ms

export const transitionStore = {
  subscribe,
  /**
   * Manages a smooth fade-to-black transition between routes.
   * @param href The destination URL to navigate to.
   */
  fadeToBlackAndNavigate: (href: string) => {
    // 1. Make the overlay visible to start the fade-in animation.
    update(state => ({ ...state, visible: true }));

    // 2. Wait for the fade-in animation to complete.
    setTimeout(() => {
      // 3. After the screen is black, perform the actual navigation.
      goto(href).then(() => {
        // 4. Once SvelteKit has loaded the new page, start fading out the overlay.
        // A tiny delay ensures the new page's content has started rendering.
        setTimeout(() => {
            update(state => ({ ...state, visible: false }));
        }, 50); 
      });
    }, TRANSITION_DURATION); // This duration MUST match the CSS/Svelte transition duration.
  }
};
--- END OF FILE src\lib\stores\transitionStore.ts ---

--- START OF FILE src\lib\three\BloomEffect.ts ---
// src/lib/three/BloomEffect.ts
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';

export class BloomEffect {
    private renderer: THREE.WebGLRenderer;
    private scene: THREE.Scene;
    // MODIFIED: Camera type is now more generic to support Orthographic camera
    private camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;
    
    public composer: EffectComposer;
    private renderPass: RenderPass;
    private bloomPass: UnrealBloomPass;
    private outputPass: OutputPass;

    // Bloom Parameters (shared default configuration)
    private bloomParams = {
        threshold: 0.4,
        strength: 0.15,
        radius: 0.1,
    };

    constructor(
        renderer: THREE.WebGLRenderer, 
        scene: THREE.Scene, 
        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,
        width: number, 
        height: number
    ) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;

        this.composer = new EffectComposer(this.renderer);
        this.composer.setSize(width, height);
        this.composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // 1. Render the original scene
        this.renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(this.renderPass);

        // 2. Apply bloom
        this.bloomPass = new UnrealBloomPass(
            new THREE.Vector2(width, height),
            this.bloomParams.strength,
            this.bloomParams.radius,
            this.bloomParams.threshold
        );
        this.composer.addPass(this.bloomPass);
        
        // 3. Output the result (handles tone mapping and color space conversion)
        this.outputPass = new OutputPass();
        this.composer.addPass(this.outputPass);
    }

    public render(deltaTime: number): void {
        this.composer.render(deltaTime);
    }

    public setSize(width: number, height: number): void {
        this.composer.setSize(width, height);
        this.composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }

    public updateParameters(params: { threshold?: number; strength?: number; radius?: number }): void {
        if (params.threshold !== undefined) this.bloomPass.threshold = params.threshold;
        if (params.strength !== undefined) this.bloomPass.strength = params.strength;
        if (params.radius !== undefined) this.bloomPass.radius = params.radius;
    }

    public dispose(): void {
        // EffectComposer automatically disposes its passes' render targets
        // if they were created internally by the composer or pass.
    }
}
--- END OF FILE src\lib\three\BloomEffect.ts ---

--- START OF FILE src\lib\three\contactRaymarching_optimized.glsl ---
//version 300 es
precision highp float;
precision highp int;

/* contactRaymarching_fixed.glsl
   Improvements:
   - Correct smooth-min (Inigo Quilez version, no distortion term)
   - Normals blended alongside distance for smooth shading at junctions
   - Slightly larger NORMAL_EPS for stable gradients
*/

#ifndef MAX_SPHERES
  #define MAX_SPHERES 12
#endif
#ifndef MAX_STEPS
  #define MAX_STEPS 96
#endif
#define MAX_SPHERES4 (MAX_SPHERES * 4)
#define SHADOW_STEPS 16

out vec4 fragColor;
in vec2 vUv;

/* Uniforms */
uniform float uTime;
uniform vec2  uResolution;

uniform int   uSphereCount;
uniform float uSpheres[MAX_SPHERES4];

uniform vec3  uSphereColor;
uniform vec3  uLightColor;
uniform vec3  uLightPosition;

uniform float uAmbientIntensity;
uniform float uDiffuseIntensity;
uniform float uSpecularIntensity;
uniform float uFresnelPower;
uniform float uSpecularPower;
uniform float uContrast;
uniform vec3  uBackgroundColor;
uniform float uFogDensity;
uniform float uCameraDistance;
uniform int   uMaxSteps;

uniform float uSmoothness;

/* Constants */
const float PI = 3.141592653589793;
const float EPSILON = 0.0001;
const float NORMAL_EPS = 0.002;   // larger epsilon for stable normals
const float HIT_EPS = 0.0025;
const float STEP_SCALE = 0.92;
const float MIN_STEP = 0.0005;
const float MAX_DIST = 100.0;

/* Data struct for returning both distance and normal */
struct SDFResult {
  float dist;
  vec3 normal;
};

/* Helpers */
vec4 sphereAt(int i) {
  int b = i * 4;
  return vec4(uSpheres[b], uSpheres[b + 1], uSpheres[b + 2], uSpheres[b + 3]);
}

SDFResult sdSphere(vec3 p, vec4 s) {
  vec3 q = p - s.xyz;
  float d = length(q) - s.w;
  return SDFResult(d, normalize(q));
}

/* Canonical smooth min (Inigo Quilez) with normal blending */
SDFResult sminBlend(SDFResult a, SDFResult b, float k) {
  float h = clamp(0.5 + 0.5 * (b.dist - a.dist) / k, 0.0, 1.0);
  float d = mix(b.dist, a.dist, h) - k * h * (1.0 - h);
  vec3 n = normalize(mix(b.normal, a.normal, h));
  return SDFResult(d, n);
}

/* Scene SDF */
SDFResult sdf(vec3 p) {
  SDFResult res;
  res.dist = MAX_DIST;
  res.normal = vec3(0.0, 1.0, 0.0);

  for (int i = 0; i < MAX_SPHERES; ++i) {
    if (i >= uSphereCount) break;
    vec4 s = sphereAt(i);
    if (s.w <= 0.0) continue;

    SDFResult sphere = sdSphere(p, s);
    res = sminBlend(res, sphere, uSmoothness);

    if (res.dist < -0.5 * uSmoothness) break;
  }
  return res;
}

/* Normal calculation: fall back to finite difference if needed */
vec3 calcNormal(vec3 p) {
  vec2 e = vec2(NORMAL_EPS, 0.0);
  return normalize(vec3(
    sdf(p + e.xyy).dist - sdf(p - e.xyy).dist,
    sdf(p + e.yxy).dist - sdf(p - e.yxy).dist,
    sdf(p + e.yyx).dist - sdf(p - e.yyx).dist
  ));
}

/* Ambient Occlusion */
float ambientOcclusion(vec3 p, vec3 n) {
  float occ = 0.0;
  float weight = 1.0;
  for (int i = 0; i < 5; ++i) {
    float dist = 0.01 + 0.02 * float(i * i);
    float h = sdf(p + n * dist).dist;
    occ += (dist - h) * weight;
    weight *= 0.85;
  }
  return clamp(1.0 - occ, 0.0, 1.0);
}

/* Soft shadow */
float softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {
  float res = 1.0;
  float t = mint;
  for (int i = 0; i < SHADOW_STEPS; ++i) {
    if (t >= maxt) break;
    float h = sdf(ro + rd * t).dist;
    if (h < EPSILON) return 0.0;
    res = min(res, k * h / t);
    t += h;
  }
  return clamp(res, 0.0, 1.0);
}

/* Raymarch */
float raymarch(vec3 ro, vec3 rd) {
  float t = 0.0;
  for (int i = 0; i < MAX_STEPS; ++i) {
    if (i >= uMaxSteps) break;
    vec3 p = ro + rd * t;
    float d = sdf(p).dist;
    if (d < HIT_EPS) return t;
    float step = max(d * STEP_SCALE, MIN_STEP);
    t += step;
    if (t > MAX_DIST) break;
  }
  return -1.0;
}

/* Lighting (Phong + Fresnel + soft shadows) */
vec3 lighting(vec3 p, vec3 rd, float tHit) {
  if (tHit < 0.0) return vec3(0.0);

  SDFResult res = sdf(p);
  vec3 normal = res.normal;  // use blended normal
  vec3 viewDir = normalize(-rd);

  vec3 baseColor = uSphereColor;
  vec3 ambient = baseColor * uAmbientIntensity;

  vec3 lightDir = normalize(uLightPosition);
  float diff = max(dot(normal, lightDir), 0.0);
  vec3 diffuse = baseColor * uLightColor * diff * uDiffuseIntensity;

  vec3 reflectDir = reflect(-lightDir, normal);
  float specAngle = max(dot(viewDir, reflectDir), 0.0);
  float spec = pow(specAngle, max(1.0, uSpecularPower));
  vec3 specular = uLightColor * spec * uSpecularIntensity;

  float fresnel = pow(1.0 - max(dot(viewDir, normal), 0.0), uFresnelPower);
  specular *= fresnel;

  float ao = ambientOcclusion(p, normal);
  float shadow = softShadow(p + normal * HIT_EPS * 3.0, lightDir, 0.01, 10.0, 16.0);

  vec3 color = ambient * ao + (diffuse * shadow + specular) * ao;
  color = pow(color, vec3(uContrast));
  return color;
}

/* Camera / ray */
vec3 makeRay(vec2 uv) {
  vec2 p = (uv - 0.5) * 2.0;
  p.x *= uResolution.x / uResolution.y;
  vec3 rd = normalize(vec3(p, 1.0));

  float camRotY = sin(uTime * 0.1) * 0.1;
  float camRotX = cos(uTime * 0.08) * 0.05;

  float cY = cos(camRotY), sY = sin(camRotY);
  rd = vec3(cY * rd.x + sY * rd.z, rd.y, -sY * rd.x + cY * rd.z);

  float cX = cos(camRotX), sX = sin(camRotX);
  rd = vec3(rd.x, cX * rd.y - sX * rd.z, sX * rd.y + cX * rd.z);

  return rd;
}

void main() {
  vec3 ro = vec3(0.0, 0.0, -uCameraDistance);
  vec3 rd = makeRay(vUv);

  float t = raymarch(ro, rd);

  if (t > 0.0) {
    vec3 p = ro + rd * t;
    vec3 color = lighting(p, rd, t);

    float fogAmt = 1.0 - exp(-t * uFogDensity);
    color = mix(color, uBackgroundColor, fogAmt);

    fragColor = vec4(color, 1.0);
  } else {
    fragColor = vec4(0.0, 0.0, 0.0, 0.0);
  }
}

--- END OF FILE src\lib\three\contactRaymarching_optimized.glsl ---

--- START OF FILE src\lib\three\heroParticleLogic.ts ---
// src/lib/three/heroParticleLogic.ts
import * as THREE from 'three';
import type { Font } from 'three/examples/jsm/loaders/FontLoader.js';
import { BloomEffect } from './BloomEffect';
import Stats from 'stats.js';

// Shaders (VERTEX_SHADER and FRAGMENT_SHADER remain the same)
export const VERTEX_SHADER = `
attribute float size;
attribute vec3 customColor;
attribute float symbolState;
attribute float symbolIndex;
attribute float variability;

varying vec3 vColor;
varying float vSymbolState;
varying float vSymbolIndex;
varying float vVariability;

void main() {
  vColor = customColor;
  vSymbolState = symbolState;
  vSymbolIndex = symbolIndex;
  vVariability = variability;
  
  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
  gl_PointSize = size * (300.0 / -mvPosition.z);
  gl_Position = projectionMatrix * mvPosition;
}
`;

export const FRAGMENT_SHADER = `
uniform sampler2D pointTexture;
uniform sampler2D symbolsTexture;
uniform float symbolRows;

varying vec3 vColor;
varying float vSymbolState;
varying float vSymbolIndex;
varying float vVariability;

void main() {
  if(vSymbolState < 0.5) { // It's a normal particle (dot)
    gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
  } 
  else { // It's a symbol
    const float symbolsPerRow = 8.0;
    float symbolIndexVal = vSymbolIndex;
    
    float columnIndex = mod(symbolIndexVal, symbolsPerRow);
    float rowIndex = floor(symbolIndexVal / symbolsPerRow);
    
    vec2 symbolCoord = gl_PointCoord;
    symbolCoord.x = (symbolCoord.x + columnIndex) / symbolsPerRow;
    symbolCoord.y = (symbolCoord.y + rowIndex) / symbolRows; // Use dynamic row count
    
    vec4 symbolTexColor = texture2D(symbolsTexture, symbolCoord);
    
    if(symbolTexColor.a < 0.3) discard; // Discard transparent parts of the symbol
    
    gl_FragColor = vec4(vColor, symbolTexColor.a); 
  }
}
`;

export interface EnvironmentOptions {
  initialInternalScale?: number; // e.g., 0.7 for mobile
  maxInternalDim?: number;       // e.g., 960 for mobile
  amountScale?: number;          // e.g., 0.85 to reduce initial particles
  antialias?: boolean;           // default true
  effectSpeed?: number;          // global speed multiplier
  referenceFps?: number;         // override reference FPS (default 60)
}

// Reference FPS baseline for converting legacy per-frame tuned constants
export const REF_FPS = 60;

export class Environment {
  public font: Font;
  public particleTexture: THREE.Texture;
  public container: HTMLElement;
  public scene!: THREE.Scene;
  public camera!: THREE.PerspectiveCamera;
  public renderer!: THREE.WebGLRenderer;
  public createParticles!: CreateParticles;
  private animationLoopCallback: (() => void) | null = null;

  private clock!: THREE.Clock; 
  private bloomEffect!: BloomEffect;

  private internalScale: number = 1.0; // dynamic internal resolution scale
  private MAX_INTERNAL_DIM = 1440; // cap for larger dimension (overridable)
  private readonly SCALE_FLOOR = 0.6;
  private readonly SCALE_CEIL = 1.0;
  private options: EnvironmentOptions | undefined;
  // performance tracking
  private frameTimes: number[] = [];
  private readonly FRAME_WINDOW = 50;
  private readonly HIGH_THRESHOLD = 19.5; // ~51 FPS
  private readonly LOW_THRESHOLD = 16.7;  // ~60 FPS to allow upscaling when stable
  private scaleCooldownSec = 0; // seconds
  private readonly SCALE_COOLDOWN_SEC = 45 / REF_FPS; // 45 frames originally
  private avgFrameMs = 0;
  // metrics flag
  private metricsEnabled = false;
  private debugOverlayActive = false;
  private debugKeyPressTimes: number[] = []; // timestamps of 'd' presses
  private readonly DEBUG_MULTI_PRESS_WINDOW = 800; // ms
  private statsInstance: Stats | null = null;
  private debugDomContainer: HTMLElement | null = null;
  private lastDomUpdateTime = 0;
  private readonly DOM_UPDATE_INTERVAL = 0.25; // seconds
  private boundKeyHandler = this.onKeyDown.bind(this);
  private isPageVisible = true;
  private boundOnVisibilityChange = this.onVisibilityChange.bind(this);

  private baseAmountScale = 1.0;
  private readonly AMOUNT_TIERS = [1.0, 0.85, 0.7, 0.55];
  private amountTierIdx = 0;
  private amountTierCooldownSec = 0; // seconds
  private readonly AMOUNT_TIER_COOLDOWN_SEC = 240 / REF_FPS; // 240 frames originally

  private effectSpeed: number = 1.0;
  private readonly referenceFps: number = REF_FPS;

  constructor(font: Font, particleTexture: THREE.Texture, container: HTMLElement, options?: EnvironmentOptions) {
    this.font = font;
    this.particleTexture = particleTexture;
    this.container = container;
    this.options = options;
    
    if (!this.container) {
      console.error("HeroParticleLogic: Container not provided to Environment!");
      return;
    }
    
  this.clock = new THREE.Clock(); 
  this.effectSpeed = options?.effectSpeed ?? 1.0;
  this.referenceFps = options?.referenceFps ?? REF_FPS;

    this.scene = new THREE.Scene();
    // Apply initial overrides for mobile or perf
    if (this.options?.maxInternalDim && this.options.maxInternalDim > 0) {
      this.MAX_INTERNAL_DIM = this.options.maxInternalDim;
    }
    if (this.options?.initialInternalScale && this.options.initialInternalScale > 0) {
      this.internalScale = Math.min(this.SCALE_CEIL, Math.max(this.SCALE_FLOOR, this.options.initialInternalScale));
    }

    this.createCamera();
    this.createRenderer();
    
    this.bloomEffect = new BloomEffect(
        this.renderer, 
        this.scene, 
        this.camera, 
        this.container.clientWidth, 
        this.container.clientHeight
    );

    this.setup(); 

    // Optionally reduce initial particle amount after first creation
    if (this.options?.amountScale && this.options.amountScale > 0 && this.options.amountScale < 1 && this.createParticles) {
      try {
        const current = this.createParticles.getAmount();
        const target = Math.max(100, Math.floor(current * this.options.amountScale));
        if (target < current) {
          this.createParticles.rebuildWithAmount(target);
        }
      } catch {}
    }
  this.bindWindowResize();
  document.addEventListener('visibilitychange', this.boundOnVisibilityChange);

  if (this.renderer) {
    this.startAnimationLoop();
  }
  // bind debug key listener
  window.addEventListener('keydown', this.boundKeyHandler);
  }

  public startAnimationLoop() {
    if (this.renderer && !this.animationLoopCallback) {
        this.animationLoopCallback = () => { this.render(); };
        this.renderer.setAnimationLoop(this.animationLoopCallback);
    }
  }

  public stopAnimationLoop() {
    if (this.renderer && this.animationLoopCallback) {
        this.renderer.setAnimationLoop(null);
        this.animationLoopCallback = null;
    }
  }

  public isLooping(): boolean {
    return !!this.animationLoopCallback;
  }

  private bindWindowResize() {
    window.addEventListener('resize', this.onWindowResize.bind(this));
  }

  private unbindWindowResize() {
    window.removeEventListener('resize', this.onWindowResize.bind(this));
  }

  private setup() {
    this.createParticles = new CreateParticles(
      this.scene, 
      this.font, 
      this.particleTexture, 
      this.camera, 
      this.renderer, 
      this.container 
    );
  }

  public render() {
    const rawDt = this.clock.getDelta();
    const deltaTime = Math.min(rawDt, 0.05); // clamp large dt spikes after tab resume (effectSpeed applied inside subsystems)
    const beforeStats = this.statsInstance ? performance.now() : 0;
    if (this.statsInstance) this.statsInstance.begin();
    if (this.isPageVisible) {
      const frameMs = deltaTime * 1000;
      this.frameTimes.push(frameMs);
      if (this.frameTimes.length > this.FRAME_WINDOW) this.frameTimes.shift();
      if (this.frameTimes.length === this.FRAME_WINDOW) {
      this.avgFrameMs = this.frameTimes.reduce((a,b)=>a+b,0)/this.frameTimes.length;
      if (this.scaleCooldownSec > 0) this.scaleCooldownSec -= deltaTime;
      let changed = false;
      if (this.scaleCooldownSec <= 0) {
        if (this.avgFrameMs > this.HIGH_THRESHOLD && this.internalScale > this.SCALE_FLOOR) {
          this.internalScale = Math.max(this.SCALE_FLOOR, +(this.internalScale - 0.1).toFixed(2));
          changed = true;
        } else if (this.avgFrameMs < this.LOW_THRESHOLD && this.internalScale < this.SCALE_CEIL) {
          this.internalScale = Math.min(this.SCALE_CEIL, +(this.internalScale + 0.1).toFixed(2));
          changed = true;
        }
        if (changed) { this.scaleCooldownSec = this.SCALE_COOLDOWN_SEC; this.onWindowResize(); }
      }
      // Particle amount tiering: only when at scale floor and still slow OR restore when fast
      if (this.createParticles) {
        if (this.amountTierCooldownSec > 0) this.amountTierCooldownSec -= deltaTime;
        if (this.amountTierCooldownSec <= 0) {
          if (this.internalScale <= this.SCALE_FLOOR + 1e-3 && this.avgFrameMs > this.HIGH_THRESHOLD + 1.0) {
            if (this.amountTierIdx < this.AMOUNT_TIERS.length - 1) {
              this.amountTierIdx++;
              const newAmount = Math.floor(this.createParticles.getAmount() * this.AMOUNT_TIERS[this.amountTierIdx]);
              this.createParticles.rebuildWithAmount(newAmount);
              this.amountTierCooldownSec = this.AMOUNT_TIER_COOLDOWN_SEC;
            }
          } else if (this.avgFrameMs < this.LOW_THRESHOLD - 0.7) {
            if (this.amountTierIdx > 0) {
              this.amountTierIdx--;
              const newAmount = Math.floor(this.createParticles.getAmount() / this.AMOUNT_TIERS[this.amountTierIdx+1]);
              this.createParticles.rebuildWithAmount(newAmount);
              this.amountTierCooldownSec = this.AMOUNT_TIER_COOLDOWN_SEC;
            }
          }
        }
      }
      }
    }
    // Force stable background
    this.scene.background = new THREE.Color(0x000000);
  if (this.createParticles) this.createParticles.render(deltaTime, this.effectSpeed); 
    if (this.bloomEffect) {
      this.bloomEffect.render(deltaTime);
    } else if (this.renderer && this.scene && this.camera) { 
      this.renderer.render(this.scene, this.camera);
    }
    if (this.statsInstance) this.statsInstance.end();
    if (this.debugOverlayActive && this.createParticles) {
      this.lastDomUpdateTime += deltaTime;
      if (this.lastDomUpdateTime >= this.DOM_UPDATE_INTERVAL) {
        this.lastDomUpdateTime = 0;
        this.updateDebugDom();
      }
    }
  }

  private createCamera() {
    this.camera = new THREE.PerspectiveCamera(
      65, 
      this.container.clientWidth / this.container.clientHeight, 
      1, 
      10000
    );
    this.camera.position.set(0, 0, 100);
  }

  private createRenderer() {
    this.renderer = new THREE.WebGLRenderer({
      antialias: this.options?.antialias ?? true,
      alpha: true 
    });
    // compute capped internal size
    const cssW = this.container.clientWidth;
    const cssH = this.container.clientHeight;
    const aspect = cssW / Math.max(1, cssH);
    let targetW = cssW;
    let targetH = cssH;
    if (cssW >= cssH) {
      if (cssW > this.MAX_INTERNAL_DIM) { targetW = this.MAX_INTERNAL_DIM; targetH = Math.round(targetW / aspect); }
    } else {
      if (cssH > this.MAX_INTERNAL_DIM) { targetH = this.MAX_INTERNAL_DIM; targetW = Math.round(targetH * aspect); }
    }
    targetW = Math.max(1, Math.round(targetW * this.internalScale));
    targetH = Math.max(1, Math.round(targetH * this.internalScale));
    this.renderer.setPixelRatio(1); // manual scaling
    this.renderer.setSize(targetW, targetH, false);
    this.renderer.setClearColor(0x000000, 0);
    if (THREE.ColorManagement.enabled) { 
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
    } else { 
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
    }
    this.container.appendChild(this.renderer.domElement);
    const canvas = this.renderer.domElement;
    // Accessibility: mark decorative canvas as hidden from assistive tech
    try {
      canvas.setAttribute('aria-hidden', 'true');
      canvas.setAttribute('role', 'presentation');
      canvas.setAttribute('tabindex', '-1');
    } catch {}
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    canvas.style.display = 'block';
    canvas.style.objectFit = 'contain';
  }
  // expose metrics
  public getMetrics() { return { internalScale: this.internalScale, avgFrameMs: this.avgFrameMs }; }
  public enableMetrics(v: boolean) { this.metricsEnabled = v; }
  public onWindowResize() {
    if (this.camera && this.renderer && this.container) {
      const cssW = this.container.clientWidth;
      const cssH = this.container.clientHeight;
      const aspect = cssW / Math.max(1, cssH);
      let targetW = cssW;
      let targetH = cssH;
      if (cssW >= cssH) {
        if (cssW > this.MAX_INTERNAL_DIM) { targetW = this.MAX_INTERNAL_DIM; targetH = Math.round(targetW / aspect); }
      } else {
        if (cssH > this.MAX_INTERNAL_DIM) { targetH = this.MAX_INTERNAL_DIM; targetW = Math.round(targetH * aspect); }
      }
      targetW = Math.max(1, Math.round(targetW * this.internalScale));
      targetH = Math.max(1, Math.round(targetH * this.internalScale));
      this.camera.aspect = cssW / cssH;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(targetW, targetH, false);
      const canvas = this.renderer.domElement;
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      if (this.bloomEffect) this.bloomEffect.setSize(targetW, targetH);
      if (this.createParticles) {
        if (this.createParticles.checkScreenSizeChange()) {
          this.createParticles.regenerateParticles();
        }
        // Always update symbol sizes to match new viewport height scaling
        this.createParticles.updateSymbolSizesForViewport();
      }
    }
  }

  public dispose() {
    this.stopAnimationLoop();
    this.unbindWindowResize();
  document.removeEventListener('visibilitychange', this.boundOnVisibilityChange);
    window.removeEventListener('keydown', this.boundKeyHandler);
    if (this.createParticles) {
      this.createParticles.dispose();
    }
    if (this.bloomEffect) {
        this.bloomEffect.dispose();
    }
    if (this.renderer) {
      this.renderer.dispose();
      if (this.renderer.domElement && this.renderer.domElement.parentNode) {
        this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
      }
    }
    if (this.scene) {
        this.scene.traverse(object => {
            const obj = object as THREE.Mesh; 
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach((material: THREE.Material) => material.dispose());
                } else {
                    (obj.material as THREE.Material).dispose();
                }
            }
        });
    }
  if (this.debugDomContainer && this.debugDomContainer.parentNode) {
    this.debugDomContainer.parentNode.removeChild(this.debugDomContainer);
    this.debugDomContainer = null;
  }
  }

  private onVisibilityChange() {
    const visible = document.visibilityState === 'visible';
    this.isPageVisible = visible;
    if (visible) {
      // clear metrics so stale hidden-frame spikes don't cause downscale
      this.frameTimes = [];
      this.avgFrameMs = 0;
      // small cooldown to avoid immediate rescale upon resume
      this.scaleCooldownSec = Math.max(this.scaleCooldownSec, this.SCALE_COOLDOWN_SEC / 2);
      // also pause amount tiering adjustments briefly
      this.amountTierCooldownSec = Math.max(this.amountTierCooldownSec, this.AMOUNT_TIER_COOLDOWN_SEC / 4);
    }
  }

  public setEffectSpeed(v: number) { this.effectSpeed = Math.max(0, v); }
  public getEffectSpeed() { return this.effectSpeed; }
  public isDebugOverlayActive() { return this.debugOverlayActive; }

  // --- Debug overlay handling ---
  private onKeyDown(e: KeyboardEvent) {
    if (e.key === 'd' || e.key === 'D') {
      const now = performance.now();
      // purge old presses
      this.debugKeyPressTimes = this.debugKeyPressTimes.filter(t => now - t < this.DEBUG_MULTI_PRESS_WINDOW);
      this.debugKeyPressTimes.push(now);
      if (!this.debugOverlayActive) {
        if (this.debugKeyPressTimes.length >= 3) {
          this.enableDebugOverlay();
          this.debugKeyPressTimes = [];
        }
      } else {
        // single press to deactivate
        this.disableDebugOverlay();
        this.debugKeyPressTimes = [];
      }
    }
  }

  private enableDebugOverlay() {
    if (this.debugOverlayActive) return;
    this.debugOverlayActive = true;
    // stats.js instance
    if (!this.statsInstance) {
      this.statsInstance = new Stats();
      // Panel 0 default: ms
      // Add FPS panel explicitly for clarity
      this.statsInstance.showPanel(0);
      this.statsInstance.dom.style.position = 'absolute';
      this.statsInstance.dom.style.top = '0';
      this.statsInstance.dom.style.left = '0';
    }
    if (!this.debugDomContainer) {
      this.debugDomContainer = document.createElement('div');
      this.debugDomContainer.style.position = 'absolute';
      this.debugDomContainer.style.top = '0';
      this.debugDomContainer.style.right = '0';
      this.debugDomContainer.style.maxWidth = '300px';
      this.debugDomContainer.style.background = 'rgba(0,0,0,0.6)';
      this.debugDomContainer.style.font = '12px monospace';
      this.debugDomContainer.style.color = '#0f0';
      this.debugDomContainer.style.padding = '6px 8px';
      this.debugDomContainer.style.lineHeight = '1.35';
      this.debugDomContainer.style.zIndex = '9999';
      this.debugDomContainer.style.pointerEvents = 'none';
      this.debugDomContainer.style.whiteSpace = 'pre';
    }
    if (this.container && this.statsInstance && !this.statsInstance.dom.parentNode) {
      this.container.appendChild(this.statsInstance.dom);
    }
    if (this.container && this.debugDomContainer && !this.debugDomContainer.parentNode) {
      this.container.appendChild(this.debugDomContainer);
    }
    this.lastDomUpdateTime = 0;
    this.updateDebugDom();
  }

  private disableDebugOverlay() {
    if (!this.debugOverlayActive) return;
    this.debugOverlayActive = false;
    if (this.statsInstance && this.statsInstance.dom.parentNode) {
      this.statsInstance.dom.parentNode.removeChild(this.statsInstance.dom);
    }
    if (this.debugDomContainer && this.debugDomContainer.parentNode) {
      this.debugDomContainer.parentNode.removeChild(this.debugDomContainer);
    }
    this.statsInstance = null; // allow GC
  }

  private updateDebugDom() {
    if (!this.debugDomContainer || !this.createParticles) return;
    const pMetrics = this.createParticles.getMetrics();
    const envMetrics = this.getMetrics();
    const lines = [
      'DEBUG OVERLAY (press d to hide)',
      `Particles: ${pMetrics.particleCount}`,
      `Active symbols: ${pMetrics.activeSymbols}`,
      `Symbol spawn rate: ${pMetrics.spawnRate.toFixed(2)} /s` ,
      `Avg heat: ${(pMetrics.avgHeat*100).toFixed(1)}%  Max heat: ${(pMetrics.maxHeat*100).toFixed(1)}%`,
      `Internal scale: ${envMetrics.internalScale.toFixed(2)}`,
      `Avg frame: ${envMetrics.avgFrameMs.toFixed(2)} ms` ,
      `Effect speed: ${this.effectSpeed.toFixed(2)}`
    ];
    this.debugDomContainer.textContent = lines.join('\n');
  }
}

interface ParticleData {
  text: string;
  amount: number;
  particleSize: number;
  textSize: number;
  area: number;
  ease: number;
  distortionThreshold: number;
  minFadeOutRate: number;
  maxFadeOutRate: number;
  minSymbolSize: number;
  maxSymbolSize: number;
  symbolMinThreshold: number;
  symbolMidThreshold: number;
  symbolMaxThreshold: number;
  symbolMinProb: number;
  symbolMaxProb: number;
  symbolHeatRequirement: number;
  particleCooldownDurationMin: number;
  particleCooldownDurationMax: number;
  symbolCooldownSpeedMultiplier: number;
}

// Screen size categories for responsive design
type ScreenSizeType = 'mobile' | 'tablet' | 'laptop' | 'desktop' | 'large' | 'ultrawide';

export class CreateParticles {
  private scene: THREE.Scene;
  private font: Font;
  private particleImg: THREE.Texture;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer; 
  private hostContainer: HTMLElement; 

  private raycaster: THREE.Raycaster;
  private mouse: THREE.Vector2;
  private isPressed: boolean = false;
  private hasMouseMoved: boolean = false; 
  // Prevent immediate color influence until user interacts
  private interactionActivated: boolean = false;
  private activationMoveThreshold: number = 12; // pixels of cumulative motion to activate
  private cumulativeMoveDistance: number = 0;
  private lastPointerClientX: number | null = null;
  private lastPointerClientY: number | null = null;

  private matrixSymbols: string[];
  private matrixColors: { [key: string]: THREE.Color };
  private bloomSymbolColor: THREE.Color; 
  // Color transition state for non-symbol dots
  private colorProgress: number[] = []; // [0..1], 0=white, 1=final green
  private influenceEMA: number[] = [];  // smoothed influence per particle
  private whiteCooldownFrames: number[] = []; // frames to wait before allowing pure white (legacy, will be replaced)
  private whiteCooldownTimeSec: number[] = []; // time-based replacement
  private kReturn: number = 0; // exponential return constant
  private lastEaseFrameValue: number = -1;
  private riseRateMul: number[] = []; // per-particle jitter
  private fallRateMul: number[] = [];
  private readonly colorParams = {
  // Distortion-driven color thresholds and rates (tuned for earlier, gradual greening)
  colorMinDistort: 2,   // start greening at small but noticeable displacement
  colorMaxDistort: 13.0,  // reach full green below symbol threshold range
  riseLerpPerSec: 4.5,    // approach speed when increasing
  fallLerpPerSec: 0.115,    // approach speed when decreasing
  minTimeToWhite: 5.0,   // seconds before returning to pure white
  curveShape: 1.6,       // perceptual curve for mid-tones
  finalDotGreenDarken: 0.1, // reduce brightness vs symbol green
  jitterRise: 0.1,       // ±10%
  jitterFall: 0.1        // ±10%
  };
  
  private particleStates: number[] = [];
  private heatLevels: number[] = [];
  private cooldownRates: number[] = []; // per-particle heat decay rate (per second)
  private symbolIndicesAttributeValues: number[] = [];
  private fadeOutRates: number[] = [];
  private fadeOutRatesPerSec: number[] = []; // converted per-second rates
  private cooldownDurationsSec: number[] = []; // store original durations in seconds for clarity
  private activeSymbolFactors: number[] = []; // store raw random factor (with modifiers) for active symbol resizing

  // --- Metrics tracking ---
  private activeSymbolsCount: number = 0;               // currently active symbol particles
  private symbolsSpawnedInWindow: number = 0;            // spawned within current accumulation window
  private spawnWindowTime: number = 0;                   // seconds accumulated for spawn rate window
  private symbolSpawnRate: number = 0;                   // symbols per second (rolling over ~1s windows)
  private readonly SPAWN_RATE_WINDOW_SEC = 1.0;          // window length to compute symbol spawn rate

  private data: ParticleData;
  private symbolsTexture!: THREE.Texture;
  private planeArea!: THREE.Mesh; 
  public particles!: THREE.Points;
  private geometryCopy!: THREE.BufferGeometry;
  private referenceTextHeight: number | null = null; // first measured text height (world units)
  private textBoundingHeight: number | null = null;  // current text height after latest generation

  private boundOnMouseDown: (event: MouseEvent) => void;
  private boundOnMouseMove: (event: MouseEvent) => void;
  private boundOnMouseUp: (event: MouseEvent) => void;
  private boundOnTouchStart: (event: TouchEvent) => void;
  private boundOnTouchMove: (event: TouchEvent) => void;
  private boundOnTouchEnd: (event: TouchEvent) => void;

  // Responsive design related properties
  private currentScreenSizeType: ScreenSizeType = 'desktop';
  private lastKnownWidth: number = 0;
  private lastKnownHeight: number = 0;
  private needsParticleRegeneration: boolean = false;

  private readonly SYMBOL_HUE_SHIFT_RANGE = 0.03;
  private readonly SYMBOL_LUMINANCE_REDUCTION_MAX = 0.08;
  private readonly SYMBOL_MIN_LUMINANCE_TARGET = 0.45;

  private readonly SCREEN_SIZES = {
    mobile: { maxWidth: 640 },
    tablet: { minWidth: 641, maxWidth: 1024 },
    laptop: { minWidth: 1025, maxWidth: 1440 },
    desktop: { minWidth: 1441, maxWidth: 1920 },
    large: { minWidth: 1921, maxWidth: 2560 },
    ultrawide: { minWidth: 2561 }
  };

  private readonly RESPONSIVE_PARAMS: Record<ScreenSizeType, Partial<ParticleData>> = {
    // Symbol min/max now unified; actual on-screen size is scaled by viewport height for consistency across resolutions.
    mobile: { amount: 2000, particleSize: 1.0, textSize: 12, minSymbolSize: 7, maxSymbolSize: 12, area: 150 },
    tablet: { amount: 2200, particleSize: 1.1, textSize: 14, minSymbolSize: 7, maxSymbolSize: 12, area: 200 },
    laptop: { amount: 2200, particleSize: 1.5, textSize: 15, minSymbolSize: 7, maxSymbolSize: 12, area: 230 },
    desktop: { amount: 2400, particleSize: 1.68, textSize: 16, minSymbolSize: 7, maxSymbolSize: 10, area: 250 },
    large: { amount: 2700, particleSize: 1.55, textSize: 18, minSymbolSize: 7, maxSymbolSize: 12, area: 280 },
    ultrawide: { amount: 2900, particleSize: 1.6, textSize: 20, minSymbolSize: 8, maxSymbolSize: 140, area: 300 }
  };
  private readonly SYMBOL_SIZE_MODIFIERS: Record<ScreenSizeType, { minMul: number; maxMul: number }> = {
    mobile: { minMul: 0.95, maxMul: 0.95 },
    tablet: { minMul: 1.0, maxMul: 1.0 },
    laptop: { minMul: 1.0, maxMul: 1.0 },
    desktop: { minMul: 0.9,maxMul: 0.9},
    large: { minMul: 1.07, maxMul: 1.08 },
    ultrawide: { minMul: 13, maxMul: 19 }
  };

  private symbolTextureRows: number = 6;
  // Global hard override multiplier (debug) applied after all other scaling (min/max, modifiers, text scale)
  private globalSymbolSizeMul: number = 1.0;
  // Instrumentation for debugging size issues
  private lastSpawnComputedSize: number = 0; // final size written to attribute on last spawn
  private lastSpawnRawRandom: number = 0;    // randomSymbolSize before global multiplier
  private lastSpawnSymbolScale: number = 0;  // symbolScale at spawn
  private lastSpawnScreenType: ScreenSizeType = 'desktop';
  // Per-screen additional ratio to gently scale symbols on higher resolutions
  private readonly SCREEN_SYMBOL_RATIO: Record<ScreenSizeType, number> = {
    mobile: 1.0,
    tablet: 1.0,
    laptop: 1.0,
    desktop: 1.0,
    large: 1.03,
    ultrawide: 1.12
  };
  private pointSizeMax: number | null = null; // GPU max point size (caps gl_PointSize)

  constructor(scene: THREE.Scene, font: Font, particleImg: THREE.Texture, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, hostContainer: HTMLElement) {
    this.scene = scene;
    this.font = font;
    this.particleImg = particleImg;
    this.camera = camera;
    this.renderer = renderer; 
    this.hostContainer = hostContainer;
    this.isPressed = false;

    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2(1e5, 1e5);

    this.matrixSymbols = [ 
      '日', '〇', 'ﾊ', 'ﾐ', 'ﾋ', 'ｰ', 'ｳ', 'ｼ', 'ﾅ', 'ﾓ', 'ﾆ', 'ｻ', 'ﾜ',
      'ﾂ', 'ｵ', 'ﾘ', 'ｱ', 'ﾎ', 'ﾃ', 'ﾏ', 'ｹ', 'ﾒ', 'ｴ', 'ｶ', 'ｷ', 'ﾑ', 
      'ﾕ', 'ﾗ', 'ｾ', 'ﾈ', 'ｦ', 'ｲ', 'ｸ', 'ｺ', 'ｿ', 'ﾀ', 'ﾁ', 'ﾄ', 'ﾉ', 'ﾌ', 'ﾍ', 'ﾏ', 'ﾔ', 'ﾖ', 'ﾙ', 'ﾚ', 'ﾛ',
      '∆','δ', 'ε', 'ζ', 'η', 'θ', '∃', '∄','∅','ﾊ', 'ﾍ', 'ﾎ', 'ﾞ', 'ﾟ', 'ｧ', 'ｨ', 'ｩ', 'ｪ', 'ｫ', 'ｬ', 'ｭ', 'ｮ', 'ｯ','Д'
    ];
    
    this.matrixColors = {
      white: new THREE.Color(1.0, 1.0, 1.0),
      verySubtleGreenTint: new THREE.Color(0.9, 1.0, 0.9), 
      almostWhiteGreen: new THREE.Color(0.8, 1.0, 0.8),
      paleGreen: new THREE.Color(0.58, 1.0, 0.58),
      lightMatrixGreen: new THREE.Color(0.3, 1.0, 0.3),
      classicMatrixGreen: new THREE.Color(0.0, 1.0, 0.0),
      deepMatrixGreen: new THREE.Color(0.0, 0.85, 0.0)
    };

    this.bloomSymbolColor = new THREE.Color(0.0, 0.95, 0.05); 

    this.data = { 
      text: "Hi, I'm\nMiká",
      amount: 2700,
      particleSize: 1.5,
      textSize: 16,
      area: 250, 
      ease: .05, 
      distortionThreshold: 12,
      minFadeOutRate: 0.09,
      maxFadeOutRate: 0.12,
      minSymbolSize: 7,
      maxSymbolSize: 12,
      symbolMinThreshold: 13,
      symbolMidThreshold: 20,
      symbolMaxThreshold: 40,
      symbolMinProb: 0.001,
      symbolMaxProb: 0.15,
      symbolHeatRequirement: 0.4,
      particleCooldownDurationMin: 200, 
      particleCooldownDurationMax: 340,
      symbolCooldownSpeedMultiplier: 3.1,
    };
    
    this.lastKnownWidth = this.hostContainer.clientWidth;
    this.lastKnownHeight = this.hostContainer.clientHeight;
    
    this.currentScreenSizeType = this.getScreenSizeType();
    this.applyResponsiveParameters(this.currentScreenSizeType);
    
    this.boundOnMouseDown = this.onMouseDown.bind(this);
    this.boundOnMouseMove = this.onMouseMove.bind(this);
    this.boundOnMouseUp = this.onMouseUp.bind(this);
    this.boundOnTouchStart = this.onTouchStart.bind(this);
    this.boundOnTouchMove = this.onTouchMove.bind(this);
    this.boundOnTouchEnd = this.onTouchEnd.bind(this);
    
    this.createMatrixSymbolsTexture();
    this.setupPlaneArea();
    this.createText();

    // Query GPU point size cap (helps explain lack of visual change when exceeding)
    try {
      const gl = this.renderer.getContext();
      const range = gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE);
      if (Array.isArray(range) || (range && range.length === 2)) {
        this.pointSizeMax = range[1];
        // console.log('GPU point size range', range); // optional dev log
      }
    } catch {}
  }

  // --- Public debug helpers ---
  public setGlobalSymbolSizeMultiplier(m: number) {
    this.globalSymbolSizeMul = Math.max(0.01, m);
    // Rescale currently active symbols immediately
    this.updateSymbolSizesForTextScale();
  }
  public setScreenSymbolRatio(screen: ScreenSizeType, ratio: number) {
    if (ratio > 0 && screen in this.SCREEN_SYMBOL_RATIO) {
      this.SCREEN_SYMBOL_RATIO[screen] = ratio;
      this.updateSymbolSizesForTextScale();
    }
  }
  public getSymbolDebugInfo() {
    return {
      globalMul: this.globalSymbolSizeMul,
      lastSpawnComputedSize: this.lastSpawnComputedSize,
      lastSpawnRawRandom: this.lastSpawnRawRandom,
      lastSpawnSymbolScale: this.lastSpawnSymbolScale,
      screenType: this.lastSpawnScreenType,
      minSymbolSize: this.data.minSymbolSize,
      maxSymbolSize: this.data.maxSymbolSize,
      modifiers: this.SYMBOL_SIZE_MODIFIERS[this.currentScreenSizeType],
      screenRatio: this.SCREEN_SYMBOL_RATIO[this.currentScreenSizeType],
      gpuPointSizeMax: this.pointSizeMax
    };
  }

  private getMatrixColor(heatLevel: number): THREE.Color {
    if (heatLevel <= 0.05) return this.matrixColors.white;                
    if (heatLevel <= 0.18) return this.matrixColors.verySubtleGreenTint; 
    if (heatLevel <= 0.35) return this.matrixColors.almostWhiteGreen;     
    if (heatLevel <= 0.55) return this.matrixColors.paleGreen;            
    if (heatLevel <= 0.75) return this.matrixColors.lightMatrixGreen;
    if (heatLevel <= 0.92) return this.matrixColors.classicMatrixGreen;   
    return this.matrixColors.deepMatrixGreen;                             
  }

  private getSymbolProbability(distortion: number): number {
    const { symbolMinThreshold, symbolMidThreshold, symbolMaxThreshold, symbolMinProb, symbolMaxProb } = this.data;
    if (distortion < symbolMinThreshold) return 0;
    if (distortion >= symbolMaxThreshold) return symbolMaxProb; 
    if (distortion < symbolMidThreshold) {
      const ratio = (distortion - symbolMinThreshold) / (symbolMidThreshold - symbolMinThreshold);
      return symbolMinProb + (symbolMaxProb / 10) * Math.pow(ratio, 3);
    } else {
      const ratio = (distortion - symbolMidThreshold) / (symbolMaxThreshold - symbolMidThreshold);
      return (symbolMaxProb / 10) + 
             (symbolMaxProb - symbolMaxProb / 10) * Math.pow(ratio, 1.5);
    }
  }

  // Symbol scale anchored to initial text height so symbols keep consistent proportion relative to text across devices.
  private getSymbolScale(): number {
    if (this.referenceTextHeight && this.textBoundingHeight && this.textBoundingHeight > 0) {
      const raw = this.referenceTextHeight / this.textBoundingHeight; // if text got larger, scale symbols up proportionally
  // Optionally: blend with a viewport factor if reintroducing hybrid behavior in future.
      // Clamp to avoid extreme jumps when fonts/rendering differ slightly.
      return Math.min(1.6, Math.max(0.65, raw));
    }
    // Fallback: no text metrics yet, neutral scale
    return 1.0;
  }

  // Recalculate current symbol point sizes so that active symbols maintain consistent proportion to text after resize.
  public updateSymbolSizesForTextScale(): void {
    if (!this.particles) return;
    const geo = this.particles.geometry as THREE.BufferGeometry;
    const sizes = geo.getAttribute('size') as THREE.BufferAttribute;
    const symbolStates = geo.getAttribute('symbolState') as THREE.BufferAttribute;
    const sizeArr = sizes.array as Float32Array;
    const stateArr = symbolStates.array as Float32Array;
    const count = sizes.count;
    const symbolScale = this.getSymbolScale();
    const baseSize = this.data.particleSize;
    const ratio = this.SCREEN_SYMBOL_RATIO[this.currentScreenSizeType] ?? 1.0;
    for (let i = 0; i < count; i++) {
      if (stateArr[i] === 1) {
        const factor = this.activeSymbolFactors[i];
        if (factor > 0) {
          sizeArr[i] = baseSize * factor * symbolScale * ratio * this.globalSymbolSizeMul;
        }
      }
    }
    sizes.needsUpdate = true;
  }

  // Backwards compatibility alias (can remove once all call sites updated)
  public updateSymbolSizesForViewport(): void {
    this.updateSymbolSizesForTextScale();
  }

  private initParticleStates(count: number) { 
    this.particleStates = new Array(count).fill(0);
    this.heatLevels = new Array(count).fill(0);
  this.cooldownRates = new Array(count); // will become per-second decay rates
    this.symbolIndicesAttributeValues = new Array(count);
    this.fadeOutRates = new Array(count);
  this.fadeOutRatesPerSec = new Array(count);
  this.cooldownDurationsSec = new Array(count);
   this.activeSymbolFactors = new Array(count).fill(0);
    // initialize color transition state
    this.colorProgress = new Array(count).fill(0);
    this.influenceEMA = new Array(count).fill(0);
  this.whiteCooldownFrames = new Array(count).fill(0);
  this.whiteCooldownTimeSec = new Array(count).fill(0);
    this.riseRateMul = new Array(count);
    this.fallRateMul = new Array(count);
    
    for (let i = 0; i < count; i++) {
      this.symbolIndicesAttributeValues[i] = Math.floor(Math.random() * this.matrixSymbols.length);
      
  const randomDurationFrames = this.data.particleCooldownDurationMin + 
             Math.random() * (this.data.particleCooldownDurationMax - this.data.particleCooldownDurationMin);
  // Convert to seconds baseline at REF_FPS
  const randomDurationSec = randomDurationFrames / REF_FPS;
  this.cooldownDurationsSec[i] = randomDurationSec;
  this.cooldownRates[i] = 1 / randomDurationSec; // per-second heat decay rate
  const fadePerFrame = this.data.minFadeOutRate + Math.random() * (this.data.maxFadeOutRate - this.data.minFadeOutRate);
  this.fadeOutRates[i] = fadePerFrame; // legacy storage (optional)
  this.fadeOutRatesPerSec[i] = fadePerFrame * REF_FPS; // per-second size reduction
      // per-particle jitter multipliers
      const jr = (Math.random() * 2 - 1) * this.colorParams.jitterRise;
      const jf = (Math.random() * 2 - 1) * this.colorParams.jitterFall;
      this.riseRateMul[i] = 1 + jr;
      this.fallRateMul[i] = 1 + jf;
    }
  }

  private createMatrixSymbolsTexture() {
    const cols = 8;
    const symbolSize = 64;
    const rows = Math.ceil(this.matrixSymbols.length / cols);
    
    const canvas = document.createElement('canvas');
    canvas.width = cols * symbolSize; 
    canvas.height = rows * symbolSize;
    const ctx = canvas.getContext('2d')!;
    
    ctx.fillStyle = 'rgba(0,0,0,0)'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.font = 'bold 48px "Courier New", monospace';
    ctx.textAlign = 'center'; 
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#00FF00';
    
    if (ctx.imageSmoothingEnabled !== undefined) {
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
    }
    
    for (let i = 0; i < this.matrixSymbols.length; i++) {
      const col = i % cols; 
      const row = Math.floor(i / cols);
      const x = col * symbolSize + symbolSize / 2; 
      const y = row * symbolSize + symbolSize / 2;
      
      const symbol = this.matrixSymbols[i];
      ctx.fillText(symbol, x, y);
    }
    
    this.symbolsTexture = new THREE.Texture(canvas);
    this.symbolsTexture.needsUpdate = true;
    this.symbolsTexture.generateMipmaps = false;
    this.symbolsTexture.minFilter = THREE.LinearFilter;
    this.symbolsTexture.magFilter = THREE.LinearFilter;
    this.symbolsTexture.wrapS = THREE.ClampToEdgeWrapping;
    this.symbolsTexture.wrapT = THREE.ClampToEdgeWrapping;
    
    this.symbolTextureRows = rows;
  }

  private setupPlaneArea() {
    const planeZ = 0;
    const planeWidth = this.visibleWidthAtZDepth(planeZ, this.camera);
    const planeHeight = this.visibleHeightAtZDepth(planeZ, this.camera);

    const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
    const material = new THREE.MeshBasicMaterial({ 
        transparent: true, 
        opacity: 0, 
        depthWrite: false 
    });
    this.planeArea = new THREE.Mesh(geometry, material);
    this.planeArea.position.z = planeZ;
    this.planeArea.visible = true;
    this.scene.add(this.planeArea);
  }

  private createText() {
    const thePoints: THREE.Vector3[] = [];
    const colorsArr: number[] = []; 
    const sizesArr: number[] = []; 
    const symbolStatesArr: number[] = []; 
    const symbolIndicesArrForAttribute: number[] = []; 
    const variabilitiesArr: number[] = [];

    if (!this.font) { console.error("HeroParticleLogic: Font not available for createText"); return; }

    const mainShapes = this.font.generateShapes(this.data.text, this.data.textSize);
    const allPaths: THREE.Path[] = [];
    mainShapes.forEach(shape => {
        allPaths.push(shape); 
        if (shape.holes && shape.holes.length > 0) {
            allPaths.push(...shape.holes); 
        }
    });
    
    const tempShapeGeometry = new THREE.ShapeGeometry(mainShapes); 
    tempShapeGeometry.computeBoundingBox();
    const bb = tempShapeGeometry.boundingBox!;
    const bboxWidth = bb.max.x - bb.min.x;
    const bboxHeight = bb.max.y - bb.min.y;
    // Center offset
    const xMid = -0.5 * bboxWidth;
    const yMid = bboxHeight / 2.85; 
    // Update text height tracking (world units)
    this.textBoundingHeight = bboxHeight;
    if (this.referenceTextHeight === null) {
      this.referenceTextHeight = bboxHeight; // anchor
    }
    tempShapeGeometry.dispose();

    let totalLength = 0;
    allPaths.forEach(path => totalLength += path.getLength());
    if (totalLength === 0) totalLength = 1; 

    const initialColor = this.matrixColors.white; 

    allPaths.forEach(path => {
      const pathLength = path.getLength();
      const numPointsForThisPath = Math.max(10, Math.floor((pathLength / totalLength) * this.data.amount));
      const points = path.getSpacedPoints(numPointsForThisPath);
      
      points.forEach(p => {
        thePoints.push(new THREE.Vector3(p.x, p.y, 0));
        colorsArr.push(initialColor.r, initialColor.g, initialColor.b); 
        sizesArr.push(this.data.particleSize);
        symbolStatesArr.push(0); 
        symbolIndicesArrForAttribute.push(Math.floor(Math.random() * this.matrixSymbols.length));
        variabilitiesArr.push(Math.random());
      });
    });
    
    const finalPointCount = thePoints.length;
    if (colorsArr.length / 3 !== finalPointCount) { colorsArr.length = finalPointCount * 3; for(let i=0; i<finalPointCount; ++i) colorsArr.splice(i*3, 3, initialColor.r, initialColor.g, initialColor.b); }
    if (sizesArr.length !== finalPointCount) { sizesArr.length = finalPointCount; sizesArr.fill(this.data.particleSize); }
    if (symbolStatesArr.length !== finalPointCount) { symbolStatesArr.length = finalPointCount; symbolStatesArr.fill(0); }
    if (symbolIndicesArrForAttribute.length !== finalPointCount) { symbolIndicesArrForAttribute.length = finalPointCount; for(let i=0; i<finalPointCount; ++i) symbolIndicesArrForAttribute[i] = Math.floor(Math.random() * this.matrixSymbols.length); }
    if (variabilitiesArr.length !== finalPointCount) { variabilitiesArr.length = finalPointCount; for(let i=0; i<finalPointCount; ++i) variabilitiesArr[i] = Math.random(); }


    const geoParticles = new THREE.BufferGeometry().setFromPoints(thePoints);
    geoParticles.translate(xMid, yMid, 0); 
    geoParticles.setAttribute('customColor', new THREE.Float32BufferAttribute(colorsArr, 3));
    geoParticles.setAttribute('size', new THREE.Float32BufferAttribute(sizesArr, 1));
    geoParticles.setAttribute('symbolState', new THREE.Float32BufferAttribute(symbolStatesArr, 1));
    geoParticles.setAttribute('symbolIndex', new THREE.Float32BufferAttribute(symbolIndicesArrForAttribute, 1));
    geoParticles.setAttribute('variability', new THREE.Float32BufferAttribute(variabilitiesArr, 1));

    const particleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        pointTexture: { value: this.particleImg },
        symbolsTexture: { value: this.symbolsTexture },
        symbolRows: { value: this.symbolTextureRows }
      },
      vertexShader: VERTEX_SHADER,
      fragmentShader: FRAGMENT_SHADER,
      blending: THREE.NormalBlending, 
      depthTest: false, 
      transparent: true, 
    });

    this.particles = new THREE.Points(geoParticles, particleMaterial);
    this.scene.add(this.particles);
    this.geometryCopy = new THREE.BufferGeometry().copy(this.particles.geometry);
    this.initParticleStates(thePoints.length);
   }

  public bindInteractionEvents() {
    this.hostContainer.addEventListener('mousedown', this.boundOnMouseDown);
    this.hostContainer.addEventListener('mousemove', this.boundOnMouseMove);
    document.addEventListener('mouseup', this.boundOnMouseUp); 

    this.hostContainer.addEventListener('touchstart', this.boundOnTouchStart, { passive: false });
    this.hostContainer.addEventListener('touchmove', this.boundOnTouchMove, { passive: false });
    this.hostContainer.addEventListener('touchend', this.boundOnTouchEnd, { passive: false });
    this.isPressed = false;
  }

  public unbindInteractionEvents() {
    this.hostContainer.removeEventListener('mousedown', this.boundOnMouseDown);
    this.hostContainer.removeEventListener('mousemove', this.boundOnMouseMove);
    document.removeEventListener('mouseup', this.boundOnMouseUp);

    this.hostContainer.removeEventListener('touchstart', this.boundOnTouchStart);
    this.hostContainer.removeEventListener('touchmove', this.boundOnTouchMove);
    this.hostContainer.removeEventListener('touchend', this.boundOnTouchEnd);
    
    this.neutralizeLastMousePosition();
  }

  public neutralizeLastMousePosition() {
    this.mouse.set(1e5, 1e5); 
    this.hasMouseMoved = false; 
    this.isPressed = false; 
    this.interactionActivated = false;
    this.cumulativeMoveDistance = 0;
    this.lastPointerClientX = null;
    this.lastPointerClientY = null;
  }

  private onMouseDown(event: MouseEvent) {
    this.updateMousePosition(event.clientX, event.clientY);
    this.isPressed = true;
    this.data.ease = .01;
    this.interactionActivated = true;
    this.lastPointerClientX = event.clientX;
    this.lastPointerClientY = event.clientY;
  }
  private onMouseUp() { this.isPressed = false; this.data.ease = .05; }
  private onMouseMove(event: MouseEvent) {
    const cx = event.clientX, cy = event.clientY;
    if (!this.hasMouseMoved) this.hasMouseMoved = true;
    if (this.lastPointerClientX !== null && this.lastPointerClientY !== null) {
      const dx = cx - this.lastPointerClientX; const dy = cy - this.lastPointerClientY;
      this.cumulativeMoveDistance += Math.hypot(dx, dy);
      if (!this.interactionActivated && this.cumulativeMoveDistance >= this.activationMoveThreshold) {
        this.interactionActivated = true;
      }
    }
    this.lastPointerClientX = cx; this.lastPointerClientY = cy;
    this.updateMousePosition(cx, cy);
  }
  private onTouchStart(event: TouchEvent) {
    if (event.touches.length > 0) {
      const cx = event.touches[0].clientX, cy = event.touches[0].clientY;
      this.updateMousePosition(cx, cy);
      this.isPressed = true; this.data.ease = .01; this.hasMouseMoved = true;
      this.interactionActivated = true;
      this.lastPointerClientX = cx; this.lastPointerClientY = cy;
    }
    event.preventDefault();
  }
  private onTouchMove(event: TouchEvent) {
    if (event.touches.length > 0) {
      const cx = event.touches[0].clientX, cy = event.touches[0].clientY;
      this.hasMouseMoved = true;
      if (this.lastPointerClientX !== null && this.lastPointerClientY !== null) {
        const dx = cx - this.lastPointerClientX; const dy = cy - this.lastPointerClientY;
        this.cumulativeMoveDistance += Math.hypot(dx, dy);
        if (!this.interactionActivated && this.cumulativeMoveDistance >= this.activationMoveThreshold) {
          this.interactionActivated = true;
        }
      }
      this.lastPointerClientX = cx; this.lastPointerClientY = cy;
      this.updateMousePosition(cx, cy);
    }
    event.preventDefault();
  }
  private onTouchEnd(event: TouchEvent) { this.isPressed = false; this.data.ease = .05; event.preventDefault(); }
  
  private updateMousePosition(clientX: number, clientY: number) {
    const rect = this.hostContainer.getBoundingClientRect();
    this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
  }

  private getVariedSymbolColor(): THREE.Color {
    const variedColor = this.bloomSymbolColor.clone();
    const hsl = { h: 0, s: 0, l: 0 };
    variedColor.getHSL(hsl); 

    const hueOffset = (Math.random() - 0.5) * this.SYMBOL_HUE_SHIFT_RANGE;
    hsl.h += hueOffset;
    hsl.h = (hsl.h + 1.0) % 1.0; 

    const luminanceReduction = Math.random() * this.SYMBOL_LUMINANCE_REDUCTION_MAX;
    hsl.l -= luminanceReduction;
    
    hsl.l = Math.max(this.SYMBOL_MIN_LUMINANCE_TARGET, hsl.l);
    hsl.l = Math.min(1.0, hsl.l);

    variedColor.setHSL(hsl.h, hsl.s, hsl.l); 
    return variedColor;
  }

  public render(deltaTime?: number, effectSpeed: number = 1.0) {
    if (!this.particles || !this.planeArea || !this.camera) return; 

    const dt = Math.max(0.00001, deltaTime ?? 1/60);
    const clamp01 = (x: number) => x < 0 ? 0 : (x > 1 ? 1 : x);
    // reset per-frame counters
    this.activeSymbolsCount = 0;
    

    // recompute exponential return constant if ease changed
    if (this.lastEaseFrameValue !== this.data.ease) {
      const ef = Math.min(Math.max(this.data.ease, 0), 0.9999);
      this.kReturn = -REF_FPS * Math.log(1 - ef);
      this.lastEaseFrameValue = this.data.ease;
    }

    const decayFromDt = (t: number) => Math.exp(-this.kReturn * t * effectSpeed);

    // cache attributes & typed arrays
    const geo = this.particles.geometry as THREE.BufferGeometry;
    const pos = geo.attributes.position as THREE.BufferAttribute;
    const colors = geo.attributes.customColor as THREE.BufferAttribute;
    const sizes = geo.attributes.size as THREE.BufferAttribute;
    const symbolStates = geo.attributes.symbolState as THREE.BufferAttribute;
    const symbolIndicesBuffer = geo.attributes.symbolIndex as THREE.BufferAttribute;

    const posArr = pos.array as Float32Array;
    const colArr = colors.array as Float32Array;
    const sizeArr = sizes.array as Float32Array;
    const stateArr = symbolStates.array as Float32Array;
    const indexArr = symbolIndicesBuffer.array as Float32Array;

    const count = pos.count;

    // target dot green derived from symbol color, slightly darkened
    const targetGreen = this.bloomSymbolColor.clone();
    const tgHSL = { h: 0, s: 0, l: 0 };
    targetGreen.getHSL(tgHSL);
    tgHSL.l = Math.max(0, tgHSL.l - this.colorParams.finalDotGreenDarken);
    targetGreen.setHSL(tgHSL.h, tgHSL.s, tgHSL.l);
    const tgR = targetGreen.r, tgG = targetGreen.g, tgB = targetGreen.b;

  if ((!this.hasMouseMoved && !this.isPressed) || !this.interactionActivated) {
      const copyPos = this.geometryCopy.attributes.position as THREE.BufferAttribute;
      const copyArr = copyPos.array as Float32Array;
      let changed = false;
      let colorChanged = false;
      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const initX = copyArr[i3], initY = copyArr[i3+1], initZ = copyArr[i3+2];
        const px = posArr[i3], py = posArr[i3+1], pz = posArr[i3+2];
  const decay = decayFromDt(dt);
  let npx = initX + (px - initX) * decay;
  let npy = initY + (py - initY) * decay;
  let npz = initZ + (pz - initZ) * decay;
        if (npx !== px || npy !== py || npz !== pz) {
          posArr[i3] = npx; posArr[i3+1] = npy; posArr[i3+2] = npz; changed = true;
        }
        // Color decay when idle or before activation
        if (this.particleStates[i] === 0) {
          let prog = this.colorProgress[i];
          if (this.whiteCooldownTimeSec[i] > 0) {
            this.whiteCooldownTimeSec[i] -= dt * effectSpeed;
            prog = Math.max(0.05, prog - this.colorParams.fallLerpPerSec * this.fallRateMul[i] * dt);
          } else {
            prog = Math.max(0, prog - this.colorParams.fallLerpPerSec * this.fallRateMul[i] * dt);
          }
          prog = clamp01(prog);
          this.colorProgress[i] = prog;
          const t = Math.pow(prog, this.colorParams.curveShape);
          const r = 1 + (tgR - 1) * t;
          const g = 1 + (tgG - 1) * t;
          const b = 1 + (tgB - 1) * t;
          const ci3 = i3;
          if (colArr[ci3] !== r || colArr[ci3+1] !== g || colArr[ci3+2] !== b) {
            colArr[ci3] = r; colArr[ci3+1] = g; colArr[ci3+2] = b; colorChanged = true;
          }
        }
      }
      if (changed) pos.needsUpdate = true;
      if (colorChanged) colors.needsUpdate = true;
      return;
    }

    // direct plane intersection instead of three Raycaster object allocation
    const rect = this.hostContainer.getBoundingClientRect();
    const ndcX = this.mouse.x; // already in NDC from updateMousePosition
    const ndcY = this.mouse.y;
    const origin = new THREE.Vector3();
    const dir = new THREE.Vector3();
    const ray = new THREE.Ray();
    origin.setFromMatrixPosition(this.camera.matrixWorld);
    dir.set(ndcX, ndcY, 0.5).unproject(this.camera).sub(origin).normalize();
    ray.set(origin, dir);
    const plane = new THREE.Plane(new THREE.Vector3(0,0,1), -this.planeArea.position.z);
    const hitPoint = new THREE.Vector3();
    const hasHit = ray.intersectPlane(plane, hitPoint) !== null;

  let attributesNeedUpdate = false;
  let colorsNeedUpdate = false;

    if (hasHit) {
      const mx = hitPoint.x;
      const my = hitPoint.y;

      const copyPos = this.geometryCopy.attributes.position as THREE.BufferAttribute;
      const copyArr = copyPos.array as Float32Array;

      const pressed = this.isPressed;
      const area = this.data.area;
      const baseSize = this.data.particleSize;

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const initX = copyArr[i3], initY = copyArr[i3+1], initZ = copyArr[i3+2];
        let px = posArr[i3], py = posArr[i3+1], pz = posArr[i3+2];

        const dx = mx - px; const dy = my - py;
        const mouseDistance = Math.hypot(dx, dy);
        const d2 = Math.max(1e-5, dx*dx + dy*dy);
  const f = -area / d2;
  // time-normalized scaling so displacement accumulates consistently across FPS
  const timeScale = dt * REF_FPS * effectSpeed; // REF_FPS keeps original tuning feel
        // color influence will be based on actual distortion from rest position

        if (pressed) {
          const t = Math.atan2(dy, dx);
          px -= f * Math.cos(t) * timeScale; py -= f * Math.sin(t) * timeScale;
          // Heat gain originally 0.1 per frame => 0.1 * REF_FPS per second
          const heatGainPerSec = 0.1 * REF_FPS;
          this.heatLevels[i] = Math.min(this.heatLevels[i] + heatGainPerSec * dt * effectSpeed, 1.0);
          attributesNeedUpdate = true;
        } else if (mouseDistance < area) {
          const t = Math.atan2(dy, dx);
          px += f * Math.cos(t) * timeScale; py += f * Math.sin(t) * timeScale;
          attributesNeedUpdate = true;
          const distortion = Math.hypot(px - initX, py - initY);
          if (distortion > this.data.distortionThreshold) {
            const perFrameAdd = Math.min(distortion / 50, 0.1);
            const perSecAdd = perFrameAdd * REF_FPS;
            this.heatLevels[i] = Math.min(this.heatLevels[i] + perSecAdd * dt * effectSpeed, 1.0);
            if (this.particleStates[i] === 0 && this.heatLevels[i] > this.data.symbolHeatRequirement) {
              // Convert original per-frame probability into per-second lambda approximation
              const pFrame = this.getSymbolProbability(distortion); // tuned for ~REF_FPS
              // For small probabilities: lambda ≈ pFrame * REF_FPS
              const lambdaPerSec = -Math.log(Math.max(1e-6, 1 - pFrame)) * REF_FPS; // stable even if pFrame larger
              const pThisFrame = 1 - Math.exp(-lambdaPerSec * dt * effectSpeed);
              if (Math.random() < pThisFrame) {
                this.particleStates[i] = 1;
                stateArr[i] = 1.0;
                const symbolScale = this.getSymbolScale();
                const mods = this.SYMBOL_SIZE_MODIFIERS[this.currentScreenSizeType];
                const minAdj = this.data.minSymbolSize * mods.minMul;
                const maxAdj = this.data.maxSymbolSize * mods.maxMul;
                const randomSymbolSize = minAdj + Math.random() * (maxAdj - minAdj);
                const randomSymbolIndex = Math.floor(Math.random() * this.matrixSymbols.length);
                // Apply text-anchored scaling so symbols maintain proportion to text PLUS global debug multiplier.
                const ratio = this.SCREEN_SYMBOL_RATIO[this.currentScreenSizeType] ?? 1.0;
                const finalSize = baseSize * randomSymbolSize * symbolScale * ratio * this.globalSymbolSizeMul;
                sizeArr[i] = finalSize;
                // Debug instrumentation capture
                this.lastSpawnComputedSize = finalSize;
                this.lastSpawnRawRandom = randomSymbolSize;
                this.lastSpawnSymbolScale = symbolScale;
                this.lastSpawnScreenType = this.currentScreenSizeType;
                this.activeSymbolFactors[i] = randomSymbolSize;
                indexArr[i] = randomSymbolIndex;
                const c = this.getVariedSymbolColor();
                const ci3 = i3;
                colArr[ci3] = c.r; colArr[ci3+1] = c.g; colArr[ci3+2] = c.b;
                colorsNeedUpdate = true; attributesNeedUpdate = true;
                // metrics: count spawn
                this.symbolsSpawnedInWindow++;
              }
            }
          }
        }

        if (this.particleStates[i] === 1) {
          this.activeSymbolsCount++;
          const currentSize = sizeArr[i];
          const newSize = Math.max(baseSize, currentSize - this.fadeOutRatesPerSec[i] * dt * effectSpeed);
          if (currentSize !== newSize) { sizeArr[i] = newSize; attributesNeedUpdate = true; }
          // heat decay while symbol active
          this.heatLevels[i] = Math.max(0, this.heatLevels[i] - (this.cooldownRates[i] * this.data.symbolCooldownSpeedMultiplier) * dt * effectSpeed);
          const fadeThreshold = baseSize + 0.01;
          if (newSize <= fadeThreshold) {
            this.particleStates[i] = 0;
            stateArr[i] = 0.0;
            sizeArr[i] = baseSize;
            this.activeSymbolFactors[i] = 0;
            this.activeSymbolFactors[i] = 0;
            attributesNeedUpdate = true;
          }
        } else {
          // Distortion-driven color: map distance from rest to target greenness [0..1]
          const d = Math.hypot(px - initX, py - initY);
          let target = clamp01((d - this.colorParams.colorMinDistort) / Math.max(1e-6, (this.colorParams.colorMaxDistort - this.colorParams.colorMinDistort)));
          if (pressed) target = clamp01(target * 1.1);
          let prog = this.colorProgress[i];
          const increasing = target > prog;
          const rate = (increasing ? this.colorParams.riseLerpPerSec * this.riseRateMul[i]
                                   : this.colorParams.fallLerpPerSec * this.fallRateMul[i]);
          const step = Math.min(Math.abs(target - prog), rate * dt);
          prog += Math.sign(target - prog) * step;
          if (increasing) {
            this.whiteCooldownTimeSec[i] = Math.max(this.whiteCooldownTimeSec[i], this.colorParams.minTimeToWhite);
          } else if (target <= 0 && this.whiteCooldownTimeSec[i] > 0) {
            prog = Math.max(0.05, prog);
            this.whiteCooldownTimeSec[i] -= dt * effectSpeed;
          }
          prog = clamp01(prog);
          this.colorProgress[i] = prog;
          const t = Math.pow(prog, this.colorParams.curveShape);
          const r = 1 + (tgR - 1) * t;
          const g = 1 + (tgG - 1) * t;
          const b = 1 + (tgB - 1) * t;
          const ci3 = i3;
          if (colArr[ci3] !== r || colArr[ci3+1] !== g || colArr[ci3+2] !== b) {
            colArr[ci3] = r; colArr[ci3+1] = g; colArr[ci3+2] = b; colorsNeedUpdate = true;
          }
        }

        if (this.heatLevels[i] > 0 && this.particleStates[i] === 0) {
          this.heatLevels[i] = Math.max(0, this.heatLevels[i] - this.cooldownRates[i] * dt * effectSpeed);
        }

        const prevPx = px, prevPy = py, prevPz = pz;
  const decayFollow = decayFromDt(dt);
  px = initX + (px - initX) * decayFollow;
  py = initY + (py - initY) * decayFollow;
  pz = initZ + (pz - initZ) * decayFollow;
        if (px !== prevPx || py !== prevPy || pz !== prevPz) {
          posArr[i3] = px; posArr[i3+1] = py; posArr[i3+2] = pz; attributesNeedUpdate = true;
        }
      }
    } else {
      const copyPos = this.geometryCopy.attributes.position as THREE.BufferAttribute;
      const copyArr = copyPos.array as Float32Array;
      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const initX = copyArr[i3], initY = copyArr[i3+1], initZ = copyArr[i3+2];
        const px = posArr[i3], py = posArr[i3+1], pz = posArr[i3+2];
  const decay = decayFromDt(dt);
  const npx = initX + (px - initX) * decay;
  const npy = initY + (py - initY) * decay;
  const npz = initZ + (pz - initZ) * decay;
        if (npx !== px || npy !== py || npz !== pz) {
          posArr[i3] = npx; posArr[i3+1] = npy; posArr[i3+2] = npz; attributesNeedUpdate = true;
        }
        // No hit: derive color from current distortion and decay
        if (this.particleStates[i] === 0) {
          const d = Math.hypot(px - initX, py - initY);
          let target = clamp01((d - this.colorParams.colorMinDistort) / Math.max(1e-6, (this.colorParams.colorMaxDistort - this.colorParams.colorMinDistort)));
          let prog = this.colorProgress[i];
          const increasing = target > prog;
          const rate = (increasing ? this.colorParams.riseLerpPerSec * this.riseRateMul[i]
                                   : this.colorParams.fallLerpPerSec * this.fallRateMul[i]);
          const step = Math.min(Math.abs(target - prog), rate * dt);
          prog += Math.sign(target - prog) * step;
          if (increasing) {
            this.whiteCooldownTimeSec[i] = Math.max(this.whiteCooldownTimeSec[i], this.colorParams.minTimeToWhite);
          } else if (target <= 0 && this.whiteCooldownTimeSec[i] > 0) {
            prog = Math.max(0.05, prog);
            this.whiteCooldownTimeSec[i] -= dt * effectSpeed;
          }
          prog = clamp01(prog);
          this.colorProgress[i] = prog;
          const t = Math.pow(prog, this.colorParams.curveShape);
          const r = 1 + (tgR - 1) * t;
          const g = 1 + (tgG - 1) * t;
          const b = 1 + (tgB - 1) * t;
          const ci3 = i3;
          if (colArr[ci3] !== r || colArr[ci3+1] !== g || colArr[ci3+2] !== b) {
            colArr[ci3] = r; colArr[ci3+1] = g; colArr[ci3+2] = b; colorsNeedUpdate = true;
          }
        }
      }
    }

    if (attributesNeedUpdate) {
      pos.needsUpdate = true;
      colors.needsUpdate = true;
      sizes.needsUpdate = true;
      symbolStates.needsUpdate = true;
      symbolIndicesBuffer.needsUpdate = true;
    }
    if (!attributesNeedUpdate && colorsNeedUpdate) {
      colors.needsUpdate = true;
    }

    // Update spawn rate window
    this.spawnWindowTime += dt;
    if (this.spawnWindowTime >= this.SPAWN_RATE_WINDOW_SEC) {
      this.symbolSpawnRate = this.symbolsSpawnedInWindow / this.spawnWindowTime; // average over window
      this.spawnWindowTime = 0;
      this.symbolsSpawnedInWindow = 0;
    }
  }
  
  public resetParticleState() {
    if (!this.particles || !this.particles.geometry) return;
    const geo = this.particles.geometry as THREE.BufferGeometry;
    const colors = geo.attributes.customColor as THREE.BufferAttribute;
    const sizes = geo.attributes.size as THREE.BufferAttribute;
    const symbolStates = geo.attributes.symbolState as THREE.BufferAttribute;
    const symbolIndicesBuffer = geo.attributes.symbolIndex as THREE.BufferAttribute;
    const pos = geo.attributes.position as THREE.BufferAttribute;

    const count = pos.count;
    const baseColor = this.matrixColors.white;

    for (let i = 0; i < count; i++) {
      // reset state & heat
      this.particleStates[i] = 0;
      this.heatLevels[i] = 0;

      // reset geometry attributes
      symbolStates.setX(i, 0);
      sizes.setX(i, this.data.particleSize);
      const c = baseColor;
      colors.setXYZ(i, c.r, c.g, c.b);

      // randomize symbol index and per-particle rates
      const idx = Math.floor(Math.random() * this.matrixSymbols.length);
      this.symbolIndicesAttributeValues[i] = idx;
      symbolIndicesBuffer.setX(i, idx);

      const randomDuration = this.data.particleCooldownDurationMin +
        Math.random() * (this.data.particleCooldownDurationMax - this.data.particleCooldownDurationMin);
      this.cooldownRates[i] = 1 / Math.max(1, randomDuration);
      this.fadeOutRates[i] = this.data.minFadeOutRate + Math.random() * (this.data.maxFadeOutRate - this.data.minFadeOutRate);
    }

    colors.needsUpdate = true;
    sizes.needsUpdate = true;
    symbolStates.needsUpdate = true;
    symbolIndicesBuffer.needsUpdate = true;
  }

  private visibleHeightAtZDepth(depth: number, camera: THREE.PerspectiveCamera): number {
    const cameraOffset = camera.position.z;
    const relativeDepth = depth - cameraOffset; 
    const vFOV = camera.fov * Math.PI / 180; 
    return 2 * Math.tan(vFOV / 2) * Math.abs(relativeDepth);
  }
  private visibleWidthAtZDepth(depth: number, camera: THREE.PerspectiveCamera): number {
    return this.visibleHeightAtZDepth(depth, camera) * camera.aspect;
  }

  // Responsive design methods
  private getScreenSizeType(): ScreenSizeType {
    const width = this.hostContainer.clientWidth;
    
    if (width <= this.SCREEN_SIZES.mobile.maxWidth) {
      return 'mobile';
    } else if (width >= this.SCREEN_SIZES.tablet.minWidth && width <= this.SCREEN_SIZES.tablet.maxWidth) {
      return 'tablet';
    } else if (width >= this.SCREEN_SIZES.laptop.minWidth && width <= this.SCREEN_SIZES.laptop.maxWidth) {
      return 'laptop';
    } else if (width >= this.SCREEN_SIZES.desktop.minWidth && width <= this.SCREEN_SIZES.desktop.maxWidth) {
      return 'desktop';
    } else if (width >= this.SCREEN_SIZES.large.minWidth && width <= this.SCREEN_SIZES.large.maxWidth) {
      return 'large';
    } else {
      return 'ultrawide';
    }
  }
  private applyResponsiveParameters(screenType: ScreenSizeType): void {
    const params = this.RESPONSIVE_PARAMS[screenType];
    
    if (params.amount !== undefined) this.data.amount = params.amount;
    if (params.particleSize !== undefined) this.data.particleSize = params.particleSize;
    if (params.textSize !== undefined) this.data.textSize = params.textSize;
    if (params.minSymbolSize !== undefined) this.data.minSymbolSize = params.minSymbolSize;
    if (params.maxSymbolSize !== undefined) this.data.maxSymbolSize = params.maxSymbolSize;
    if (params.area !== undefined) this.data.area = params.area;
  }

  public checkScreenSizeChange(): boolean {
    const currentWidth = this.hostContainer.clientWidth;
    const currentHeight = this.hostContainer.clientHeight;
    
    const widthChange = Math.abs(currentWidth - this.lastKnownWidth);
    const heightChange = Math.abs(currentHeight - this.lastKnownHeight);
    const significantChange = widthChange > 100 || heightChange > 100 || 
                             widthChange / this.lastKnownWidth > 0.1 || 
                             heightChange / this.lastKnownHeight > 0.1;
    
    if (significantChange) {
      const newScreenType = this.getScreenSizeType();
      
      if (newScreenType !== this.currentScreenSizeType) {
        this.currentScreenSizeType = newScreenType;
        this.applyResponsiveParameters(newScreenType);
        this.lastKnownWidth = currentWidth;
        this.lastKnownHeight = currentHeight;
        this.needsParticleRegeneration = true;
        return true;
      }
    }
    
    return false;
  }

  public regenerateParticles(): void {
    if (!this.needsParticleRegeneration) return;
    
    if (this.particles) {
      this.scene.remove(this.particles);
      this.particles.geometry.dispose();
      const material = this.particles.material as THREE.Material | THREE.Material[];
      if (Array.isArray(material)) {
        material.forEach(m => m.dispose());
      } else {
        material.dispose();
      }
    }
    
    this.createText();
    
    this.needsParticleRegeneration = false;
  }
  
  public dispose() {
    this.unbindInteractionEvents();
    if (this.particles) {
      this.scene.remove(this.particles);
      this.particles.geometry.dispose();
      const material = this.particles.material as THREE.Material | THREE.Material[];
      if (Array.isArray(material)) {
        material.forEach(m => m.dispose());
      } else {
        material.dispose();
      }
    }
    if (this.geometryCopy) this.geometryCopy.dispose();
    if (this.symbolsTexture) this.symbolsTexture.dispose();
    if (this.planeArea) {
      this.scene.remove(this.planeArea);
      this.planeArea.geometry.dispose();
      const material = this.planeArea.material as THREE.Material | THREE.Material[];
      if (Array.isArray(material)) {
         material.forEach(m => m.dispose());
      } else {
        (material as THREE.Material).dispose();
      }
    }
  }

  public getAmount(): number { return this.data.amount; }
  public setAmount(amount: number): void { this.data.amount = Math.max(100, Math.floor(amount)); }
  public rebuildWithAmount(amount: number): void {
    this.setAmount(amount);
    if (this.particles) {
      this.scene.remove(this.particles);
      this.particles.geometry.dispose();
      const material = this.particles.material as THREE.Material | THREE.Material[];
      if (Array.isArray(material)) { material.forEach(m => m.dispose()); } else { material.dispose(); }
    }
    this.createText();
  }

  // --- Public metrics API ---
  public getMetrics() {
    const count = this.particles ? (this.particles.geometry as THREE.BufferGeometry).attributes.position.count : 0;
    // compute heat stats lazily
    let heatSum = 0; let heatMax = 0;
    for (let i = 0; i < this.heatLevels.length; i++) {
      const h = this.heatLevels[i];
      heatSum += h;
      if (h > heatMax) heatMax = h;
    }
    const avgHeat = this.heatLevels.length > 0 ? heatSum / this.heatLevels.length : 0;
    return {
      particleCount: count,
      activeSymbols: this.activeSymbolsCount,
      spawnRate: this.symbolSpawnRate, // per second
      avgHeat,
      maxHeat: heatMax
    };
  }
}
--- END OF FILE src\lib\three\heroParticleLogic.ts ---

--- START OF FILE src\params\lang.ts ---
// src/params/lang.ts
// Constrains [lang] route segment to supported locales
export function match(param: string) {
  return param === 'en' || param === 'de';
}

--- END OF FILE src\params\lang.ts ---

--- START OF FILE src\routes\+layout.server.ts ---
// src/routes/+layout.server.ts
import type { LayoutServerLoad } from './$types';
import { decideLocale, extractCountryCodeFromHeaders, setVaryHeaders, syncLocaleCookie } from '$lib/server/locale';

export const load: LayoutServerLoad = async ({ cookies, request, params, setHeaders }) => {
  const urlLocale = params?.lang ?? null;
  const cookieLocale = cookies.get('locale');
  const accept = request.headers.get('accept-language');
  const countryCode = extractCountryCodeFromHeaders((name) => request.headers.get(name));

  const locale = decideLocale({ urlLocale, cookieLocale, acceptLanguage: accept, countryCode });
  syncLocaleCookie(cookies, locale);
  setVaryHeaders(setHeaders);

  return { locale };
};

--- END OF FILE src\routes\+layout.server.ts ---

--- START OF FILE src\routes\+layout.svelte ---
<!-- src/routes/+layout.svelte -->
<script lang="ts">
  // Import the global stylesheet. This is the new line.
  import '../app.css';
  import TransitionOverlay from '$lib/components/TransitionOverlay.svelte';
  import LegalFooter from '$lib/components/LegalFooter.svelte';
  import LanguageSwitcher from '$lib/components/LanguageSwitcher.svelte';
  import { siteConfig } from '$lib/data/siteConfig';
  import { initialSiteLoadComplete } from '$lib/stores/preloadingStore';
  import { page } from '$app/stores';
  import { fade } from 'svelte/transition';
  import { browser } from '$app/environment';
  import { onMount, onDestroy } from 'svelte';

  export let data: { locale: 'en' | 'de'; messages?: { common?: any; layout?: any } };
  let isHome: boolean;
  let showFooter: boolean;
  // Fallback: force-show footer on home after short delay if initial load signal is slow
  let footerForcedVisible = false;
  let footerForceTimer: number | undefined;
  // Treat /, /en and /de as home (with or without trailing slash)
  $: isHome = /^\/(|en\/|de\/?|en|de)$/.test($page.url.pathname);
  $: showFooter = isHome ? ($initialSiteLoadComplete || footerForcedVisible) : true;
  const fadeIn = { duration: 250 };

  // Keep document language in sync with the active locale
  $: if (browser && data?.locale) {
    document.documentElement.lang = data.locale;
  }

  onMount(() => {
    // Safety: ensure footer becomes visible even if initial load never flips (e.g., dev anomalies)
    footerForceTimer = window.setTimeout(() => {
      footerForcedVisible = true;
    }, 2500);
  });

  onDestroy(() => {
    if (footerForceTimer) clearTimeout(footerForceTimer);
  });

  // Scroll control: lock body only on the immersive home route; all other pages (legal etc.) should scroll normally.
  $: if (browser) {
    if (isHome) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
    }
  }
</script>

<svelte:head>
  {#if $page}
    {@const pathname = $page.url.pathname}
    {@const origin = $page.url.origin}
    {@const hrefEn = (() => {
      if (pathname === '/') return `/en`;
      if (/^\/(en|de)(\/|$)/.test(pathname)) return pathname.replace(/^\/(en|de)/, `/en`);
      return `/en${pathname}`;
    })()}
    {@const hrefDe = (() => {
      if (pathname === '/') return `/de`;
      if (/^\/(en|de)(\/|$)/.test(pathname)) return pathname.replace(/^\/(en|de)/, `/de`);
      return `/de${pathname}`;
    })()}
    <link rel="alternate" hreflang="en" href={`${origin}${hrefEn}`} />
    <link rel="alternate" hreflang="de" href={`${origin}${hrefDe}`} />
    <link rel="alternate" hreflang="x-default" href={`${origin}${hrefDe}`} />
  {/if}
  {#if data?.messages?.layout?.meta?.siteTitle}
    <title>{data.messages.layout.meta.siteTitle}</title>
    <meta name="description" content={data.messages.layout.meta.siteDescription} />
  {/if}
</svelte:head>

<TransitionOverlay />

<slot />

{#if showFooter}
  <div in:fade={fadeIn}>
    <LegalFooter
      legalLinks={siteConfig.legalLinks.map((l) => {
        // Map base German slugs to English variants when locale is EN
        const locale = data.locale;
        let localizedUrl = l.url;
        if (locale === 'en') {
          if (l.url === '/datenschutz') localizedUrl = '/privacy';
          else if (l.url === '/impressum') localizedUrl = '/imprint';
          else if (l.url === '/barrierefreiheit') localizedUrl = '/accessibility';
        }
        const nameOverride = (() => {
          if (l.url === '/impressum') return data.messages?.common?.legal?.impressum ?? l.name;
          if (l.url === '/datenschutz') return data.messages?.common?.legal?.datenschutz ?? l.name;
          if (l.url === '/barrierefreiheit') return data.messages?.common?.legal?.barrierefreiheit ?? l.name;
          return l.name;
        })();
        // If locale is EN and we swapped slug, optionally override label to English if translations exist
        const englishLabelMap: Record<string, string | undefined> = {
          '/privacy': data.messages?.common?.legal?.privacy,
          '/imprint': data.messages?.common?.legal?.imprint,
          // Reuse the same translation key used for the DE base name; EN locale maps it to "Accessibility"
          '/accessibility': data.messages?.common?.legal?.barrierefreiheit
        };
        const finalName = locale === 'en' && englishLabelMap[localizedUrl]
          ? englishLabelMap[localizedUrl]!
          : nameOverride;
        return { ...l, url: localizedUrl, name: finalName };
      })}
    >
      <LanguageSwitcher
        locale={data.locale}
        groupLabel={data.messages?.common?.language?.groupLabel ?? 'Language'}
        labelEn={data.messages?.common?.language?.en ?? 'EN'}
        labelDe={data.messages?.common?.language?.de ?? 'DE'}
        switchToEnLabel={data.messages?.common?.language?.switchToEn ?? 'Switch to English'}
        switchToDeLabel={data.messages?.common?.language?.switchToDe ?? 'Switch to German'}
      />
    </LegalFooter>
  </div>
{/if}

<!-- 
  The <style> block has been removed from here and its contents
  have been moved to src/app.css, as per SvelteKit best practices.
-->
--- END OF FILE src\routes\+layout.svelte ---

--- START OF FILE src\routes\+layout.ts ---
import type { LayoutLoad } from './$types';

export const load: LayoutLoad = async ({ data }) => {
  const locale = (data as { locale?: 'en' | 'de' })?.locale ?? 'de';

  const common = (await import(`$lib/i18n/locales/${locale}/common.json`)).default;
  const layout = (await import(`$lib/i18n/locales/${locale}/layout.json`)).default;

  return { messages: { common, layout }, locale };
};

--- END OF FILE src\routes\+layout.ts ---

--- START OF FILE src\routes\+page.server.ts ---
// src/routes/+page.server.ts
import type { PageServerLoad } from './$types';
import { redirect } from '@sveltejs/kit';
import { decideLocale, extractCountryCodeFromHeaders, setVaryHeaders } from '$lib/server/locale';

export const load: PageServerLoad = async ({ cookies, request, setHeaders }) => {
  const locale = decideLocale({
    cookieLocale: cookies.get('locale') ?? null,
    acceptLanguage: request.headers.get('accept-language'),
    countryCode: extractCountryCodeFromHeaders((name) => request.headers.get(name)) ?? null
  });
  setVaryHeaders(setHeaders);
  throw redirect(307, `/${locale}`);
};

--- END OF FILE src\routes\+page.server.ts ---

--- START OF FILE src\routes\+page.svelte ---
<!-- Minimal placeholder. Root path redirects via +page.server.ts -->
<script lang="ts">
  // intentionally empty
</script>

<div></div>
--- END OF FILE src\routes\+page.svelte ---

--- START OF FILE src\routes\barrierefreiheit\+page.server.ts ---
import type { PageServerLoad } from './$types';
import { redirect } from '@sveltejs/kit';
import { decideLocale, extractCountryCodeFromHeaders, setVaryHeaders } from '$lib/server/locale';

export const load: PageServerLoad = async ({ cookies, request, setHeaders }) => {
  const locale = decideLocale({
    cookieLocale: cookies.get('locale') ?? null,
    acceptLanguage: request.headers.get('accept-language'),
    countryCode: extractCountryCodeFromHeaders((name) => request.headers.get(name)) ?? null
  });
  setVaryHeaders(setHeaders);
  throw redirect(307, `/${locale}/barrierefreiheit`);
};

--- END OF FILE src\routes\barrierefreiheit\+page.server.ts ---

--- START OF FILE src\routes\barrierefreiheit\+page.svelte ---
<script lang="ts">
  import BackButton from '$lib/components/BackButton.svelte';
</script>

<svelte:head>
  <title>Barrierefreiheit</title>
</svelte:head>

<main class="legal-page">
  <BackButton />
  <h1>Barrierefreiheit</h1>
  <p>Platzhalter-Inhalt. Hier folgt die Erklärung zur Barrierefreiheit dieser Website.</p>
</main>

<style>
  .legal-page { min-height: 100vh; display: grid; place-items: center; padding: 2rem; color: white; }
  h1 { font-size: 2rem; margin-bottom: 1rem; }
  p { max-width: 60ch; color: rgba(255,255,255,0.8); margin-bottom: 1.5rem; }
  /* Back button provided by shared component */
</style>

--- END OF FILE src\routes\barrierefreiheit\+page.svelte ---

--- START OF FILE src\routes\datenschutz\+page.server.ts ---
import type { PageServerLoad } from './$types';
import { redirect } from '@sveltejs/kit';
import { decideLocale, extractCountryCodeFromHeaders, setVaryHeaders } from '$lib/server/locale';

export const load: PageServerLoad = async ({ cookies, request, setHeaders }) => {
  const locale = decideLocale({
    cookieLocale: cookies.get('locale') ?? null,
    acceptLanguage: request.headers.get('accept-language'),
    countryCode: extractCountryCodeFromHeaders((name) => request.headers.get(name)) ?? null
  });
  setVaryHeaders(setHeaders);
  throw redirect(307, `/${locale}/datenschutz`);
};

--- END OF FILE src\routes\datenschutz\+page.server.ts ---

--- START OF FILE src\routes\datenschutz\+page.svelte ---
<script lang="ts">
  import BackButton from '$lib/components/BackButton.svelte';
</script>

<svelte:head>
  <title>Datenschutz</title>
</svelte:head>

<main class="legal-page">
  <BackButton />
  <h1>Datenschutz</h1>
  <p>Platzhalter-Inhalt. Hier stehen Informationen zur Datenverarbeitung und Ihren Rechten.</p>
</main>

<style>
  .legal-page { min-height: 100vh; display: grid; place-items: center; padding: 2rem; color: white; }
  h1 { font-size: 2rem; margin-bottom: 1rem; }
  p { max-width: 60ch; color: rgba(255,255,255,0.8); margin-bottom: 1.5rem; }
  /* Back button provided by shared component */
</style>

--- END OF FILE src\routes\datenschutz\+page.svelte ---

--- START OF FILE src\routes\debug\locale\+server.ts ---
// src/routes/debug/locale/+server.ts
import type { RequestHandler } from './$types';
import { json } from '@sveltejs/kit';
import { decideLocale, extractCountryCodeFromHeaders, setVaryHeaders } from '$lib/server/locale';

export const GET: RequestHandler = async ({ cookies, request, setHeaders, url }) => {
  const acceptLanguage = request.headers.get('accept-language');
  const countryCode = extractCountryCodeFromHeaders((name) => request.headers.get(name));
  const cookieLocale = cookies.get('locale');
  const resolved = decideLocale({ urlLocale: null, cookieLocale, acceptLanguage, countryCode });

  setVaryHeaders(setHeaders);
  setHeaders({ 'Cache-Control': 'no-store', 'X-Robots-Tag': 'noindex, nofollow' });

  return json({
    resolvedLocale: resolved,
    inputs: {
      url: url.pathname,
  urlLocale: null,
      cookieLocale,
      acceptLanguage,
      countryCode
    },
    headers: {
      'accept-language': acceptLanguage,
      'cf-ipcountry': request.headers.get('cf-ipcountry'),
      'x-vercel-ip-country': request.headers.get('x-vercel-ip-country'),
      'fastly-geoip-country-code': request.headers.get('fastly-geoip-country-code'),
      'x-fastly-country-code': request.headers.get('x-fastly-country-code'),
      'x-country-code': request.headers.get('x-country-code'),
      'x-geo-country': request.headers.get('x-geo-country'),
      'x-nf-geo': request.headers.get('x-nf-geo')
    }
  });
};

--- END OF FILE src\routes\debug\locale\+server.ts ---

--- START OF FILE src\routes\impressum\+page.server.ts ---
import type { PageServerLoad } from './$types';
import { redirect } from '@sveltejs/kit';
import { decideLocale, extractCountryCodeFromHeaders, setVaryHeaders } from '$lib/server/locale';

export const load: PageServerLoad = async ({ cookies, request, setHeaders }) => {
  const locale = decideLocale({
    cookieLocale: cookies.get('locale') ?? null,
    acceptLanguage: request.headers.get('accept-language'),
    countryCode: extractCountryCodeFromHeaders((name) => request.headers.get(name)) ?? null
  });
  setVaryHeaders(setHeaders);
  throw redirect(307, `/${locale}/impressum`);
};

--- END OF FILE src\routes\impressum\+page.server.ts ---

--- START OF FILE src\routes\impressum\+page.svelte ---
<script lang="ts">
  import BackButton from '$lib/components/BackButton.svelte';
</script>

<svelte:head>
  <title>Impressum</title>
</svelte:head>

<main class="legal-page">
  <BackButton />
  <h1>Impressum</h1>
  <p>Platzhalter-Inhalt. Hier folgen rechtliche Angaben gemäß § 5 TMG.</p>
</main>

<style>
  .legal-page { min-height: 100vh; display: grid; place-items: center; padding: 2rem; color: white; }
  h1 { font-size: 2rem; margin-bottom: 1rem; }
  p { max-width: 60ch; color: rgba(255,255,255,0.8); margin-bottom: 1.5rem; }
  /* Back button provided by shared component */
</style>

--- END OF FILE src\routes\impressum\+page.svelte ---

--- START OF FILE src\routes\projects\[slug]\+layout.svelte ---
<!-- src/routes/projects/[slug]/+layout.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { ArrowLeft } from 'lucide-svelte';
  // --- MODIFICATION: Import the new transition store ---
  import { transitionStore } from '$lib/stores/transitionStore';

  let showButton = false;

  onMount(() => {
    const timer = setTimeout(() => {
      showButton = true;
    }, 300);

    return () => clearTimeout(timer);
  });

  function handleBackClick() {
    // Determine project id based on slug param
    // Access $page not available here (no import) so replicate via URL parsing as fallback
    let projectId: string | null = null;
    try {
      const path = window.location.pathname; // /projects/{slug}
      const parts = path.split('/');
      const slug = parts[parts.length - 1];
      if (slug === 'BURA') projectId = 'project-one';
      else if (slug === 'Project2') projectId = 'project-two';
    } catch {}
    const hash = projectId ? `#project-${projectId}` : '';
    transitionStore.fadeToBlackAndNavigate(`/${hash}`);
  }
</script>

<div class="project-subpage-layout">
  <button 
    class="back-button"
    class:visible={showButton}
    on:click={handleBackClick}
    aria-label="Back to home"
  >
    <ArrowLeft size={24} />
  </button>

  <!-- The content of +page.svelte will be rendered here -->
  <slot />
</div>

<style>
  .project-subpage-layout {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .back-button {
    position: fixed;
    top: 2rem;
    left: 2rem;
    z-index: 1000; /* Ensure it's on top of all page content */
    
    background-color: rgba(30, 30, 32, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: white;
    backdrop-filter: blur(8px);
    
    width: 3rem;
    height: 3rem;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    
    cursor: pointer;
    transition: all 0.3s ease-in-out;
    
    opacity: 0;
    transform: scale(0.8);
    pointer-events: none;
  }

  .back-button.visible {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
  }

  .back-button:hover {
    background-color: rgba(50, 50, 52, 0.9);
    transform: scale(1.05);
  }
</style>
--- END OF FILE src\routes\projects\[slug]\+layout.svelte ---

--- START OF FILE src\routes\projects\[slug]\+page.svelte ---
<!-- src/routes/projects/[slug]/+page.svelte -->
<script lang="ts">
  import { onMount, onDestroy, tick } from 'svelte';
  import { get, writable } from 'svelte/store';
  import { page } from '$app/stores';
  import { gsap } from 'gsap';
  import { siteConfig } from '$lib/data/siteConfig';
  import { preloadingStore, startLoadingTask, preloadAssets } from '$lib/stores/preloadingStore';

  export let data;
  const { project } = data;

  // A unique task ID for this specific project's assets.
  const PROJECT_ASSETS_TASK_ID = `project-assets-${project.slug}`;

  // A local store to track when this page's content is ready to be shown.
  const isContentLoaded = writable(false);

  // Combine the project overview and detailed sections into one scrollable list.
  const allSubSections = [
    { 
      id: 'overview', 
      title: project.headline,
      content: project.summary,
      background: project.backgrounds[0]
    },
    ...project.subPageSections
  ];

  let sectionElements: HTMLElement[] = [];
  let sectionContentTimelines: (gsap.core.Timeline | null)[] = [];
  let sectionBackgroundZooms: (gsap.core.Tween | null)[] = [];

  // State for the subpage's internal scrolling logic.
  let currentSectionIndex = 0;
  let isAnimating = false;
  let lastScrollTime = 0;
  const scrollDebounce = 200;
  const transitionDuration = 1.1;

  onMount(() => {
    // This function runs once when the component is created.
    const runPreloadAndSetup = async () => {
      // 1. Register a task with the global preloading store.
      startLoadingTask(PROJECT_ASSETS_TASK_ID, 2);

      // 2. Gather all image URLs needed for this subpage.
      const assetUrls = allSubSections
        .filter(s => s.background && s.background.type === 'image')
        .map(s => s.background.value);
      
      try {
        // 3. Use the global preloader to fetch assets. This is cache-aware.
        await preloadAssets(assetUrls);
        preloadingStore.updateTaskStatus(PROJECT_ASSETS_TASK_ID, 'loaded');
        console.log(`All assets for project '${project.slug}' preloaded successfully.`);
      } catch (error) {
        console.error(error);
        preloadingStore.updateTaskStatus(PROJECT_ASSETS_TASK_ID, 'error', (error as Error).message);
      } finally {
        // 4. Mark content as ready to be shown, which will trigger the animation setup.
        isContentLoaded.set(true);
      }
    };
    
    runPreloadAndSetup();

    return () => {
      window.removeEventListener('wheel', handleWheel);
      window.removeEventListener('keydown', handleKeyDown);
      sectionContentTimelines.forEach(timeline => { timeline?.kill(); });
      sectionBackgroundZooms.forEach(tween => { tween?.kill(); });
    };
  });

  // This reactive block runs automatically when `isContentLoaded` becomes true.
  $: if ($isContentLoaded) {
    setupAnimations();
  }

  async function setupAnimations() {
      await tick();

      sectionElements = allSubSections.map(section => document.getElementById(section.id) as HTMLElement);
      
      // Check the URL hash to determine the starting section.
      const urlHash = get(page).url.hash;
      const cleanHash = urlHash.startsWith('#') ? urlHash.substring(1) : null;
      
      let initialIndex = 0;
      if (cleanHash) {
        const foundIndex = allSubSections.findIndex(s => s.id === cleanHash);
        if (foundIndex !== -1) {
          initialIndex = foundIndex;
        }
      }
      currentSectionIndex = initialIndex;

      // Create animations for each section but keep them paused.
      sectionElements.forEach((sectionEl, index) => {
        const contentTl = gsap.timeline({ paused: true });
        const contentOverlay = sectionEl.querySelector('.subpage-content-overlay');
        const h2El = sectionEl.querySelector('h2');
        const pEl = sectionEl.querySelector('p');

        if (contentOverlay) {
          contentTl.fromTo(contentOverlay, { autoAlpha: 0, scale: 0.95 }, { autoAlpha: 1, scale: 1, duration: 0.7, ease: 'power2.out' }, "start");
        }
        if (h2El) {
          contentTl.fromTo(h2El, { autoAlpha: 0, y: 30 }, { autoAlpha: 1, y: 0, duration: 0.8, ease: 'power2.out' }, "start+=0.2");
        }
        if (pEl) {
          contentTl.fromTo(pEl, { autoAlpha: 0, y: 20 }, { autoAlpha: 1, y: 0, duration: 0.7, ease: 'power2.out' }, "start+=0.35");
        }
        sectionContentTimelines[index] = contentTl;
        
        const bgTarget = sectionEl.querySelector('.subpage-background-image') as HTMLElement;
        if (bgTarget) {
          sectionBackgroundZooms[index] = gsap.to(bgTarget, { scale: 1.05, duration: 3, ease: 'power1.out', paused: true });
        }
      });

      // Set initial visibility and positions.
      sectionElements.forEach((el, index) => {
        if (index === initialIndex) {
          gsap.set(el, { yPercent: 0, autoAlpha: 1 });
          sectionContentTimelines[index]?.restart();
          sectionBackgroundZooms[index]?.restart();
        } else {
          gsap.set(el, { yPercent: 100, autoAlpha: 0 });
        }
      });

      // Add event listeners for navigation.
      window.addEventListener('wheel', handleWheel, { passive: false });
      window.addEventListener('keydown', handleKeyDown);
  }

  function navigateToSection(newIndex: number) {
    const oldIndex = currentSectionIndex;
    if (isAnimating || newIndex === oldIndex || newIndex < 0 || newIndex >= sectionElements.length) return;
    
    isAnimating = true;

    const currentSectionEl = sectionElements[oldIndex];
    const targetSectionEl = sectionElements[newIndex];
    const direction = newIndex > oldIndex ? 1 : -1;

    // Reset and pause animations for the outgoing section.
    sectionContentTimelines[oldIndex]?.progress(0).pause();
    sectionBackgroundZooms[oldIndex]?.progress(0).pause();

    gsap.set(targetSectionEl, { yPercent: direction * 100, autoAlpha: 1 });

    const masterTl = gsap.timeline({
      onComplete: () => {
        isAnimating = false;
        currentSectionIndex = newIndex;
      }
    });

    masterTl.to(currentSectionEl, { yPercent: -direction * 100, autoAlpha: 0, duration: transitionDuration, ease: 'expo.out' }, "slide");
    masterTl.to(targetSectionEl, { yPercent: 0, duration: transitionDuration, ease: 'expo.out' }, "slide");
    
    // Play animations for the incoming section partway through the transition.
    masterTl.call(() => { sectionContentTimelines[newIndex]?.restart(); }, [], `slide+=${transitionDuration * 0.3}`);
    masterTl.call(() => { sectionBackgroundZooms[newIndex]?.restart(); }, [], `slide+=${transitionDuration * 0.1}`);
  }

  function handleWheel(event: WheelEvent) {
    event.preventDefault();
    const currentTime = Date.now();
    if (currentTime - lastScrollTime < scrollDebounce || isAnimating) return;
    lastScrollTime = currentTime;
    navigateToSection(currentSectionIndex + (event.deltaY > 0 ? 1 : -1));
  }

  function handleKeyDown(event: KeyboardEvent) {
    if (isAnimating) {
        event.preventDefault();
        return;
    }
    const currentTime = Date.now();
    if (currentTime - lastScrollTime < scrollDebounce) {
        event.preventDefault();
        return;
    }
    let newIndex = currentSectionIndex;
    let shouldScroll = false;
    switch (event.key) {
        case 'ArrowDown': case 'PageDown': case ' ': newIndex++; shouldScroll = true; break;
        case 'ArrowUp': case 'PageUp': newIndex--; shouldScroll = true; break;
        case 'Home': newIndex = 0; shouldScroll = true; break;
        case 'End': newIndex = allSubSections.length - 1; shouldScroll = true; break;
    }
    if (shouldScroll && newIndex !== currentSectionIndex) {
        event.preventDefault();
        lastScrollTime = currentTime;
        navigateToSection(newIndex);
    }
  }
</script>

<svelte:head>
  <title>{project.headline} | {siteConfig.author}</title>
  <meta name="description" content={project.summary} />
</svelte:head>

<div class="subpage-container" class:loaded={$isContentLoaded}>
  {#each allSubSections as section, i (section.id)}
    <section id={section.id} class="subpage-fullscreen-section">
      <!-- --- START OF FIX --- -->
      <!-- Add a conditional wrapper to prevent rendering this div if a section has no background. -->
      <!-- This makes the component robust and prevents the SSR crash. -->
      {#if section.background}
        <div 
          class="subpage-background-image"
          style="background-image: url({section.background.value});"
        ></div>
      {/if}
      <!-- --- END OF FIX --- -->
      
      <div class="subpage-content-overlay">
        <h2>{section.title}</h2>
        <p>{section.content}</p>
      </div>
    </section>
  {/each}
</div>

<style>
  .subpage-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #000;
    overflow: hidden;
    opacity: 0;
    transition: opacity 0.6s ease-in-out;
  }
  
  .subpage-container.loaded {
    opacity: 1;
  }

  .subpage-fullscreen-section {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    padding: 2rem;
    box-sizing: border-box;
  }

  .subpage-background-image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 0;
    transform: scale(1);
  }

  .subpage-content-overlay {
    position: relative;
    z-index: 1;
    max-width: 800px;
    text-align: center;
    padding: 2rem 3rem;
    background-color: rgba(9, 9, 11, 0.75);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    opacity: 0;
    visibility: hidden; /* Start hidden for GSAP */
  }

  .subpage-content-overlay h2 {
    font-size: clamp(2.2rem, 5vw, 3.5rem);
    font-weight: 700;
    font-family: 'Playfair Display', serif;
    margin-bottom: 1.5rem;
    text-shadow: 0 2px 20px rgba(0,0,0,0.5);
    opacity: 0;
    visibility: hidden;
  }

  .subpage-content-overlay p {
    font-size: clamp(1rem, 2.5vw, 1.15rem);
    line-height: 1.8;
    max-width: 700px;
    margin: 0 auto;
    color: #e2e8f0;
    opacity: 0;
    visibility: hidden;
  }
</style>
--- END OF FILE src\routes\projects\[slug]\+page.svelte ---

--- START OF FILE src\routes\projects\[slug]\+page.ts ---
// src/routes/projects/[slug]/+page.ts

import { error } from '@sveltejs/kit';
import { projects } from '$lib/data/projectsData';
import type { PageLoad } from './$types';

// FIX: Removed `url` from the function parameters. We only need `params`.
export const load: PageLoad = ({ params }) => {
  const project = projects.find(p => p.slug === params.slug);

  if (!project) {
    throw error(404, 'Project not found');
  }

  // FIX: Only return the project data. The hash will be read on the client.
  return {
    project
  };
};
--- END OF FILE src\routes\projects\[slug]\+page.ts ---

--- START OF FILE src\routes\[lang=lang]\+page.svelte ---
<!-- src/routes/[lang=lang]/+page.svelte -->
<script lang="ts">
	import { onMount, onDestroy, tick } from 'svelte';
	import { writable, get } from 'svelte/store';
		import { siteConfig } from '$lib/data/siteConfig';
		import { page } from '$app/stores';
	import { getProjects, type Project, type Locale } from '$lib/data/projectsData';
	import { initialSiteLoadComplete, preloadAssets } from '$lib/stores/preloadingStore';
	import { sectionStates, type SectionState } from '$lib/stores/sectionStateStore';
	import { renderProfile } from '$lib/stores/renderProfile';
	import { gsap } from 'gsap';

	// Component Imports
	import LoadingScreen from '$lib/components/LoadingScreen.svelte';
	import HeroSection from '$lib/components/sections/HeroSection.svelte';
	import AboutSection from '$lib/components/sections/AboutSection.svelte';
	import ContactSection from '$lib/components/sections/ContactSection.svelte';
	import ProjectSection from '$lib/components/sections/ProjectSection.svelte'; 
	import ProjectOneLayout from '$lib/components/layouts/ProjectOneLayout.svelte';
	import MobileNavDots from '$lib/components/MobileNavDots.svelte';

	// Type Imports
	interface IAnimatedComponent {
		onEnterSection: () => void;
		onLeaveSection: () => void;
		initializeEffect?: () => Promise<void>;
		onTransitionComplete?: () => void;
		onUnload?: () => void;
	}
	import type { HeroSectionInstance } from '$lib/components/sections/HeroSection.svelte';

	// Section Data Structure (reactive to locale)
	let allSectionsData: any[] = [];
	let currentLocale: Locale;
	$: currentLocale = ((($page.params as any)?.lang === 'de') ? 'de' : 'en');
	$: localizedProjects = getProjects(currentLocale);
	$: allSectionsData = [
		{ id: 'hero', component: HeroSection, data: siteConfig.heroSection, layout: null },
		{ id: 'about', component: AboutSection, data: siteConfig.aboutSection, layout: null },
		{ id: `project-${localizedProjects[0].id}`, component: ProjectSection, layout: ProjectOneLayout, data: localizedProjects[0] },
		{ id: `project-${localizedProjects[1].id}`, component: ProjectSection, layout: ProjectOneLayout, data: localizedProjects[1] },
		{ id: 'contact', component: ContactSection, data: siteConfig.contactSection, layout: null }
	];
	const contactSectionIndex = allSectionsData.findIndex(s => s.id === 'contact');

		// Localized data overrides for About and Contact
		let aboutData: typeof siteConfig.aboutSection = siteConfig.aboutSection;
		let contactData: typeof siteConfig.contactSection = siteConfig.contactSection;
		$: {
			const common = ($page.data as any)?.messages?.common;
			if (common?.about) {
				aboutData = {
					...siteConfig.aboutSection,
					title: common.about.title ?? siteConfig.aboutSection.title,
					introduction: common.about.introduction ?? siteConfig.aboutSection.introduction
				};
			}
			if (common?.contact) {
				contactData = {
					...siteConfig.contactSection,
					title: common.contact.title ?? siteConfig.contactSection.title,
					outroMessage: common.contact.outroMessage ?? siteConfig.contactSection.outroMessage
				};
			}
		}

	// Instance Management
	let heroSectionInstance: HeroSectionInstance | null = null;
	let sectionInstancesArray: (IAnimatedComponent | null)[] = new Array(allSectionsData.length).fill(null);
	let sectionInstances = new Map<string, IAnimatedComponent>();
	$: if (sectionInstancesArray.length > 0) {
		const newMap = new Map<string, IAnimatedComponent>();
		allSectionsData.forEach((section, index) => {
			const instance = index === 0 ? heroSectionInstance : sectionInstancesArray[index];
			if (instance) newMap.set(section.id, instance);
		});
		sectionInstances = newMap;
	}
  
	// Core State
	const isAnimating = writable(false);
	const currentSectionIndex = writable(0);
	const isTransitioning = writable(false);
	const isInitialReveal = writable(true);
	const sectionStatesStore = sectionStates;
	const isLeavingHero = writable(false);
		// Dots active index updates at transition start for smooth grow/shrink
		const navActiveIndex = writable(0);

	// Page & Animation State
	let visibilityHideTimeoutId: number | undefined;
	let isTabHiddenAndPaused = false;
	const HIDE_BUFFER_DURATION = 15000;
	let sectionElements: HTMLElement[] = [];
	let sectionBackgroundZooms: (gsap.core.Tween | null)[] = [];
	const transitionDuration = 1.1;
	const projectBgZoomDuration = 5;
	const minSectionDisplayDuration = 1.2;
	const initialRevealDelay = 300;
	const particleFadeInDuration = 1.5;
	let unsubInitialLoadComplete: (() => void) | undefined;
	let hasStartedInitialReveal = false;

	// --- HASH NAVIGATION STATE (declared early so usable everywhere) ---
	let initialHashFragment: string | null = null; // raw fragment captured on first mount
	let initialHashTargetIndex: number | null = null; // resolved index once sections known
	let suppressNextHashUpdate = false; // guard to avoid loops when we programmatically set hash
	let onHashChange: (() => void) | null = null; // reference for cleanup

	// --- DEEP LINK / LOADING CONTROL ---
	let startOnHero = true; // becomes false if deep link to non-hero
	let isDeepLinkStart = false;
	let showLoadingScreen = true; // controls LoadingScreen rendering

	// --- Focus management helpers ---
	function isElementVisible(el: Element): boolean {
		if (!(el instanceof HTMLElement)) return false;
		if (el.hidden) return false;
		if (el.getAttribute('aria-hidden') === 'true') return false;
		const rect = el.getBoundingClientRect();
		return rect.width > 0 && rect.height > 0;
	}

	function findFocusTarget(sectionEl: HTMLElement): HTMLElement | null {
		// New priority: dedicated invisible sentinel to avoid visual focus ring on buttons
		let candidate = sectionEl.querySelector('.section-focus-sentinel') as HTMLElement | null;
		if (candidate) return candidate;
		// fallback to previous logic (reduced) for robustness
		candidate = sectionEl.querySelector('[data-focus-first]') as HTMLElement | null;
		if (candidate && isElementVisible(candidate)) return candidate;
		candidate = sectionEl.querySelector('[autofocus]') as HTMLElement | null;
		if (candidate && isElementVisible(candidate)) return candidate;
		if (!sectionEl.hasAttribute('tabindex')) sectionEl.setAttribute('tabindex', '-1');
		return sectionEl;
	}

	function setActiveSectionInert(activeIndex: number) {
		sectionElements.forEach((el, idx) => {
			if (!el) return;
			if (idx === activeIndex) {
				el.removeAttribute('inert');
			} else {
				el.setAttribute('inert', '');
			}
		});
	}

	function focusSection(index: number) {
		const el = sectionElements[index];
		if (!el) return;
		const target = findFocusTarget(el);
		if (target) {
			// Use rAF to ensure styles/layout are settled post-transition
			requestAnimationFrame(() => {
				try { target.focus({ preventScroll: true } as any); } catch {}
				// move virtual cursor into view without jarring scroll (sections are full-screen)
				try { target.scrollIntoView({ block: 'nearest' }); } catch {}
			});
		}
	}

	// --- ARIA live region for section announcements ---
	let liveMessage = '';
	function computeSectionTitle(index: number): string {
		const section = allSectionsData[index];
		if (!section) return '';
		if (section.id === 'about') return aboutData.title ?? 'About';
		if (section.id === 'contact') return contactData.title ?? 'Contact';
		if (section.id === 'hero') {
			const name = siteConfig?.heroSection?.name ?? '';
			const greeting = siteConfig?.heroSection?.greeting ?? '';
			return [greeting, name].filter(Boolean).join(' ').trim() || 'Home';
		}
		if (section.id.startsWith('project-')) {
			try { return (section.data as any)?.headline || 'Project'; } catch { return 'Project'; }
		}
		return section.id;
	}

	function announceSection(index: number) {
		const title = computeSectionTitle(index);
		if (!title) return;
		// Clear then set to ensure screen readers announce changes
		liveMessage = '';
		requestAnimationFrame(() => { liveMessage = title; });
	}
  
	let particleLayerPointerEvents = 'none';
	$: particleLayerPointerEvents = ($currentSectionIndex === 0 && !$isInitialReveal) ? 'auto' : 'none';
	let mainContainerPointerEvents = 'auto';
	$: mainContainerPointerEvents = ($currentSectionIndex === 0 || $isInitialReveal) ? 'none' : 'auto';

	// Render profile

	// Promise setup for initial load
	let heroReadyResolver: () => void;
	const heroReadyPromise = new Promise<void>(resolve => {
		heroReadyResolver = resolve;
	});

	// The HYBRID Preload Manager
	const preloadManager = {
		async updateNeighborStates(activeIndex: number) {
			const currentStates = get(sectionStatesStore);
			const desiredStates: SectionState[] = allSectionsData.map((_, i) => {
				if (i === activeIndex) return 'ACTIVE';
				if (i === activeIndex - 1 || i === activeIndex + 1) return 'READY';
				return 'COOLDOWN';
			});

			const tasks: Promise<void>[] = [];

			for (let i = 0; i < allSectionsData.length; i++) {
				const currentState = currentStates[i];
				const desiredState = desiredStates[i];

				if (currentState !== desiredState) {
					if ((currentState === 'IDLE' || currentState === 'COOLDOWN') && desiredState === 'READY') {
						tasks.push(this.prepareSection(i));
					}
					if (currentState === 'READY' && desiredState === 'COOLDOWN') {
						tasks.push(this.coolDownSection(i));
					}
				}
			}
      
			sectionStatesStore.update(states => {
				states[activeIndex] = 'ACTIVE';
				return states;
			});

			await Promise.all(tasks);
		},
    
		async prepareSection(index: number) {
			const currentState = get(sectionStatesStore)[index];
			if (currentState !== 'IDLE' && currentState !== 'COOLDOWN') return;
      
			const sectionInfo = allSectionsData[index];
			const instance = sectionInstances.get(sectionInfo.id);
			const element = sectionElements[index];

			if (!instance || !element) return;

			sectionStatesStore.update(states => { states[index] = 'PRELOADING'; return states; });

			const urls = this.getSectionAssetUrls(index);
			if (urls.length > 0) await preloadAssets(urls);
      
			if (instance.initializeEffect) await instance.initializeEffect();
      
			if (sectionInfo.id === 'about' || sectionInfo.id === 'contact') {
				gsap.set(element, { yPercent: 0, autoAlpha: 0.0001 });
				instance.onEnterSection();
				instance.onTransitionComplete?.();
				await new Promise(resolve => setTimeout(resolve, 200));
				instance.onLeaveSection();
				gsap.set(element, { yPercent: 100, autoAlpha: 0 });
			} else if (sectionInfo.id.startsWith('project-')) {
				gsap.set(element, { yPercent: 0, autoAlpha: 0.0001 });
				await new Promise(resolve => requestAnimationFrame(resolve));
				await new Promise(resolve => requestAnimationFrame(resolve));
				gsap.set(element, { yPercent: 100, autoAlpha: 0 });
			}
      
			sectionStatesStore.update(states => { states[index] = 'READY'; return states; });
		},

		async coolDownSection(index: number) {
			const sectionId = allSectionsData[index].id;
			sectionStatesStore.update(states => { states[index] = 'COOLDOWN'; return states; });
      
			const instance = sectionInstances.get(sectionId);
			instance?.onUnload?.();
      
			sectionStatesStore.update(states => { states[index] = 'IDLE'; return states; });
		},

		getSectionAssetUrls(index: number): string[] {
			if (index < 0 || index >= allSectionsData.length) return [];
			const section = allSectionsData[index];
			let urls: string[] = [];
			if (section.id === 'about') {
				urls.push((section.data as typeof siteConfig.aboutSection).imageUrl);
			} else if (section.id.startsWith('project-')) {
				const p = section.data as Project;
				if (p.backgrounds && p.backgrounds.length > 0) {
					urls.push(p.backgrounds[0].value);
					if (p.backgrounds.length > 1) urls.push(p.backgrounds[1].value);
				}
				p.cards.forEach(card => {
					if (card.cardImage) urls.push(card.cardImage);
				});
			}
			return urls.filter(Boolean);
		},
	};

	function handleAnimationComplete() {
		const nextNeighborIndex = get(currentSectionIndex) + 2;
		if(nextNeighborIndex < allSectionsData.length) {
			preloadManager.prepareSection(nextNeighborIndex);
		}
	}

	async function handleVisibilityChange() {
		const currentIndex = get(currentSectionIndex);
		const currentInstance = sectionInstances.get(allSectionsData[currentIndex].id);
		if (!currentInstance) return;
		if (document.hidden) {
			visibilityHideTimeoutId = window.setTimeout(() => {
				if (document.hidden && !isTabHiddenAndPaused) {
					currentInstance.onLeaveSection();
					isTabHiddenAndPaused = true;
				}
			}, HIDE_BUFFER_DURATION);
		} else {
			clearTimeout(visibilityHideTimeoutId);
			if (isTabHiddenAndPaused) {
				if (currentInstance.onUnload && currentInstance.initializeEffect) {
					currentInstance.onUnload();
					await currentInstance.initializeEffect();
				}
				currentInstance.onEnterSection();
				requestAnimationFrame(() => {
					currentInstance.onTransitionComplete?.();
				});
				isTabHiddenAndPaused = false;
				preloadManager.updateNeighborStates(currentIndex);
			}
		}
	}

	onMount(() => {
		const mountLogic = async () => {
			await tick();
			// --- HASH NAVIGATION: capture initial hash (without leading '#') ---
			if (typeof window !== 'undefined') {
				const raw = window.location.hash?.trim();
				if (raw && raw.length > 1) {
					const fragment = decodeURIComponent(raw.substring(1));
					// Store temporarily; we'll map to index after sections array is ready
					initialHashFragment = fragment;
				}
			}

			// Determine deep link target before preparing sections
			if (initialHashFragment && initialHashFragment !== 'hero') {
				initialHashTargetIndex = allSectionsData.findIndex(s => s.id === initialHashFragment);
				if (initialHashTargetIndex !== -1 && initialHashTargetIndex !== 0) {
					startOnHero = false;
					isDeepLinkStart = true;
					showLoadingScreen = false; // suppress overlay
				}
			}
      
				sectionStatesStore.set(new Array(allSectionsData.length).fill('IDLE'));
			sectionElements = allSectionsData.map(section => document.getElementById(section.id) as HTMLElement);

				sectionElements.forEach((sectionEl, index) => {
				const sectionData = allSectionsData[index];
				if (sectionData.id.startsWith('project-')) {
					const bgTarget = sectionEl.querySelector('.background-zoom-target') as HTMLElement;
					sectionBackgroundZooms[index] = bgTarget ? gsap.to(bgTarget, { scale: 1.08, duration: projectBgZoomDuration, ease: 'power1.out', paused: true }) : null;
				}
					// Default positioning assumes hero start; override later for deep link
					gsap.set(sectionEl, { yPercent: index === 0 ? 0 : 100, autoAlpha: index === 0 ? 1 : 0 });
			});

				if (!isDeepLinkStart) {
					// Standard hero start
					setActiveSectionInert(0);
					announceSection(0);
				} else if (initialHashTargetIndex && initialHashTargetIndex > 0) {
					// Deep link fast path: position target section immediately
					const targetIdx = initialHashTargetIndex;
					sectionElements.forEach((el, idx) => {
						if (!el) return;
						if (idx === targetIdx) {
							gsap.set(el, { yPercent: 0, autoAlpha: 1 });
						} else {
							gsap.set(el, { yPercent: 100, autoAlpha: 0 });
						}
					});
					currentSectionIndex.set(targetIdx);
					navActiveIndex.set(targetIdx);
					setActiveSectionInert(targetIdx);
					announceSection(targetIdx);
					// Kick section instance lifecycle
					const secId = allSectionsData[targetIdx].id;
					const inst = sectionInstances.get(secId);
					inst?.onEnterSection();
					requestAnimationFrame(() => inst?.onTransitionComplete?.());
				}

			const setupInitialLoad = async () => {
				if (!isDeepLinkStart) {
					await Promise.all([heroReadyPromise, preloadManager.prepareSection(1)]);
					preloadManager.updateNeighborStates(0);
					initialSiteLoadComplete.set(true);
				} else if (initialHashTargetIndex && initialHashTargetIndex > 0) {
					// Preload neighbors of target section instead of hero neighbors
					const t = initialHashTargetIndex;
					const preloadPromises: Promise<void>[] = [];
					if (t - 1 >= 0) preloadPromises.push(preloadManager.prepareSection(t - 1));
					if (t + 1 < allSectionsData.length) preloadPromises.push(preloadManager.prepareSection(t + 1));
					await Promise.all(preloadPromises);
					preloadManager.updateNeighborStates(t);
					initialSiteLoadComplete.set(true);
					// Immediately end initial reveal state
					isInitialReveal.set(false);
				}
			};

			setupInitialLoad();

			onHashChange = () => {
				if (suppressNextHashUpdate) { suppressNextHashUpdate = false; return; }
				if (get(isInitialReveal) || get(isAnimating)) return; // ignore during reveal/animation
				const raw = window.location.hash?.trim();
				if (raw && raw.length > 1) {
					const fragment = decodeURIComponent(raw.substring(1));
					const idx = allSectionsData.findIndex(s => s.id === fragment);
					if (idx >= 0) navigateToSection(idx);
				} else {
					// Empty hash -> go back to hero
					if (get(currentSectionIndex) !== 0) navigateToSection(0);
				}
			};
			window.addEventListener('hashchange', onHashChange);

			if (!get(renderProfile).isMobile) {
				window.addEventListener('wheel', handleWheel, { passive: false });
				window.addEventListener('keydown', handleKeyDown);
			}
			document.addEventListener('visibilitychange', handleVisibilityChange);
		};

		mountLogic();
    
	unsubInitialLoadComplete = initialSiteLoadComplete.subscribe(complete => {
		if (!startOnHero) return; // deep link path handles its own reveal
		if (complete && !hasStartedInitialReveal) startInitialReveal();
	});

		return () => {
			if (!get(renderProfile).isMobile) {
				window.removeEventListener('wheel', handleWheel);
				window.removeEventListener('keydown', handleKeyDown);
			}
			document.removeEventListener('visibilitychange', handleVisibilityChange);
			if (onHashChange) window.removeEventListener('hashchange', onHashChange);
			if (unsubInitialLoadComplete) unsubInitialLoadComplete();
			sectionBackgroundZooms.forEach(tween => tween?.kill());
			clearTimeout(visibilityHideTimeoutId);
			if (wheelUnlockTimer !== null) {
				clearTimeout(wheelUnlockTimer);
				wheelUnlockTimer = null;
				wheelGestureLocked = false;
			}
		};
	});

	function onParticleEffectReady() {
		if (heroReadyResolver) heroReadyResolver();
	}

	function startInitialReveal() {
		if (hasStartedInitialReveal) return;
		hasStartedInitialReveal = true;

		setTimeout(() => {
			if (heroSectionInstance) {
				heroSectionInstance.onTransitionToHeroComplete();
				preloadManager.prepareSection(2);
			}
			setTimeout(() => { isInitialReveal.set(false); }, particleFadeInDuration * 1000);
		}, initialRevealDelay);
	}
  
	function navigateToSection(newIndex: number) { 
		if (get(isInitialReveal)) return; 
		const oldIndex = get(currentSectionIndex); 
		if (get(isAnimating) || newIndex === oldIndex || newIndex < 0 || newIndex >= sectionElements.length) return; 
		// Update dots immediately to animate grow/shrink during transition
		navActiveIndex.set(newIndex);
    
		isAnimating.set(true); 
		isTransitioning.set(true); 

		if (oldIndex === 0 && newIndex > 0) {
			isLeavingHero.set(true);
		}

		const oldInstance = sectionInstances.get(allSectionsData[oldIndex].id);
		const newInstance = sectionInstances.get(allSectionsData[newIndex].id);
    
		oldInstance?.onLeaveSection();
		sectionBackgroundZooms[oldIndex]?.progress(0).pause();
		newInstance?.onEnterSection();

		const currentSectionEl = sectionElements[oldIndex]; 
		const targetSectionEl = sectionElements[newIndex]; 
		const direction = newIndex > oldIndex ? 1 : -1; 
    
		const masterTransitionTl = gsap.timeline({ 
			onComplete: () => { 
				currentSectionIndex.set(newIndex); 
				isTransitioning.set(false);
				isLeavingHero.set(false);
				preloadManager.updateNeighborStates(newIndex);
				requestAnimationFrame(() => newInstance?.onTransitionComplete?.());
				if (allSectionsData[newIndex].id === 'hero' && heroSectionInstance) {
					 heroSectionInstance.onTransitionToHeroComplete();
				}
				// Manage focus and inert after transition completes
				setActiveSectionInert(newIndex);
				focusSection(newIndex);
				announceSection(newIndex);
			} 
		}); 
    
		gsap.set(targetSectionEl, { yPercent: direction * 100, autoAlpha: 1 }); 
		masterTransitionTl.to(currentSectionEl, { yPercent: -direction * 100, autoAlpha: 0, duration: transitionDuration, ease: 'expo.out' }, "slide"); 
		masterTransitionTl.to(targetSectionEl, { yPercent: 0, duration: transitionDuration, ease: 'expo.out' }, "slide"); 
    
    masterTransitionTl.call(() => {
				sectionBackgroundZooms[newIndex]?.restart();
		}, [], `slide+=${transitionDuration * 0.1}`);

		gsap.delayedCall(Math.max(transitionDuration, minSectionDisplayDuration), () => { 
			isAnimating.set(false); 
			// After animation complete, update hash (avoid doing for hero index 0 to keep URL clean?)
			const id = allSectionsData[newIndex].id;
			if (typeof window !== 'undefined') {
				// Option: keep hero clean; only set when not hero
				if (id === 'hero') {
					suppressNextHashUpdate = true;
					if (window.location.hash) history.replaceState(null, '', window.location.pathname + window.location.search);
				} else {
					suppressNextHashUpdate = true;
					const newHash = '#' + encodeURIComponent(id);
					if (window.location.hash !== newHash) {
						history.replaceState(null, '', newHash);
					}
				}
			}
		}); 
	}

	// Mobile navigation wrapper: optional haptic feedback
	function tryVibrate(duration = 15) {
		// Basic feature detection; most mobile browsers ignore silently if unsupported
		try {
			if (navigator && 'vibrate' in navigator) {
				// @ts-ignore - vibrate may not be in lib.dom.d.ts for all targets
				navigator.vibrate?.(duration);
			}
		} catch {}
	}
	function mobileNavigateTo(newIndex: number, _cause: 'swipe'|'dot') {
		if (!get(renderProfile).isMobile) return navigateToSection(newIndex);
		tryVibrate(15);
	    navigateToSection(newIndex);
	}

		let lastScrollTime = 0; // still used for keyboard debounce
		const scrollDebounce = 200;

		// Touchpad-friendly wheel gesture lock: one move per gesture
		const WHEEL_NOISE_THRESH = 2; // ignore tiny deltas/noise
		const WHEEL_LOCK_DURATION = Math.max(transitionDuration, minSectionDisplayDuration) * 1000 + 150; // ~1.35s
		// After unlock, briefly require higher delta to allow a second transition from the same ongoing gesture
		const SECONDARY_MIN_DELTA = 30; // px, only for a potential second transition
		const SECONDARY_WINDOW_MS = 600; // window right after unlock
		let wheelGestureLocked = false;
		let wheelUnlockTimer: number | null = null;
		let unlockAt = 0; // timestamp when wheel unlocks
		let lastWheelDir = 0; // direction of last triggered transition
		function handleWheel(event: WheelEvent) {
			event.preventDefault();
			if (get(isInitialReveal)) return;
			// Respect active animation; otherwise use our gesture lock
			if (get(isAnimating)) return;
			if (wheelGestureLocked) return;

			const now = Date.now();
			const dir = event.deltaY > 0 ? 1 : -1;
			const absDelta = Math.abs(event.deltaY);

			// Dynamic threshold: right after unlock, require a much larger delta (same direction)
			const withinSecondaryWindow = unlockAt && (now - unlockAt < SECONDARY_WINDOW_MS);
			const needsHigherThreshold = withinSecondaryWindow && dir === lastWheelDir;
			const minDelta = needsHigherThreshold ? Math.max(WHEEL_NOISE_THRESH, SECONDARY_MIN_DELTA) : WHEEL_NOISE_THRESH;
			if (absDelta < minDelta) return;

			// Lock for the duration of the transition
			wheelGestureLocked = true;
			if (wheelUnlockTimer === null) {
				wheelUnlockTimer = window.setTimeout(() => {
					wheelGestureLocked = false;
					wheelUnlockTimer = null;
					unlockAt = Date.now();
				}, WHEEL_LOCK_DURATION);
			}

			lastWheelDir = dir;
			navigateToSection(get(currentSectionIndex) + dir);
		}
	function handleKeyDown(event: KeyboardEvent) { if (get(isInitialReveal) || get(isAnimating)) { if (['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', ' ', 'Home', 'End'].includes(event.key)) event.preventDefault(); return; } const currentTime = Date.now(); if (currentTime - lastScrollTime < scrollDebounce) { if (['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', ' ', 'Home', 'End'].includes(event.key)) event.preventDefault(); return; } let newIndex = get(currentSectionIndex); let shouldScroll = false; switch (event.key) { case 'ArrowDown': case 'PageDown': case ' ': newIndex++; shouldScroll = true; break; case 'ArrowUp': case 'PageUp': newIndex--; shouldScroll = true; break; case 'Home': newIndex = 0; shouldScroll = true; break; case 'End': newIndex = sectionElements.length - 1; shouldScroll = true; break; } if (shouldScroll && newIndex !== get(currentSectionIndex)) { event.preventDefault(); lastScrollTime = currentTime; navigateToSection(newIndex); } }

	// --- Mobile swipe detection (no drag-follow, swipe triggers only) ---
	let touchStartY = 0;
	let touchStartX = 0;
	let touchStartTime = 0;
	const SWIPE_DIST = 70; // px
	const SWIPE_VELOCITY = 0.35; // px/ms
	const HORIZ_DEADZONE = 60; // px, ignore if mostly horizontal

		function onTouchStart(e: TouchEvent) {
			if (!get(renderProfile).isMobile || get(isInitialReveal) || get(isAnimating)) return;
		const t = e.changedTouches[0];
		touchStartY = t.clientY;
		touchStartX = t.clientX;
		touchStartTime = performance.now();
	}
		function onTouchEnd(e: TouchEvent) {
			if (!get(renderProfile).isMobile || get(isInitialReveal) || get(isAnimating)) return;
		const t = e.changedTouches[0];
		const dy = t.clientY - touchStartY;
		const dx = t.clientX - touchStartX;
		const dt = Math.max(1, performance.now() - touchStartTime);
		if (Math.abs(dx) > HORIZ_DEADZONE) return; // likely horizontal gesture (e.g., carousels)
		const v = Math.abs(dy) / dt; // px/ms
			if (Math.abs(dy) > SWIPE_DIST || v > SWIPE_VELOCITY) {
				const dir = dy < 0 ? 1 : -1; // swipe up -> next
				mobileNavigateTo(get(currentSectionIndex) + dir, 'swipe');
			}
	}
</script>

<svelte:head>
	<title>{siteConfig.title}</title>
	<meta name="description" content={siteConfig.description} />
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400..900&display=swap" rel="stylesheet">
</svelte:head>

<div>
	<!-- Visually hidden live region for announcing section changes -->
	<div aria-live="polite" aria-atomic="true" class="sr-only">{liveMessage}</div>
	{#if showLoadingScreen}
		<LoadingScreen />
	{/if}

	<div 
		class="particle-effect-layer" 
		class:initial-state={$isInitialReveal}
		class:on-top={$isLeavingHero}
		style="pointer-events: {particleLayerPointerEvents};"
		on:touchstart|passive={onTouchStart}
		on:touchend|passive={onTouchEnd}
	>
			<HeroSection
			bind:this={heroSectionInstance}
				activeSectionIndex={$currentSectionIndex}
			isTransitioning={$isTransitioning}
			{transitionDuration}
			isInitialLoad={$isInitialReveal}
			on:ready={onParticleEffectReady}
		/>
	</div>

		<main
			class="portfolio-container"
			style="pointer-events: {mainContainerPointerEvents};"
			on:touchstart|passive={onTouchStart}
			on:touchend|passive={onTouchEnd}
		>
		<section id="hero" class="full-screen-section hero-section-container">
			<div class="section-focus-sentinel sr-only" tabindex="-1" aria-label="Start of hero section"></div>
		</section>

		{#each allSectionsData.slice(1) as section, i (section.id)}
			<section 
				id={section.id} 
				class="full-screen-section"
			>
				<!-- Invisible sentinel for accessible, non-distracting programmatic focus -->
				<div class="section-focus-sentinel sr-only" tabindex="-1" aria-label={`Start of ${section.id} section`}></div>
				{#if section.id === 'about'}
					<AboutSection
						bind:this={sectionInstancesArray[i + 1]}
					data={aboutData}
						{contactSectionIndex}
						{navigateToSection}
						on:animationComplete={handleAnimationComplete}
					/>
						{:else if section.id.startsWith('project-')}
					<ProjectSection
						bind:this={sectionInstancesArray[i + 1]}
						project={section.data as Project}
						on:animationComplete={handleAnimationComplete}
					>
						<svelte:component 
							this={section.layout} 
									{...(section.data as Project)}
									readMoreFallbackLabel={(($page.data as any)?.messages?.common?.projects?.readMore) ?? undefined}
						/>
					</ProjectSection>
				{:else if section.id === 'contact'}
								<ContactSection
						bind:this={sectionInstancesArray[i + 1]}
									data={contactData}
								emailLabel={(($page.data as any)?.messages?.common?.contact?.emailLabel) ?? undefined}
						on:animationComplete={handleAnimationComplete}
					/>
				{/if}
			</section>
		{/each}
			{#if get(renderProfile).isMobile}
				<MobileNavDots
					sections={allSectionsData.map(s => ({ id: s.id, label: s.id }))}
					activeIndex={$navActiveIndex}
					on:select={(e) => mobileNavigateTo(e.detail.index, 'dot')}
				/>
			{/if}
		</main>

  

	<style>
		.particle-effect-layer { 
			position: fixed; 
			top: 0; 
			left: 0; 
			width: 100vw; 
			height: 100vh; 
			z-index: 0; /* Default state: behind main content */
			background-color: rgb(9 9 11); 
			transition: opacity 1.5s cubic-bezier(0.4, 0.2, 1); 
		}

		/* --- START OF FIX --- */
		/* This class is now applied only when transitioning away from the hero section. */
		.particle-effect-layer.on-top {
			z-index: 2; /* Promoted state: on top of main content */
			background-color: transparent; /* Makes the layer see-through, leaving only the particles. */
		}
		/* --- END OF FIX --- */

		.particle-effect-layer.initial-state { background-color: rgb(5 8 5); }
		.portfolio-container { 
			position: relative; 
			width: 100%; 
			height: 100vh; 
			overflow: hidden; 
			z-index: 1; /* Default state: on top of hero particles */
		}
    
		.full-screen-section {
			height: 100%;
			width: 100%;
			position: absolute;
			top: 0;
			left: 0;
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			box-sizing: border-box;
			background-color: transparent; 
		}

		.hero-section-container {
			pointer-events: none;
		}
    
		* { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }

		/* Screen reader only (visually hidden) */
		.sr-only {
			border: 0 !important;
			clip: rect(1px, 1px, 1px, 1px) !important;
			clip-path: inset(50%) !important;
			height: 1px !important;
			margin: -1px !important;
			overflow: hidden !important;
			padding: 0 !important;
			position: absolute !important;
			width: 1px !important;
			white-space: nowrap !important;
		}

		/* Focus sentinel inherits sr-only; ensure no outline flicker */
		.section-focus-sentinel:focus { outline: none; }
	</style>

  
</div>

--- END OF FILE src\routes\[lang=lang]\+page.svelte ---

--- START OF FILE src\routes\[lang=lang]\accessibility\+page.svelte ---
<script lang="ts">
  import { page } from '$app/stores';
  import BackButton from '$lib/components/BackButton.svelte';
  $: currentLang = $page.params.lang === 'de' ? 'de' : 'en';
  const lastUpdatedISO = '2025-09-16';
  const lastUpdatedText = 'September 16, 2025';
</script>

<svelte:head>
  <title>Accessibility</title>
  <meta name="description" content="Accessibility statement: focus management, live announcements, reduced motion support, hidden decorative canvases, semantic structure, locale-aware routing, and ongoing improvements." />
  <link rel="alternate" hreflang="en" href="/en/accessibility" />
  <link rel="alternate" hreflang="de" href="/de/barrierefreiheit" />
</svelte:head>

<main class="legal-page">
  <BackButton />
  <article class="legal-article" lang="en" aria-labelledby="a11y-heading">
    <header class="article-header">
      <h1 id="a11y-heading">Accessibility Statement</h1>
  <p class="last-updated"><strong>Last Updated:</strong> <time datetime={lastUpdatedISO}>{lastUpdatedText}</time></p>
      <p class="intro">I’m committed to making this site usable by as many people as possible. This is an immersive, highly visual portfolio with animated transitions and WebGL effects; I actively design and test with accessibility in mind and iterate continuously.</p>
    </header>

    <section id="conformance" class="legal-section" aria-labelledby="conformance-heading">
      <h2 id="conformance-heading">Conformance status</h2>
      <p>This is a self-assessed accessibility statement; no formal third-party evaluation has been conducted.</p>
      <p>This website is partially conformant with the Web Content Accessibility Guidelines Version 2.1 at Level AA (WCAG 2.1 AA). "Partially conformant" means that some parts of the content do not fully conform to the accessibility standard. Given the interactive and visually complex nature of this portfolio, I am prioritizing improvements that most directly impact screen reader users, keyboard-only users, and visitors with motion sensitivity.</p>
    </section>

    <section id="measures" class="legal-section" aria-labelledby="measures-heading">
      <h2 id="measures-heading">Measures in place</h2>

      <section id="focus-management" class="sub-section" aria-labelledby="focus-management-heading">
        <h3 id="focus-management-heading">Robust focus management</h3>
        <p>During section transitions, keyboard focus is programmatically moved to the most relevant element in the new section. All off-screen sections are temporarily set <code>inert</code> to avoid focus traps and ensure a single, clear reading order.</p>
      </section>

      <section id="live-announcements" class="sub-section" aria-labelledby="live-announcements-heading">
        <h3 id="live-announcements-heading">Live announcements for content changes</h3>
        <p>A visually hidden <code>aria-live</code> region announces the current section title after transitions and on initial load, so screen reader users are notified without needing to explore manually.</p>
      </section>

      <section id="reduced-motion" class="sub-section" aria-labelledby="reduced-motion-heading">
        <h3 id="reduced-motion-heading">Motion preference support</h3>
        <p>When <code>prefers-reduced-motion</code> is enabled: immersive WebGL/GSAP effects are paused or disabled (including the hero particles, the About image effect, and the Contact raymarching scene); page transitions are simplified and shortened. If you change this preference while the site is open, the effects respond immediately without reloading.</p>
      </section>

      <section id="decorative-effects" class="sub-section" aria-labelledby="decorative-effects-heading">
        <h3 id="decorative-effects-heading">Decorative effects hidden from assistive tech</h3>
        <p>WebGL canvases used for purely visual atmosphere (Three.js) are removed from the accessibility tree with <code>aria-hidden="true"</code>, <code>role="presentation"</code>, and <code>tabindex="-1"</code>.</p>
      </section>

      <section id="semantics" class="sub-section" aria-labelledby="semantics-heading">
        <h3 id="semantics-heading">Correct semantic structure</h3>
        <p>Headings form a logical outline (e.g., section titles use <code>h2</code>, subheadings use <code>h3</code>), improving navigation for assistive technologies that rely on heading shortcuts.</p>
      </section>

      <section id="i18n" class="sub-section" aria-labelledby="i18n-heading">
        <h3 id="i18n-heading">Accessible internationalization and URL mapping</h3>
        <p>The language switcher is operable with keyboard, conveys state, preserves focus on change, and maps localized slugs (e.g., <code>/en/privacy</code> ↔ <code>/de/datenschutz</code>; <code>/en/imprint</code> ↔ <code>/de/impressum</code>; <code>/en/accessibility</code> ↔ <code>/de/barrierefreiheit</code>) while preserving query and hash.</p>
      </section>

      <section id="scroll" class="sub-section" aria-labelledby="scroll-heading">
        <h3 id="scroll-heading">Predictable scroll behavior</h3>
        <p>The immersive home uses a controlled section navigator; legal and content subpages use native vertical scrolling to ensure compatibility with assistive technologies.</p>
      </section>
    </section>

    <section id="known-limitations" class="legal-section" aria-labelledby="known-limitations-heading">
      <h2 id="known-limitations-heading">Known limitations</h2>
      <ul class="rights-list">
        <li><strong>Complex visual effects:</strong> While decorative and hidden from assistive tech, WebGL effects may distract some users. Enabling reduced motion helps tone down visuals. I’m planning a site control to pause animations.</li>
        <li><strong>Reduced‑motion coverage:</strong> All major immersive WebGL effects now pause/disable under reduced motion; a few brief micro‑animations may still play. I’m continuing to audit and simplify remaining motion.</li>
        <li><strong>Alternative descriptions for media:</strong> Static images have alt text; I continue to review descriptive quality, especially for project imagery that conveys meaning.</li>
      </ul>
    </section>

    <section id="feedback" class="legal-section" aria-labelledby="feedback-heading">
      <h2 id="feedback-heading">Feedback and contact</h2>
  <p>If you encounter any accessibility barriers not listed here, please contact me:</p>
  <p>Email: <a class="link" href="mailto:mika38159@gmail.com">mika38159@gmail.com</a>. I aim to respond within 5 business days.</p>
    </section>

    <section id="technical" class="legal-section" aria-labelledby="technical-heading">
      <h2 id="technical-heading">Technical specifications</h2>
      <p>Accessibility relies on HTML, CSS, JavaScript, and WAI‑ARIA. The site is built with SvelteKit and Three.js; progressive enhancement is used so content remains available even if advanced effects are disabled.</p>
    </section>

    <section id="ongoing" class="legal-section" aria-labelledby="ongoing-heading">
      <h2 id="ongoing-heading">Ongoing improvements</h2>
      <ul class="rights-list">
        <li>Broader reduced‑motion support for all continuous animations (including WebGL particle/raymarching effects).</li>
        <li>A “Pause animations” control to pause/stop decorative effects beyond system preferences.</li>
        <li>Periodic keyboard‑only and screen reader walkthroughs to catch regressions.</li>
        <li>Image alt text and link purpose reviews on new content.</li>
      </ul>
    </section>
    <footer class="article-footer">
      <button class="back" on:click={() => (location.href = `/${currentLang}`)} aria-label="Back to homepage">Back to homepage</button>
    </footer>
  </article>
  
</main>

<style>
  .legal-page { min-height: 100vh; padding: clamp(1.5rem, 3vw, 3rem); color: var(--legal-fg, #fafafa); background: radial-gradient(circle at 30% 20%, #111 0%, #0a0a0b 60%, #050506 100%); overflow-y: auto; }
  .legal-article { max-width: 75ch; margin: 0 auto; line-height: 1.55; font-size: 1rem; }
  .article-header { margin-bottom: 2.25rem; }
  h1 { font-size: clamp(2.2rem, 5vw, 3.1rem); line-height: 1.1; letter-spacing: -0.5px; margin: 0 0 0.75rem; }
  h2 { font-size: clamp(1.45rem, 3vw, 2rem); margin: 2.5rem 0 1rem; line-height: 1.2; position: relative; }
  h3 { font-size: 1.05rem; margin: 1.75rem 0 0.65rem; letter-spacing: 0.3px; }
  p, li { color: rgba(255,255,255,0.85); }
  p { margin: 0 0 1.15rem; }
  .intro { font-size: 1.05rem; }
  .last-updated { margin: 0 0 1.1rem; color: rgba(255,255,255,0.65); font-size: 0.9rem; }
  .rights-list { list-style: disc; padding-left: 1.2rem; margin: 0 0 1.5rem; }
  .rights-list li { margin: 0 0 0.4rem; }
  code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; background: rgba(255,255,255,0.08); padding: 0.15rem 0.4rem; border-radius: 4px; font-size: 0.85em; }
  .link { color: #82d6ff; text-decoration: underline; text-underline-offset: 2px; }
  .link:hover, .link:focus-visible { color: #b5e7ff; }
  .article-footer { margin-top: 3rem; display: flex; justify-content: flex-start; }
  .back { background: linear-gradient(145deg, #1d1f21, #2a2d31); border: 1px solid rgba(255,255,255,0.12); color: #fff; padding: 0.7rem 1.1rem; border-radius: 10px; cursor: pointer; font-size: 0.95rem; letter-spacing: 0.3px; transition: background .25s, transform .25s; }
  .back:hover, .back:focus-visible { background: linear-gradient(145deg, #303438, #353a40); outline: none; }
  .back:active { transform: translateY(2px); }
  a:focus-visible, .back:focus-visible { box-shadow: 0 0 0 3px rgba(130,214,255,0.45), 0 0 0 6px rgba(130,214,255,0.15); border-radius: 6px; }
  @media (max-width: 680px) {
    .legal-article { font-size: 0.96rem; }
    h2 { margin-top: 2rem; }
    h3 { margin-top: 1.2rem; }
    .article-footer { margin-top: 2.2rem; }
  }
</style>

--- END OF FILE src\routes\[lang=lang]\accessibility\+page.svelte ---

--- START OF FILE src\routes\[lang=lang]\barrierefreiheit\+page.svelte ---
<script lang="ts">
  import { transitionStore } from '$lib/stores/transitionStore';
  import BackButton from '$lib/components/BackButton.svelte';
  // Deutschsprachige Seite (englisches Pendant unter /en/accessibility)
  const lang: 'de' = 'de';
  function backHome() { transitionStore.fadeToBlackAndNavigate(`/${lang}`); }
  const lastUpdatedISO = '2025-09-16';
  const lastUpdatedText = '16.09.2025';
</script>

<svelte:head>
  <title>Barrierefreiheit</title>
  <meta name="description" content="Erklärung zur Barrierefreiheit: Fokusmanagement, Live-Regionen, Unterstützung von reduzierten Bewegungen, ausgeblendete dekorative WebGL-Canvas, semantische Struktur, sprachsensitive URLs und laufende Verbesserungen." />
  <link rel="alternate" hreflang="de" href="/de/barrierefreiheit" />
  <link rel="alternate" hreflang="en" href="/en/accessibility" />
</svelte:head>

<main class="legal-page">
  <BackButton />
  <article class="legal-article" lang="de" aria-labelledby="a11y-heading-de">
    <header class="article-header">
      <h1 id="a11y-heading-de">Erklärung zur Barrierefreiheit</h1>
  <p class="last-updated"><strong>Stand:</strong> <time datetime={lastUpdatedISO}>{lastUpdatedText}</time></p>
      <p class="intro">Ich möchte diese Seite für möglichst viele Menschen nutzbar machen. Es handelt sich um ein immersives, visuell geprägtes Portfolio mit animierten Übergängen und WebGL‑Effekten; ich gestalte und teste mit Blick auf Barrierefreiheit und entwickle kontinuierlich weiter.</p>
    </header>

    <section id="konformitaet" class="legal-section" aria-labelledby="konformitaet-heading">
      <h2 id="konformitaet-heading">Konformitätsstatus</h2>
      <p>Dies ist eine selbsteingeschätzte Barrierefreiheits­erklärung; es wurde keine formale, externe Bewertung durchgeführt.</p>
      <p>Diese Website ist <strong>teilweise konform</strong> mit den Web Content Accessibility Guidelines in der Version 2.1 auf Stufe AA (WCAG 2.1 AA). „Teilweise konform“ bedeutet, dass einige Teile der Inhalte den Standard noch nicht vollständig erfüllen. Angesichts des interaktiven und visuell komplexen Charakters dieses Portfolios priorisiere ich Verbesserungen, die Screenreader‑Nutzer:innen, reine Tastaturnutzung und Personen mit Bewegungssensibilität am direktesten unterstützen.</p>
    </section>

    <section id="massnahmen" class="legal-section" aria-labelledby="massnahmen-heading">
      <h2 id="massnahmen-heading">Umgesetzte Maßnahmen</h2>

      <section id="fokusmanagement" class="sub-section" aria-labelledby="fokusmanagement-heading">
        <h3 id="fokusmanagement-heading">Robustes Fokusmanagement</h3>
        <p>Während Abschnittsübergängen wird der Tastaturfokus gezielt auf das relevanteste Element des neuen Abschnitts gesetzt. Außerhalb des Bildschirms liegende Bereiche werden vorübergehend <code>inert</code>, um Fokusfallen zu vermeiden und eine eindeutige Lesereihenfolge sicherzustellen.</p>
      </section>

      <section id="live-ankuendigungen" class="sub-section" aria-labelledby="live-ankuendigungen-heading">
        <h3 id="live-ankuendigungen-heading">Live‑Ankündigungen von Inhaltsänderungen</h3>
        <p>Eine visuell verborgene <code>aria-live</code>-Region kündigt nach Übergängen (und beim ersten Laden) den Titel des aktuellen Abschnitts an, sodass Screenreader‑Nutzer:innen nicht aktiv nach Änderungen suchen müssen.</p>
      </section>

      <section id="reduzierte-bewegung" class="sub-section" aria-labelledby="reduzierte-bewegung-heading">
        <h3 id="reduzierte-bewegung-heading">Unterstützung für reduzierte Bewegungen</h3>
        <p>Wenn <code>prefers-reduced-motion</code> aktiviert ist, werden immersive WebGL‑/GSAP‑Effekte angehalten oder deaktiviert (einschließlich der Partikel im Hero, des Bild‑Effekts im About‑Bereich und der Raymarching‑Szene im Kontaktbereich); Seitenübergänge werden vereinfacht und verkürzt. Eine Änderung der Systemeinstellung greift sofort, ohne die Seite neu zu laden.</p>
      </section>

      <section id="dekorative-effekte" class="sub-section" aria-labelledby="dekorative-effekte-heading">
        <h3 id="dekorative-effekte-heading">Dekorative Effekte aus dem Zugänglichkeitsbaum entfernt</h3>
        <p>Für rein visuelle Atmosphäre eingesetzte WebGL‑Canvas (Three.js) sind mit <code>aria-hidden="true"</code>, <code>role="presentation"</code> und <code>tabindex="-1"</code> aus dem Zugänglichkeitsbaum entfernt.</p>
      </section>

      <section id="semantik" class="sub-section" aria-labelledby="semantik-heading">
        <h3 id="semantik-heading">Korrekte semantische Struktur</h3>
        <p>
          Überschriften bilden eine logische Gliederung (z. B. Abschnittstitel als <code>h2</code>, Untertitel als <code>h3</code>), was die Navigation über Screenreader‑Kurzbefehle verbessert.
        </p>
      </section>

      <section id="i18n" class="sub-section" aria-labelledby="i18n-heading">
        <h3 id="i18n-heading">Zugängliche Internationalisierung & URL‑Abbildung</h3>
        <p>Der Sprachwechsel ist per Tastatur bedienbar, übermittelt seinen Zustand, erhält den Fokus und bildet lokalisierte Slugs korrekt ab (z. B. <code>/en/privacy</code> ↔ <code>/de/datenschutz</code>; <code>/en/imprint</code> ↔ <code>/de/impressum</code>; <code>/en/accessibility</code> ↔ <code>/de/barrierefreiheit</code>). Query und Hash bleiben erhalten.</p>
      </section>

      <section id="scroll" class="sub-section" aria-labelledby="scroll-heading">
        <h3 id="scroll-heading">Vorhersehbares Scrollverhalten</h3>
        <p>Die Startseite nutzt einen gesteuerten Abschnittsnavigator; Unterseiten (z. B. rechtliche Inhalte) verwenden nativen, vertikalen Scroll, um Kompatibilität mit Hilfstechnologien sicherzustellen.</p>
      </section>
    </section>

    <section id="einschraenkungen" class="legal-section" aria-labelledby="einschraenkungen-heading">
      <h2 id="einschraenkungen-heading">Bekannte Einschränkungen</h2>
      <ul class="rights-list">
        <li><strong>Komplexe visuelle Effekte:</strong> Obwohl dekorativ und für Hilfstechnologien ausgeblendet, können WebGL‑Effekte manche Nutzer:innen ablenken. Die Einstellung „Bewegung reduzieren“ dämpft die Effekte. Geplant ist eine Seitenschaltfläche, um Animationen zusätzlich zu pausieren.</li>
        <li><strong>Abdeckung für reduzierte Bewegung:</strong> Alle größeren immersiven WebGL‑Effekte werden inzwischen bei reduzierter Bewegung pausiert/deaktiviert; einzelne kurze Mikroanimationen können noch auftreten. Ich vereinfache verbleibende Bewegungen schrittweise weiter.</li>
        <li><strong>Alternative Beschreibungen für Medien:</strong> Statische Bilder besitzen Alt‑Texte; ich verbessere die Beschreibungsqualität fortlaufend, insbesondere bei Projektdarstellungen mit inhaltlicher Bedeutung.</li>
      </ul>
    </section>

    <section id="feedback" class="legal-section" aria-labelledby="feedback-heading">
      <h2 id="feedback-heading">Feedback und Kontakt</h2>
  <p>Wenn Sie auf Barrieren stoßen, die hier nicht aufgeführt sind, melden Sie sich bitte:</p>
  <p>E‑Mail: <a class="link" href="mailto:mika38159@gmail.com">mika38159@gmail.com</a>. Ich versuche, innerhalb von 5 Werktagen zu antworten.</p>
    </section>

    <section id="technisch" class="legal-section" aria-labelledby="technisch-heading">
      <h2 id="technisch-heading">Technische Spezifikationen</h2>
      <p>Die Barrierefreiheit dieser Website basiert auf HTML, CSS, JavaScript und WAI‑ARIA. Die Seite ist mit SvelteKit und Three.js erstellt; durch progressive Enhancement bleiben Inhalte verfügbar, auch wenn erweiterte Effekte deaktiviert sind.</p>
    </section>

    <section id="fortlaufend" class="legal-section" aria-labelledby="fortlaufend-heading">
      <h2 id="fortlaufend-heading">Laufende Verbesserungen</h2>
      <ul class="rights-list">
        <li>Breitere Unterstützung für reduzierte Bewegung bei kontinuierlichen Animationen (inklusive WebGL‑Partikel/Raymarching).</li>
        <li>Ein Schalter „Animationen pausieren“ als zusätzliche Kontrolle unabhängig von Systemeinstellungen.</li>
        <li>Regelmäßige Tastatur‑ und Screenreader‑Überprüfungen, um Regressionen zu vermeiden.</li>
        <li>Laufende Prüfung von Alternativtexten und Linkzwecken bei neuen Inhalten.</li>
      </ul>
    </section>

    <footer class="article-footer">
      <button class="back" on:click={backHome} aria-label="Zurück zur Startseite">Zurück zur Startseite</button>
    </footer>
  </article>
</main>

<style>
  .legal-page { min-height: 100vh; padding: clamp(1.5rem, 3vw, 3rem); color: var(--legal-fg, #fafafa); background: radial-gradient(circle at 30% 20%, #111 0%, #0a0a0b 60%, #050506 100%); overflow-y: auto; }
  /* Defensive: falls der Body versehentlich gelockt wird, bleibt Scrollen möglich */
  :global(body) .legal-page { overflow-y: auto; }
  .legal-article { max-width: 75ch; margin: 0 auto; line-height: 1.55; font-size: 1rem; }
  .article-header { margin-bottom: 2.25rem; }
  h1 { font-size: clamp(2.2rem, 5vw, 3.1rem); line-height: 1.1; letter-spacing: -0.5px; margin: 0 0 0.75rem; }
  h2 { font-size: clamp(1.45rem, 3vw, 2rem); margin: 2.5rem 0 1rem; line-height: 1.2; position: relative; }
  h3 { font-size: 1.05rem; margin: 1.75rem 0 0.65rem; letter-spacing: 0.3px; }
  p, li { color: rgba(255,255,255,0.85); }
  p { margin: 0 0 1.15rem; }
  .intro { font-size: 1.05rem; }
  .last-updated { margin: 0 0 1.1rem; color: rgba(255,255,255,0.65); font-size: 0.9rem; }
  .rights-list { list-style: disc; padding-left: 1.2rem; margin: 0 0 1.5rem; }
  .rights-list li { margin: 0 0 0.4rem; }
  code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; background: rgba(255,255,255,0.08); padding: 0.15rem 0.4rem; border-radius: 4px; font-size: 0.85em; }
  .link { color: #82d6ff; text-decoration: underline; text-underline-offset: 2px; }
  .link:hover, .link:focus-visible { color: #b5e7ff; }
  .article-footer { margin-top: 3rem; display: flex; justify-content: flex-start; }
  .back { background: linear-gradient(145deg, #1d1f21, #2a2d31); border: 1px solid rgba(255,255,255,0.12); color: #fff; padding: 0.7rem 1.1rem; border-radius: 10px; cursor: pointer; font-size: 0.95rem; letter-spacing: 0.3px; transition: background .25s, transform .25s; }
  .back:hover, .back:focus-visible { background: linear-gradient(145deg, #303438, #353a40); outline: none; }
  .back:active { transform: translateY(2px); }
  a:focus-visible, .back:focus-visible { box-shadow: 0 0 0 3px rgba(130,214,255,0.45), 0 0 0 6px rgba(130,214,255,0.15); border-radius: 6px; }
  @media (max-width: 680px) {
    .legal-article { font-size: 0.96rem; }
    h2 { margin-top: 2rem; }
    h3 { margin-top: 1.2rem; }
    .article-footer { margin-top: 2.2rem; }
  }
</style>

--- END OF FILE src\routes\[lang=lang]\barrierefreiheit\+page.svelte ---

--- START OF FILE src\routes\[lang=lang]\datenschutz\+page.svelte ---
<script lang="ts">
  import { page } from '$app/stores';
  import { transitionStore } from '$lib/stores/transitionStore';
  import BackButton from '$lib/components/BackButton.svelte';

  // German-only page (English redirects handled in +page.ts)
  const lang: 'de' = 'de';
  function backHome() { transitionStore.fadeToBlackAndNavigate('/de'); }

  const title = 'Datenschutz';
  const backLabel = 'Zurück zur Startseite';
  const lastUpdatedISO = '2025-09-16';
  const lastUpdatedText = '16.09.2025';
</script>

<svelte:head>
  <title>{title}</title>
  <meta name="description" content="Datenschutzerklärung: Informationen zum Datenschutz, Server-Logs, Hosting, Cookies, Drittanbietern, E-Mail-Kontakt, externen Links und Ihren Rechten." />
  <!-- Allow indexing (remove robots noindex); add again if you prefer to hide legal pages -->
</svelte:head>

<main class="legal-page">
  <BackButton />
  <article class="legal-article" lang="de" aria-labelledby="privacy-policy-heading-de">
    <header class="article-header">
      <h1 id="privacy-policy-heading-de">Datenschutzerklärung</h1>
  <p class="last-updated"><strong>Stand:</strong> <time datetime={lastUpdatedISO}>{lastUpdatedText}</time></p>
      <p class="intro">Ich nehme den Schutz Ihrer persönlichen Daten sehr ernst. Nachfolgend informiere ich Sie ausführlich über den Umgang mit Ihren Daten beim Besuch dieser Webseite. Der Verantwortliche im Sinne der Datenschutz-Grundverordnung (DSGVO) bin ich:</p>
      <address class="controller-address" aria-label="Verantwortlicher">
        <p><span>Miká Müller</span><br />
        <span>Weinbergstraße 16a</span><br />
        <span>38159 Vechelde</span><br />
        <span>Deutschland</span></p>
        <p>E-Mail: <a href="mailto:mika38159@gmail.com" class="link">mika38159@gmail.com</a></p>
      </address>
    </header>

    <section id="datensicherheit" class="legal-section" aria-labelledby="datensicherheit-heading">
      <h2 id="datensicherheit-heading">1. Datensicherheit durch SSL/TLS-Verschlüsselung</h2>
      <p>Um die Sicherheit Ihrer Daten bei der Übertragung zu schützen, verwende ich eine SSL/TLS-Verschlüsselung. Eine verschlüsselte Verbindung erkennen Sie an dem Präfix <code>https://</code> in der Adresszeile Ihres Browsers sowie am Schloss-Symbol. Wenn die SSL- bzw. TLS-Verschlüsselung aktiviert ist, können die Daten, die Sie an mich übermitteln, nicht von Dritten mitgelesen werden.</p>
    </section>

    <section id="datenerfassung" class="legal-section" aria-labelledby="datenerfassung-heading">
      <h2 id="datenerfassung-heading">2. Datenerfassung auf dieser Webseite</h2>
      <section id="server-log-dateien" class="sub-section" aria-labelledby="server-log-dateien-heading">
        <h3 id="server-log-dateien-heading">a) Server-Log-Dateien</h3>
        <p>Bei jedem Aufruf meiner Webseite erfasst mein System bzw. der Hosting-Provider automatisiert Daten und Informationen vom Computersystem des aufrufenden Rechners.</p>
        <p>Folgende Daten werden hierbei erhoben:</p>
        <ul class="rights-list">
          <li>IP-Adresse des anfragenden Rechners</li>
          <li>Datum und Uhrzeit des Zugriffs</li>
          <li>Name und URL der abgerufenen Datei</li>
          <li>Webseite, von der aus der Zugriff erfolgt (Referrer-URL)</li>
          <li>Verwendeter Browser und ggf. das Betriebssystem Ihres Rechners</li>
        </ul>
        <p>Die Verarbeitung dieser Daten erfolgt zu dem Zweck, die Nutzung der Webseite zu ermöglichen (Verbindungsaufbau), die Systemsicherheit und -stabilität zu gewährleisten sowie zur technischen Administration der Netzinfrastruktur. Rechtsgrundlage ist Art. 6 Abs. 1 S. 1 lit. f DSGVO. Mein berechtigtes Interesse folgt aus den oben aufgelisteten Zwecken zur Datenerhebung.</p>
      </section>
      <section id="hosting" class="sub-section" aria-labelledby="hosting-heading">
        <h3 id="hosting-heading">b) Hosting</h3>
  <p>Diese Webseite wird bei einem externen Dienstleister gehostet. Die auf dieser Webseite erfassten personenbezogenen Daten werden auf den Servern des Hosters gespeichert.</p>
        <p>Der Einsatz des Hosters erfolgt im Interesse einer sicheren, schnellen und effizienten Bereitstellung meines Online-Angebots durch einen professionellen Anbieter (Art. 6 Abs. 1 lit. f DSGVO). Ich habe mit meinem Hoster einen Vertrag zur Auftragsverarbeitung (AVV) gemäß Art. 28 DSGVO abgeschlossen. Dieser stellt sicher, dass der Hoster Ihre Daten nur nach meinen Weisungen und DSGVO-konform verarbeitet.</p>
      </section>
      <section id="cookies" class="sub-section" aria-labelledby="cookies-heading">
        <h3 id="cookies-heading">c) Cookies</h3>
        <p>Diese Webseite verwendet ausschließlich ein technisch notwendiges Cookie (<code>locale</code>), um Ihre bevorzugte Spracheinstellung zu speichern, wenn Sie diese aktiv auswählen. Rechtsgrundlage ist mein berechtigtes Interesse an einer nutzerfreundlichen Gestaltung der Webseite gemäß Art. 6 Abs. 1 lit. f DSGVO sowie § 25 Abs. 2 Nr. 2 TTDSG.</p>
        <p>Sie können Ihren Browser so einstellen, dass Sie über das Setzen von Cookies informiert werden und deren Verwendung einschränken oder gänzlich unterbinden. Bei der Deaktivierung von Cookies kann die Funktionalität dieser Webseite eingeschränkt sein.</p>
      </section>
    </section>

    <section id="dienste-dritter" class="legal-section" aria-labelledby="dienste-dritter-heading">
      <h2 id="dienste-dritter-heading">3. Einbindung von Diensten Dritter &amp; Datenübermittlung in Drittländer</h2>
      <section id="google-fonts" class="sub-section" aria-labelledby="google-fonts-heading-de">
        <h3 id="google-fonts-heading-de">a) Google Fonts</h3>
        <p>Ich verwende auf meiner Webseite "Google Fonts", einen Dienst der Google Ireland Limited, Gordon House, Barrow Street, Dublin 4, Irland. Die Einbindung erfolgt durch einen Serveraufruf bei Google, wodurch Ihre IP-Adresse an Google übertragen wird.</p>
        <p><strong>Datenübermittlung in Drittländer:</strong> Google Fonts kann Daten auf Servern in den USA verarbeiten. Die USA gelten datenschutzrechtlich als Drittland. Die Datenübermittlung ist durch die Zertifizierung von Google LLC unter dem EU-U.S. Data Privacy Framework (DPF) legitimiert. Die Europäische Kommission hat mit Angemessenheitsbeschluss vom 10. Juli 2023 das Datenschutzniveau für unter dem DPF zertifizierte Unternehmen als angemessen anerkannt.</p>
        <p>Die Nutzung von Google Fonts erfolgt im Interesse einer einheitlichen und ansprechenden Darstellung meiner Webseite (berechtigtes Interesse gemäß Art. 6 Abs. 1 lit. f DSGVO). Weitere Informationen: <a href="https://www.google.com/policies/privacy/" target="_blank" rel="noopener noreferrer" class="link">Google Datenschutzerklärung</a>.</p>
      </section>
      <section id="cloudinary" class="sub-section" aria-labelledby="cloudinary-heading-de">
        <h3 id="cloudinary-heading-de">b) Cloudinary</h3>
        <p>Aktuell wird über das CDN von Cloudinary Ltd. (USA) <strong>nur eine kleine dekorative Partikel‑Textur</strong> für einen visuellen Effekt geladen. Weitere Bilder oder nutzergenerierte Inhalte werden derzeit nicht über Cloudinary ausgeliefert.</p>
        <p>Beim Abruf dieser Textur werden Ihre IP-Adresse und übliche HTTP‑Request‑Metadaten ausschließlich zur Auslieferung an Cloudinary übermittelt; es erfolgt keine Profilbildung oder zusätzliche Nachverfolgung durch mich.</p>
        <p><strong>Datenübermittlung in Drittländer:</strong> Die Anfrage kann über in den USA befindliche Infrastruktur bedient werden. Die Übermittlung stützt sich auf die Zertifizierung von Cloudinary, Inc. unter dem EU‑U.S. Data Privacy Framework (DPF).</p>
        <p>Rechtsgrundlage ist mein berechtigtes Interesse an einer effizienten Asset‑Auslieferung und Performance (Art. 6 Abs. 1 lit. f DSGVO). Sollte die Nutzung (z.B. für responsive Optimierung) ausgedehnt werden, wird dieser Abschnitt entsprechend aktualisiert. Weitere Informationen: <a href="https://cloudinary.com/privacy" target="_blank" rel="noopener noreferrer" class="link">Cloudinary Datenschutzerklärung</a>.</p>
      </section>
    </section>

    <section id="kontakt-email" class="legal-section" aria-labelledby="kontakt-email-heading">
      <h2 id="kontakt-email-heading">4. Kontaktaufnahme per E-Mail</h2>
      <p>Wenn Sie mich per E-Mail kontaktieren, speichere ich die von Ihnen übermittelten Daten, um Ihre Anfrage zu bearbeiten. Zielt Ihre Anfrage auf den Abschluss eines Vertrages ab, ist die Rechtsgrundlage Art. 6 Abs. 1 lit. b DSGVO. In allen anderen Fällen ist die Rechtsgrundlage mein berechtigtes Interesse an der effektiven Bearbeitung der an mich gerichteten Anfragen (Art. 6 Abs. 1 lit. f DSGVO). Die Daten werden gelöscht, sobald sie für den Zweck ihrer Erhebung nicht mehr erforderlich sind.</p>
    </section>

    <section id="externe-links" class="legal-section" aria-labelledby="externe-links-heading">
      <h2 id="externe-links-heading">5. Externe Links</h2>
      <p>Diese Webseite enthält Links zu externen Webseiten (z.B. GitHub, LinkedIn). Wenn Sie auf einen dieser Links klicken, verlassen Sie meine Webseite. Ich habe keinen Einfluss auf die Datenverarbeitung auf diesen externen Seiten. Es gilt die Datenschutzerklärung des jeweiligen Betreibers.</p>
    </section>

    <section id="rechte-betroffene" class="legal-section" aria-labelledby="rechte-betroffene-heading">
      <h2 id="rechte-betroffene-heading">6. Ihre Rechte als betroffene Person</h2>
      <p>Sie haben das Recht auf:</p>
      <ul class="rights-list">
        <li><strong>Auskunft</strong> (Art. 15 DSGVO)</li>
        <li><strong>Berichtigung</strong> (Art. 16 DSGVO)</li>
        <li><strong>Löschung</strong> (Art. 17 DSGVO)</li>
        <li><strong>Einschränkung der Verarbeitung</strong> (Art. 18 DSGVO)</li>
        <li><strong>Datenübertragbarkeit</strong> (Art. 20 DSGVO)</li>
        <li><strong>Widerspruch</strong> gegen die Verarbeitung (Art. 21 DSGVO)</li>
        <li><strong>Beschwerde</strong> bei einer Aufsichtsbehörde (Art. 77 DSGVO)</li>
      </ul>
      <p>Sofern eine Verarbeitung auf Ihrer Einwilligung beruht, können Sie diese jederzeit mit Wirkung für die Zukunft widerrufen.</p>
    </section>

    <section id="aenderungen" class="legal-section" aria-labelledby="aenderungen-heading">
      <h2 id="aenderungen-heading">7. Änderung dieser Datenschutzerklärung</h2>
      <p>Ich behalte mir vor, diese Datenschutzerklärung anzupassen, damit sie stets den aktuellen rechtlichen Anforderungen entspricht. Für Ihren erneuten Besuch gilt dann die neue Datenschutzerklärung.</p>
    </section>

    <footer class="article-footer">
      <button class="back" on:click={backHome} aria-label={backLabel}>{backLabel}</button>
    </footer>
  </article>
</main>

<style>
  .legal-page { min-height: 100vh; padding: clamp(1.5rem, 3vw, 3rem); color: var(--legal-fg, #fafafa); background: radial-gradient(circle at 30% 20%, #111 0%, #0a0a0b 60%, #050506 100%); overflow-y: auto; }
  /* Defensive: ensure nested scroll still works if body accidentally gets locked */
  :global(body) .legal-page { overflow-y: auto; }
  .legal-article { max-width: 75ch; margin: 0 auto; line-height: 1.55; font-size: 1rem; }
  .article-header { margin-bottom: 2.25rem; }
  h1 { font-size: clamp(2.2rem, 5vw, 3.1rem); line-height: 1.1; letter-spacing: -0.5px; margin: 0 0 0.75rem; }
  h2 { font-size: clamp(1.45rem, 3vw, 2rem); margin: 2.5rem 0 1rem; line-height: 1.2; position: relative; }
  h3 { font-size: 1.05rem; margin: 1.75rem 0 0.65rem; letter-spacing: 0.3px; }
  p, li { color: rgba(255,255,255,0.85); }
  p { margin: 0 0 1.15rem; }
  .intro { font-size: 1.05rem; }
  .last-updated { margin: 0 0 1.5rem; color: rgba(255,255,255,0.65); font-size: 0.9rem; }
  address { font-style: normal; line-height: 1.4; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.08); padding: 0.9rem 1rem; border-radius: 10px; margin: 0 0 1.7rem; }
  address p { margin: 0 0 0.5rem; }
  code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; background: rgba(255,255,255,0.08); padding: 0.15rem 0.4rem; border-radius: 4px; font-size: 0.85em; }
  .rights-list { list-style: disc; padding-left: 1.2rem; margin: 1.25rem 0 1.5rem; }
  .rights-list li { margin: 0 0 0.4rem; }
  .legal-section { scroll-margin-top: 5rem; }
  .sub-section { padding-left: 0.2rem; }
  /* Box accent similar to English version for sub-sections */
  .sub-section { position: relative; padding: 0.2rem 0 0.2rem 0.6rem; border-left: 2px solid rgba(255,255,255,0.08); margin-bottom: 1.2rem; }
  .sub-section h3 { margin-top: 1.2rem; }
  .link { color: #82d6ff; text-decoration: underline; text-underline-offset: 2px; transition: color .25s; }
  .link:hover, .link:focus-visible { color: #b5e7ff; }
  .article-footer { margin-top: 3rem; display: flex; justify-content: flex-start; }
  .back { background: linear-gradient(145deg, #1d1f21, #2a2d31); border: 1px solid rgba(255,255,255,0.12); color: #fff; padding: 0.7rem 1.1rem; border-radius: 10px; cursor: pointer; font-size: 0.95rem; letter-spacing: 0.3px; transition: background .25s, transform .25s; }
  .back:hover, .back:focus-visible { background: linear-gradient(145deg, #303438, #353a40); outline: none; }
  .back:active { transform: translateY(2px); }
  /* Focus styles */
  a:focus-visible, .back:focus-visible { box-shadow: 0 0 0 3px rgba(130,214,255,0.45), 0 0 0 6px rgba(130,214,255,0.15); border-radius: 6px; }
  /* Responsive adjustments */
  @media (max-width: 680px) {
    .legal-article { font-size: 0.96rem; }
    h2 { margin-top: 2rem; }
    h3 { margin-top: 1.2rem; }
    .article-footer { margin-top: 2.2rem; }
  }
</style>

--- END OF FILE src\routes\[lang=lang]\datenschutz\+page.svelte ---

--- START OF FILE src\routes\[lang=lang]\datenschutz\+page.ts ---
import type { PageLoad } from './$types';
import { redirect } from '@sveltejs/kit';

export const load: PageLoad = async ({ params, url }) => {
  // If user accesses /en/datenschutz, redirect permanently to /en/privacy
  if (params.lang === 'en') {
    throw redirect(308, '/en/privacy');
  }
  return {};
};

--- END OF FILE src\routes\[lang=lang]\datenschutz\+page.ts ---

--- START OF FILE src\routes\[lang=lang]\impressum\+page.svelte ---
<script lang="ts">
  import { page } from '$app/stores';
  import { transitionStore } from '$lib/stores/transitionStore';
  import BackButton from '$lib/components/BackButton.svelte';

  // German-only page (English users are redirected to /en/imprint via +page.ts)
  const lang: 'de' = 'de';
  function backHome() { transitionStore.fadeToBlackAndNavigate('/de'); }
  const title = 'Impressum';
  const backLabel = 'Zurück zur Startseite';
  const lastUpdatedISO = '2025-09-16';
  const lastUpdatedText = '16.09.2025';
</script>

<svelte:head>
  <title>{title}</title>
  <meta name="description" content="Impressum: Angaben gemäß § 5 TMG, Kontakt, USt-ID, Verantwortlichkeit, EU‑Streitschlichtung, Verbraucherstreitbeilegung und rechtliche Hinweise." />
</svelte:head>

<main class="legal-page">
  <BackButton />
  <article class="legal-article" lang="de" aria-labelledby="impressum-heading">
    <header class="article-header">
  <h1 id="impressum-heading">Impressum</h1>
  <p class="last-updated"><strong>Stand:</strong> <time datetime={lastUpdatedISO}>{lastUpdatedText}</time></p>
    </header>

    <section id="angaben-5-tmg" class="legal-section" aria-labelledby="angaben-5-tmg-heading">
      <h2 id="angaben-5-tmg-heading">Angaben gemäß § 5 TMG</h2>
      <address class="controller-address" aria-label="Anschrift">
        <p><span>Miká Müller</span><br />
        <span>Weinbergstraße 16a</span><br />
        <span>38159 Vechelde</span><br />
        <span>Deutschland</span></p>
      </address>
    </section>

    <section id="kontakt" class="legal-section" aria-labelledby="kontakt-heading">
      <h2 id="kontakt-heading">Kontakt</h2>
  <p>E‑Mail: <a href="mailto:mika38159@gmail.com" class="link">mika38159@gmail.com</a></p>
    </section>

    

    <section id="redaktionell-verantwortlich" class="legal-section" aria-labelledby="redaktionell-verantwortlich-heading">
      <h2 id="redaktionell-verantwortlich-heading">Redaktionell verantwortlich</h2>
      <p>Verantwortlich für den Inhalt nach § 18 Abs. 2 MStV: siehe Kontaktdaten oben.</p>
    </section>

    <section id="eu-streitschlichtung" class="legal-section" aria-labelledby="eu-streitschlichtung-heading">
      <h2 id="eu-streitschlichtung-heading">EU‑Streitschlichtung</h2>
      <p>Die Europäische Kommission informiert zur Verbraucherstreitbeilegung:
        <a href="https://europa.eu/youreurope/citizens/consumers/consumers-dispute-resolution/index_en.htm" target="_blank" rel="noopener noreferrer" class="link">https://europa.eu/youreurope/citizens/consumers/consumers-dispute-resolution/index_en.htm</a>.
        <br />Meine E‑Mail‑Adresse finden Sie oben im Impressum.</p>
    </section>

    <section id="verbraucherstreitbeilegung" class="legal-section" aria-labelledby="verbraucherstreitbeilegung-heading">
      <h2 id="verbraucherstreitbeilegung-heading">Verbraucher­streit­beilegung / Universal­schlichtungs­stelle</h2>
      <p>Ich bin nicht bereit oder verpflichtet, an Streitbeilegungsverfahren vor einer Verbraucherschlichtungsstelle teilzunehmen.</p>
    </section>

    <hr class="divider" />

    <section id="haftungsausschluss" class="legal-section" aria-labelledby="haftungsausschluss-heading">
      <h2 id="haftungsausschluss-heading">Haftungsausschluss (Disclaimer)</h2>

      <section id="haftung-inhalte" class="sub-section" aria-labelledby="haftung-inhalte-heading">
        <h3 id="haftung-inhalte-heading">Haftung für Inhalte</h3>
        <p>Als Diensteanbieter bin ich gemäß § 7 Abs. 1 TMG für eigene Inhalte auf diesen Seiten nach den allgemeinen Gesetzen verantwortlich. Nach §§ 8 bis 10 TMG bin ich als Diensteanbieter jedoch nicht verpflichtet, übermittelte oder gespeicherte fremde Informationen zu überwachen oder nach Umständen zu forschen, die auf eine rechtswidrige Tätigkeit hinweisen. Verpflichtungen zur Entfernung oder Sperrung der Nutzung von Informationen nach den allgemeinen Gesetzen bleiben hiervon unberührt. Eine diesbezügliche Haftung ist jedoch erst ab dem Zeitpunkt der Kenntnis einer konkreten Rechtsverletzung möglich. Bei Bekanntwerden von entsprechenden Rechtsverletzungen werde ich diese Inhalte umgehend entfernen.</p>
      </section>

      <section id="haftung-links" class="sub-section" aria-labelledby="haftung-links-heading">
        <h3 id="haftung-links-heading">Haftung für Links</h3>
        <p>Mein Angebot enthält Links zu externen Websites Dritter, auf deren Inhalte ich keinen Einfluss habe. Deshalb kann ich für diese fremden Inhalte auch keine Gewähr übernehmen. Für die Inhalte der verlinkten Seiten ist stets der jeweilige Anbieter oder Betreiber der Seiten verantwortlich. Die verlinkten Seiten wurden zum Zeitpunkt der Verlinkung auf mögliche Rechtsverstöße überprüft. Rechtswidrige Inhalte waren zum Zeitpunkt der Verlinkung nicht erkennbar. Eine permanente inhaltliche Kontrolle der verlinkten Seiten ist jedoch ohne konkrete Anhaltspunkte einer Rechtsverletzung nicht zumutbar. Bei Bekanntwerden von Rechtsverletzungen werde ich derartige Links umgehend entfernen.</p>
      </section>

      <section id="urheberrecht" class="sub-section" aria-labelledby="urheberrecht-heading">
        <h3 id="urheberrecht-heading">Urheberrecht</h3>
        <p>Die durch mich erstellten Inhalte und Werke auf diesen Seiten unterliegen dem deutschen Urheberrecht. Die Vervielfältigung, Bearbeitung, Verbreitung und jede Art der Verwertung außerhalb der Grenzen des Urheberrechtes bedürfen der schriftlichen Zustimmung des jeweiligen Autors bzw. Erstellers. Downloads und Kopien dieser Seite sind nur für den privaten, nicht kommerziellen Gebrauch gestattet. Soweit die Inhalte auf dieser Seite nicht vom Betreiber erstellt wurden, werden die Urheberrechte Dritter beachtet. Insbesondere werden Inhalte Dritter als solche gekennzeichnet. Sollten Sie trotzdem auf eine Urheberrechtsverletzung aufmerksam werden, bitte ich um einen entsprechenden Hinweis. Bei Bekanntwerden von Rechtsverletzungen werde ich derartige Inhalte umgehend entfernen.</p>
      </section>
    </section>

    <footer class="article-footer">
      <button class="back" on:click={backHome} aria-label={backLabel}>{backLabel}</button>
    </footer>
  </article>
</main>

<style>
  .legal-page { min-height: 100vh; padding: clamp(1.5rem, 3vw, 3rem); color: var(--legal-fg, #fafafa); background: radial-gradient(circle at 30% 20%, #111 0%, #0a0a0b 60%, #050506 100%); overflow-y: auto; }
  .legal-article { max-width: 75ch; margin: 0 auto; line-height: 1.55; font-size: 1rem; }
  .article-header { margin-bottom: 2.25rem; }
  h1 { font-size: clamp(2.2rem, 5vw, 3.1rem); line-height: 1.1; letter-spacing: -0.5px; margin: 0 0 0.75rem; }
  h2 { font-size: clamp(1.45rem, 3vw, 2rem); margin: 2.5rem 0 1rem; line-height: 1.2; position: relative; }
  h3 { font-size: 1.05rem; margin: 1.75rem 0 0.65rem; letter-spacing: 0.3px; }
  /* Scope list item color to lists inside legal article to avoid unused selector warnings */
  p { color: rgba(255,255,255,0.85); }
  .legal-article :global(li) { color: rgba(255,255,255,0.85); }
  p { margin: 0 0 1.15rem; }
  address { font-style: normal; line-height: 1.4; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.08); padding: 0.9rem 1rem; border-radius: 10px; margin: 0.75rem 0 1.5rem; }
  address p { margin: 0 0 0.5rem; }
  .divider { border: 0; height: 1px; background: linear-gradient(90deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02)); margin: 1.5rem 0 0.25rem; }
  .legal-section { scroll-margin-top: 5rem; }
  .sub-section { position: relative; padding: 0.2rem 0 0.2rem 0.6rem; border-left: 2px solid rgba(255,255,255,0.08); margin-bottom: 1.2rem; }
  .link { color: #82d6ff; text-decoration: underline; text-underline-offset: 2px; transition: color .25s; }
  .link:hover, .link:focus-visible { color: #b5e7ff; }
  .last-updated { margin: 0.25rem 0 1.25rem; color: rgba(255,255,255,0.65); font-size: 0.9rem; }
  .article-footer { margin-top: 3rem; display: flex; justify-content: flex-start; }
  .back { background: linear-gradient(145deg, #1d1f21, #2a2d31); border: 1px solid rgba(255,255,255,0.12); color: #fff; padding: 0.7rem 1.1rem; border-radius: 10px; cursor: pointer; font-size: 0.95rem; letter-spacing: 0.3px; transition: background .25s, transform .25s; }
  .back:hover, .back:focus-visible { background: linear-gradient(145deg, #303438, #353a40); outline: none; }
  .back:active { transform: translateY(2px); }
  a:focus-visible, .back:focus-visible { box-shadow: 0 0 0 3px rgba(130,214,255,0.45), 0 0 0 6px rgba(130,214,255,0.15); border-radius: 6px; }
  @media (max-width: 680px) {
    .legal-article { font-size: 0.96rem; }
    h2 { margin-top: 2rem; }
    h3 { margin-top: 1.2rem; }
    .article-footer { margin-top: 2.2rem; }
  }
</style>

--- END OF FILE src\routes\[lang=lang]\impressum\+page.svelte ---

--- START OF FILE src\routes\[lang=lang]\impressum\+page.ts ---
import type { PageLoad } from './$types';
import { redirect } from '@sveltejs/kit';

export const load: PageLoad = async ({ params }) => {
  if (params.lang === 'en') {
    throw redirect(308, '/en/imprint');
  }
  return {};
};

--- END OF FILE src\routes\[lang=lang]\impressum\+page.ts ---

--- START OF FILE src\routes\[lang=lang]\imprint\+page.svelte ---
<script lang="ts">
  import { page } from '$app/stores';
  import BackButton from '$lib/components/BackButton.svelte';
  $: currentLang = $page.params.lang === 'de' ? 'de' : 'en';
  const lastUpdatedISO = '2025-09-16';
  const lastUpdatedText = 'September 16, 2025';
</script>

<svelte:head>
  <title>Imprint (Legal Notice)</title>
  <meta name="description" content="Imprint (Legal Notice): Information under § 5 TMG, contact, VAT ID, responsibility for content, EU dispute resolution, consumer arbitration, and legal disclaimers." />
  <link rel="alternate" hreflang="en" href="/en/imprint" />
  <link rel="alternate" hreflang="de" href="/de/impressum" />
  <link rel="alternate" hreflang="x-default" href="/de/impressum" />
  
</svelte:head>

<main class="legal-page">
  <BackButton />
  <article class="legal-article" lang="en" aria-labelledby="imprint-heading">
    <header class="article-header">
  <h1 id="imprint-heading">Imprint (Legal Notice)</h1>
  <p class="last-updated"><strong>Last Updated:</strong> <time datetime={lastUpdatedISO}>{lastUpdatedText}</time></p>
    </header>

    <section id="info-5-tmg" class="legal-section" aria-labelledby="info-5-tmg-heading">
      <h2 id="info-5-tmg-heading">Information according to § 5 TMG (German Telemedia Act)</h2>
      <address class="controller-address" aria-label="Address">
        <p><span>Miká Müller</span><br />
        <span>Weinbergstraße 16a</span><br />
        <span>38159 Vechelde</span><br />
        <span>Germany</span></p>
      </address>
    </section>

    <section id="contact" class="legal-section" aria-labelledby="contact-heading">
      <h2 id="contact-heading">Contact</h2>
  <p>Email: <a href="mailto:mika38159@gmail.com" class="link">mika38159@gmail.com</a></p>
    </section>

    

    <section id="responsible-content" class="legal-section" aria-labelledby="responsible-content-heading">
      <h2 id="responsible-content-heading">Responsible for the Content</h2>
      <p>Responsible for the content according to § 18 Abs. 2 MStV (German State Media Treaty): see contact details above.</p>
    </section>

    <section id="eu-dispute" class="legal-section" aria-labelledby="eu-dispute-heading">
      <h2 id="eu-dispute-heading">EU Dispute Resolution</h2>
      <p>The European Commission provides information on consumer dispute resolution:
        <a href="https://europa.eu/youreurope/citizens/consumers/consumers-dispute-resolution/index_en.htm" target="_blank" rel="noopener noreferrer" class="link">https://europa.eu/youreurope/citizens/consumers/consumers-dispute-resolution/index_en.htm</a>.
        <br />My email address can be found above in this imprint.</p>
    </section>

    <section id="consumer-dispute" class="legal-section" aria-labelledby="consumer-dispute-heading">
      <h2 id="consumer-dispute-heading">Consumer Dispute Resolution / Universal Arbitration Board</h2>
      <p>I am not willing or obliged to participate in dispute resolution proceedings before a consumer arbitration board.</p>
    </section>

    <hr class="divider" />

    <section id="disclaimer" class="legal-section" aria-labelledby="disclaimer-heading">
      <h2 id="disclaimer-heading">Disclaimer</h2>

      <section id="liability-content" class="sub-section" aria-labelledby="liability-content-heading">
        <h3 id="liability-content-heading">Liability for Content</h3>
        <p>As a service provider, I am responsible for my own content on these pages according to § 7 Abs.1 TMG and general laws. However, according to §§ 8 to 10 TMG, I am not obligated to monitor transmitted or stored third-party information or to investigate circumstances that indicate illegal activity. Obligations to remove or block the use of information under general laws remain unaffected. However, liability in this regard is only possible from the moment of knowledge of a specific infringement. Upon notification of such violations, I will remove the content immediately.</p>
      </section>

      <section id="liability-links" class="sub-section" aria-labelledby="liability-links-heading">
        <h3 id="liability-links-heading">Liability for Links</h3>
        <p>My offer contains links to external third-party websites, over whose content I have no influence. Therefore, I cannot assume any liability for these external contents. The respective provider or operator of the pages is always responsible for the content of the linked pages. The linked pages were checked for possible legal violations at the time of linking. Illegal content was not recognizable at the time of linking. However, a permanent content control of the linked pages is not reasonable without concrete evidence of an infringement. Upon notification of violations, I will remove such links immediately.</p>
      </section>

      <section id="copyright" class="sub-section" aria-labelledby="copyright-heading">
        <h3 id="copyright-heading">Copyright</h3>
        <p>The content and works created by me on these pages are subject to German copyright law. The reproduction, processing, distribution, and any kind of exploitation outside the limits of copyright require the written consent of the respective author or creator. Downloads and copies of this site are for private, non-commercial use only. Insofar as the content on this site was not created by the operator, the copyrights of third parties are respected. In particular, third-party content is identified as such. Should you still become aware of a copyright infringement, I ask for a corresponding notice. Upon notification of violations, I will remove such content immediately.</p>
      </section>
    </section>

    <footer class="article-footer">
      <button class="back" on:click={() => (location.href = `/${currentLang}`)} aria-label="Back to homepage">Back to homepage</button>
    </footer>
  </article>
</main>

<style>
  .legal-page { min-height: 100vh; padding: clamp(1.5rem, 3vw, 3rem); color: var(--legal-fg, #fafafa); background: radial-gradient(circle at 30% 20%, #111 0%, #0a0a0b 60%, #050506 100%); overflow-y: auto; }
  .legal-article { max-width: 75ch; margin: 0 auto; line-height: 1.55; font-size: 1rem; }
  .article-header { margin-bottom: 2.25rem; }
  h1 { font-size: clamp(2.2rem, 5vw, 3.1rem); line-height: 1.1; letter-spacing: -0.5px; margin: 0 0 0.75rem; }
  h2 { font-size: clamp(1.45rem, 3vw, 2rem); margin: 2.5rem 0 1rem; line-height: 1.2; position: relative; }
  h3 { font-size: 1.05rem; margin: 1.75rem 0 0.65rem; letter-spacing: 0.3px; }
  /* Scope list item color to lists inside legal article to avoid unused selector warnings */
  p { color: rgba(255,255,255,0.85); }
  .legal-article :global(li) { color: rgba(255,255,255,0.85); }
  p { margin: 0 0 1.15rem; }
  address { font-style: normal; line-height: 1.4; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.08); padding: 0.9rem 1rem; border-radius: 10px; margin: 0.75rem 0 1.5rem; }
  address p { margin: 0 0 0.5rem; }
  .divider { border: 0; height: 1px; background: linear-gradient(90deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02)); margin: 1.5rem 0 0.25rem; }
  .legal-section { scroll-margin-top: 5rem; }
  .sub-section { position: relative; padding: 0.2rem 0 0.2rem 0.6rem; border-left: 2px solid rgba(255,255,255,0.08); margin-bottom: 1.2rem; }
  .link { color: #82d6ff; text-decoration: underline; text-underline-offset: 2px; transition: color .25s; }
  .link:hover, .link:focus-visible { color: #b5e7ff; }
  .last-updated { margin: 0.25rem 0 1.25rem; color: rgba(255,255,255,0.65); font-size: 0.9rem; }
  .article-footer { margin-top: 3rem; display: flex; justify-content: flex-start; }
  .back { background: linear-gradient(145deg, #1d1f21, #2a2d31); border: 1px solid rgba(255,255,255,0.12); color: #fff; padding: 0.7rem 1.1rem; border-radius: 10px; cursor: pointer; font-size: 0.95rem; letter-spacing: 0.3px; transition: background .25s, transform .25s; }
  .back:hover, .back:focus-visible { background: linear-gradient(145deg, #303438, #353a40); outline: none; }
  .back:active { transform: translateY(2px); }
  a:focus-visible, .back:focus-visible { box-shadow: 0 0 0 3px rgba(130,214,255,0.45), 0 0 0 6px rgba(130,214,255,0.15); border-radius: 6px; }
  @media (max-width: 680px) {
    .legal-article { font-size: 0.96rem; }
    h2 { margin-top: 2rem; }
    h3 { margin-top: 1.2rem; }
    .article-footer { margin-top: 2.2rem; }
  }
</style>

--- END OF FILE src\routes\[lang=lang]\imprint\+page.svelte ---

--- START OF FILE src\routes\[lang=lang]\imprint\+page.ts ---
import type { PageLoad } from './$types';
import { redirect } from '@sveltejs/kit';

export const load: PageLoad = async ({ params }) => {
  // If user accesses /de/imprint, redirect permanently to /de/impressum
  if (params.lang === 'de') {
    throw redirect(308, '/de/impressum');
  }
  return {};
};

--- END OF FILE src\routes\[lang=lang]\imprint\+page.ts ---

--- START OF FILE src\routes\[lang=lang]\privacy\+page.svelte ---
<script lang="ts">
  import { page } from '$app/stores';
  import { transitionStore } from '$lib/stores/transitionStore';
  import BackButton from '$lib/components/BackButton.svelte';
  // Force English content; if lang param is 'de', we will optionally redirect higher up (handled in datenschutz redirect) or still show EN fallback.
  const lastUpdatedISO = '2025-09-16';
  const lastUpdatedText = 'September 16, 2025';
  $: currentLang = $page.params.lang === 'de' ? 'de' : 'en';
  function backHome() { transitionStore.fadeToBlackAndNavigate(`/${currentLang}`); }
</script>

<svelte:head>
  <title>Privacy Policy</title>
  <meta name="description" content="Privacy Policy: Information on data protection, server logs, hosting, cookies, third-party services, contact by email, external links, and your GDPR rights." />
  <link rel="alternate" hreflang="en" href="/en/privacy" />
  <link rel="alternate" hreflang="de" href="/de/datenschutz" />
</svelte:head>

<main class="legal-page">
  <BackButton />
  <article class="legal-article" lang="en" aria-labelledby="privacy-policy-heading">
    <header class="article-header">
      <h1 id="privacy-policy-heading">Privacy Policy</h1>
  <p class="last-updated"><strong>Last Updated:</strong> <time datetime={lastUpdatedISO}>{lastUpdatedText}</time></p>
      <p class="intro">I take the protection of your personal data very seriously. This policy provides detailed information about how I handle your data when you visit this website. The data controller, as defined by the General Data Protection Regulation (GDPR), is:</p>
      <address class="controller-address" aria-label="Data Controller Contact">
        <p><span>Miká Müller</span><br />
        <span>Weinbergstraße 16a</span><br />
        <span>38159 Vechelde</span><br />
        <span>Germany</span></p>
        <p>Email: <a href="mailto:mika38159@gmail.com" class="link">mika38159@gmail.com</a></p>
      </address>
    </header>

    <section id="data-security" class="legal-section" aria-labelledby="data-security-heading">
      <h2 id="data-security-heading">1. Data Security Through SSL/TLS Encryption</h2>
      <p>To protect the security of your data during transmission, this site uses SSL/TLS encryption. You can recognize an encrypted connection by the <code>https://</code> prefix in your browser address bar and by the lock symbol. When SSL or TLS encryption is activated, the data you transmit cannot be read by third parties.</p>
    </section>

    <section id="data-collection" class="legal-section" aria-labelledby="data-collection-heading">
      <h2 id="data-collection-heading">2. Data Collection on This Website</h2>
      <section id="server-log-files" class="sub-section" aria-labelledby="server-log-files-heading">
        <h3 id="server-log-files-heading">a) Server Log Files</h3>
        <p>Each time you access this website, the system or hosting provider automatically collects data from the accessing device. This includes your IP address, date and time of access, requested file, referrer URL, and browser information. Processing is based on the legitimate interest (Art. 6(1)(f) GDPR) in ensuring stability, security, and technical administration of the website.</p>
      </section>
      <section id="hosting" class="sub-section" aria-labelledby="hosting-heading">
        <h3 id="hosting-heading">b) Hosting</h3>
        <p>This website is hosted by an external service provider. Personal data collected on this website is stored on the host's servers.</p>
        <p>The use of a hosting provider is based on the legitimate interest in a secure, fast, and efficient provision of online services by a professional provider (Art. 6(1)(f) GDPR). A Data Processing Agreement (DPA) pursuant to Art. 28 GDPR ensures data is processed only on documented instructions and in compliance with the GDPR.</p>
      </section>
      <section id="cookies" class="sub-section" aria-labelledby="cookies-heading">
        <h3 id="cookies-heading">c) Cookies</h3>
        <p>This website uses a single, technically necessary cookie (<code>locale</code>) to save your preferred language setting. This is based on the legitimate interest in providing a user-friendly website (Art. 6(1)(f) GDPR). You can manage or disable cookies in your browser settings; doing so may affect functionality.</p>
      </section>
    </section>

    <section id="third-party" class="legal-section" aria-labelledby="third-party-heading">
      <h2 id="third-party-heading">3. Third-Party Services &amp; Data Transfer to Third Countries</h2>
      <section id="google-fonts" class="sub-section" aria-labelledby="google-fonts-heading">
        <h3 id="google-fonts-heading">a) Google Fonts</h3>
        <p>Google Fonts (provider: Google Ireland Limited) are used to ensure a consistent and appealing presentation. When you access a page, your browser loads the required fonts and your IP address is transmitted to Google servers.</p>
        <p><strong>Data Transfer to Third Countries:</strong> Google Fonts may process data on servers in the USA. The USA is considered a third country under data protection law. The transfer is legitimized by Google LLC's certification under the EU-U.S. Data Privacy Framework (DPF). The EU Commission deemed the level of protection adequate for certified companies (decision of 10 July 2023).</p>
        <p>The use of Google Fonts is based on legitimate interest according to Art. 6(1)(f) GDPR. Further information: <a href="https://www.google.com/policies/privacy/" target="_blank" rel="noopener noreferrer" class="link">Google Privacy Policy</a>.</p>
      </section>
      <section id="cloudinary" class="sub-section" aria-labelledby="cloudinary-heading">
        <h3 id="cloudinary-heading">b) Cloudinary</h3>
        <p>This site currently loads <strong>one small decorative particle texture</strong> from the CDN of Cloudinary Ltd. (USA) for a visual effect. No other images or user-generated content are delivered via Cloudinary at this time.</p>
        <p>When that texture is requested, your IP address and standard HTTP request metadata are transmitted to Cloudinary servers solely for content delivery; no profiling or additional tracking is performed by me.</p>
        <p><strong>Data Transfer to Third Countries:</strong> The request is served from infrastructure that may be located in the USA. The transfer relies on Cloudinary Inc.'s certification under the EU‑U.S. Data Privacy Framework (DPF).</p>
        <p>Legal basis is the legitimate interest in efficient asset delivery and page performance (Art. 6(1)(f) GDPR). If Cloudinary usage is expanded (e.g. for responsive optimization), this section will be updated accordingly. More information: <a href="https://cloudinary.com/privacy" target="_blank" rel="noopener noreferrer" class="link">Cloudinary Privacy Policy</a>.</p>
      </section>
    </section>

    <section id="contact-email" class="legal-section" aria-labelledby="contact-email-heading">
      <h2 id="contact-email-heading">4. Contacting Me by Email</h2>
      <p>If you contact me by email, the data you provide is stored to process your request. If your inquiry aims at entering into a contract, processing is based on Art. 6(1)(b) GDPR; otherwise on the legitimate interest in effectively handling inquiries (Art. 6(1)(f) GDPR). Data is deleted when no longer necessary for its original purpose.</p>
    </section>

    <section id="external-links" class="legal-section" aria-labelledby="external-links-heading">
      <h2 id="external-links-heading">5. External Links</h2>
      <p>This website contains links to external websites (e.g., GitHub, LinkedIn). Clicking these links leaves this site. I have no influence on data processing by external operators. Their respective privacy policies apply.</p>
    </section>

    <section id="data-subject-rights" class="legal-section" aria-labelledby="data-subject-rights-heading">
      <h2 id="data-subject-rights-heading">6. Your Rights as a Data Subject</h2>
      <p>You have the following rights under the GDPR:</p>
      <ul class="rights-list">
        <li><strong>Access</strong> (Art. 15)</li>
        <li><strong>Rectification</strong> (Art. 16)</li>
        <li><strong>Erasure</strong> (Art. 17)</li>
        <li><strong>Restriction of Processing</strong> (Art. 18)</li>
        <li><strong>Data Portability</strong> (Art. 20)</li>
        <li><strong>Object to Processing</strong> (Art. 21)</li>
        <li><strong>Complaint</strong> with a supervisory authority (Art. 77)</li>
      </ul>
      <p>Where processing is based on consent, you may withdraw that consent at any time with future effect.</p>
    </section>

    <section id="changes" class="legal-section" aria-labelledby="changes-heading">
      <h2 id="changes-heading">7. Changes to this Privacy Policy</h2>
      <p>I reserve the right to adapt this privacy policy to ensure ongoing compliance with legal requirements. The updated policy applies to future visits.</p>
    </section>

    <footer class="article-footer">
      <button class="back" on:click={backHome} aria-label="Back to homepage">Back to homepage</button>
    </footer>
  </article>
</main>

<style>
  .legal-page { min-height: 100vh; padding: clamp(1.5rem, 3vw, 3rem); color: var(--legal-fg, #fafafa); background: radial-gradient(circle at 30% 20%, #111 0%, #0a0a0b 60%, #050506 100%); overflow-y: auto; }
  /* Defensive: ensure nested scroll still works if body accidentally gets locked */
  :global(body) .legal-page { overflow-y: auto; }
  .legal-article { max-width: 75ch; margin: 0 auto; line-height: 1.55; font-size: 1rem; }
  .article-header { margin-bottom: 2.25rem; }
  h1 { font-size: clamp(2.2rem, 5vw, 3.1rem); line-height: 1.1; letter-spacing: -0.5px; margin: 0 0 0.75rem; }
  h2 { font-size: clamp(1.45rem, 3vw, 2rem); margin: 3rem 0 1rem; line-height: 1.2; position: relative; }
  h3 { font-size: 1.15rem; margin: 2rem 0 0.75rem; letter-spacing: 0.3px; }
  p, li { color: rgba(255,255,255,0.85); }
  p { margin: 0 0 1.15rem; }
  .intro { font-size: 1.05rem; }
  .last-updated { margin: 0 0 1.5rem; color: rgba(255,255,255,0.65); font-size: 0.9rem; }
  address { font-style: normal; line-height: 1.4; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.08); padding: 0.9rem 1rem; border-radius: 10px; margin-bottom: 1.5rem; }
  address p { margin: 0 0 0.5rem; }
  code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; background: rgba(255,255,255,0.08); padding: 0.15rem 0.4rem; border-radius: 4px; font-size: 0.85em; }
  .rights-list { list-style: disc; padding-left: 1.2rem; margin: 0 0 1.5rem; }
  .rights-list li { margin: 0 0 0.4rem; }
  .legal-section { scroll-margin-top: 5rem; }
  .sub-section { padding-left: 0.2rem; }
  .link { color: #82d6ff; text-decoration: underline; text-underline-offset: 2px; }
  .link:hover, .link:focus-visible { color: #b5e7ff; }
  .article-footer { margin-top: 3rem; display: flex; justify-content: flex-start; }
  .back { background: linear-gradient(145deg, #1d1f21, #2a2d31); border: 1px solid rgba(255,255,255,0.12); color: #fff; padding: 0.7rem 1.1rem; border-radius: 10px; cursor: pointer; font-size: 0.95rem; letter-spacing: 0.3px; transition: background .25s, transform .25s; }
  .back:hover, .back:focus-visible { background: linear-gradient(145deg, #303438, #353a40); outline: none; }
  .back:active { transform: translateY(2px); }
  a:focus-visible, .back:focus-visible { box-shadow: 0 0 0 3px rgba(130,214,255,0.45), 0 0 0 6px rgba(130,214,255,0.15); border-radius: 6px; }
  @media (max-width: 680px) {
    .legal-article { font-size: 0.96rem; }
    h2 { margin-top: 2.4rem; }
    h3 { margin-top: 1.4rem; }
    .article-footer { margin-top: 2.2rem; }
  }
</style>

--- END OF FILE src\routes\[lang=lang]\privacy\+page.svelte ---

--- START OF FILE src\routes\[lang=lang]\projects\[slug]\+layout.svelte ---
<script lang="ts">
  import { onMount } from 'svelte';
  import { ArrowLeft } from 'lucide-svelte';
  import { page } from '$app/stores';
  import { transitionStore } from '$lib/stores/transitionStore';

  let showButton = false;
  $: backAria = (($page.data as any)?.messages?.common?.a11y?.backHome) ?? (($page.params.lang === 'en') ? 'Back to home' : 'Zurück zur Startseite');

  onMount(() => {
    const timer = setTimeout(() => {
      showButton = true;
    }, 300);

    return () => clearTimeout(timer);
  });

  function handleBackClick() {
    const lang = $page.params.lang ?? 'de';
    // Map slug back to project id used on main page section IDs (project-{id})
    // We can derive id by inspecting slug param vs known patterns. For now assume slug exactly matches Project.slug.
    // Need to load project list for current locale to find matching project object.
    try {
      // Dynamic import to avoid adding heavy data eagerly
      const locale: 'en' | 'de' = lang === 'de' ? 'de' : 'en';
      // @ts-ignore - dynamic require via import.meta.glob could be used; simple synchronous assumption here
    } catch {}
    // Minimal inline mapping approach: replicate logic cheaply
    // We only need id for hash; slug is unique so we can hardcode mapping for existing projects.
    const slug = ($page.params as any).slug;
    let projectId: string | null = null;
    if (slug === 'BURA') projectId = 'project-one';
    else if (slug === 'Project2') projectId = 'project-two';
    const hash = projectId ? `#project-${projectId}` : '';
    transitionStore.fadeToBlackAndNavigate(`/${lang}${hash}`);
  }
</script>
<div class="project-subpage-layout">
  <button 
    class="back-button"
    class:visible={showButton}
    on:click={handleBackClick}
  aria-label={backAria}
  >
    <ArrowLeft size={24} />
  </button>

  <slot />
  
</div>

<style>
  .project-subpage-layout { width: 100%; height: 100%; position: relative; }
  .back-button {
    position: fixed; top: 2rem; left: 2rem; z-index: 1000;
    background-color: rgba(30,30,32,0.7);
    border: 1px solid rgba(255,255,255,0.1);
    color: white; backdrop-filter: blur(8px);
    width: 3rem; height: 3rem; border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; transition: all 0.3s ease-in-out;
    opacity: 0; transform: scale(0.8); pointer-events: none;
  }
  .back-button.visible { opacity: 1; transform: scale(1); pointer-events: auto; }
  .back-button:hover { background-color: rgba(50,50,52,0.9); transform: scale(1.05); }
</style>

--- END OF FILE src\routes\[lang=lang]\projects\[slug]\+layout.svelte ---

--- START OF FILE src\routes\[lang=lang]\projects\[slug]\+page.svelte ---
<script lang="ts">
  import { onMount, tick } from 'svelte';
  import { get, writable } from 'svelte/store';
  import { page } from '$app/stores';
  import { gsap } from 'gsap';
  import { siteConfig } from '$lib/data/siteConfig';
  import { preloadingStore, startLoadingTask, preloadAssets } from '$lib/stores/preloadingStore';

  export let data;
  // Make project reactive so when locale switches and data changes, text updates without reload
  let project = data.project;
  $: project = data.project;

  const PROJECT_ASSETS_TASK_ID = `project-assets-${project.slug}`;
  const isContentLoaded = writable(false);

  // Reactive recomputation of subsections when project changes
  let allSubSections: any[] = [];
  $: if (project) {
    allSubSections = [
      { id: 'overview', title: project.headline, content: project.summary, background: project.backgrounds[0] },
      ...project.subPageSections
    ];
  }

  let sectionElements: HTMLElement[] = [];
  let sectionContentTimelines: (gsap.core.Timeline | null)[] = [];
  let sectionBackgroundZooms: (gsap.core.Tween | null)[] = [];

  let currentSectionIndex = 0;
  let isAnimating = false;
  let lastScrollTime = 0;
  const scrollDebounce = 200;
  const transitionDuration = 1.1;
  let suppressHashUpdate = false; // prevent feedback loop when programmatically updating hash

  onMount(() => {
    const runPreloadAndSetup = async () => {
      startLoadingTask(PROJECT_ASSETS_TASK_ID, 2);
      const assetUrls = allSubSections
        .filter(s => s.background && s.background.type === 'image')
        .map(s => s.background.value);
      try {
        await preloadAssets(assetUrls);
        preloadingStore.updateTaskStatus(PROJECT_ASSETS_TASK_ID, 'loaded');
      } catch (error) {
        console.error(error);
        preloadingStore.updateTaskStatus(PROJECT_ASSETS_TASK_ID, 'error', (error as Error).message);
      } finally {
        isContentLoaded.set(true);
      }
    };
    runPreloadAndSetup();

    return () => {
      window.removeEventListener('wheel', handleWheel);
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('hashchange', handleHashChange);
      sectionContentTimelines.forEach(t => t?.kill());
      sectionBackgroundZooms.forEach(t => t?.kill());
    };
  });

  $: if ($isContentLoaded) setupAnimations();

  async function setupAnimations() {
    await tick();
    sectionElements = allSubSections.map(section => document.getElementById(section.id) as HTMLElement);
    const urlHash = get(page).url.hash;
    const cleanHash = urlHash.startsWith('#') ? urlHash.substring(1) : null;
    let initialIndex = 0;
    if (cleanHash) {
      const foundIndex = allSubSections.findIndex(s => s.id === cleanHash);
      if (foundIndex !== -1) initialIndex = foundIndex;
    }
    currentSectionIndex = initialIndex;

    sectionElements.forEach((sectionEl, index) => {
      const contentTl = gsap.timeline({ paused: true });
      const contentOverlay = sectionEl.querySelector('.subpage-content-overlay');
      const h2El = sectionEl.querySelector('h2');
      const pEl = sectionEl.querySelector('p');

      if (contentOverlay) contentTl.fromTo(contentOverlay, { autoAlpha: 0, scale: 0.95 }, { autoAlpha: 1, scale: 1, duration: 0.7, ease: 'power2.out' }, 'start');
      if (h2El) contentTl.fromTo(h2El, { autoAlpha: 0, y: 30 }, { autoAlpha: 1, y: 0, duration: 0.8, ease: 'power2.out' }, 'start+=0.2');
      if (pEl) contentTl.fromTo(pEl, { autoAlpha: 0, y: 20 }, { autoAlpha: 1, y: 0, duration: 0.7, ease: 'power2.out' }, 'start+=0.35');
      sectionContentTimelines[index] = contentTl;

      const bgTarget = sectionEl.querySelector('.subpage-background-image') as HTMLElement;
      if (bgTarget) sectionBackgroundZooms[index] = gsap.to(bgTarget, { scale: 1.05, duration: 3, ease: 'power1.out', paused: true });
    });

    sectionElements.forEach((el, index) => {
      if (index === initialIndex) {
        gsap.set(el, { yPercent: 0, autoAlpha: 1 });
        sectionContentTimelines[index]?.restart();
        sectionBackgroundZooms[index]?.restart();
      } else {
        gsap.set(el, { yPercent: 100, autoAlpha: 0 });
      }
    });

    window.addEventListener('wheel', handleWheel, { passive: false });
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('hashchange', handleHashChange);
  }

  function navigateToSection(newIndex: number) {
    const oldIndex = currentSectionIndex;
    if (isAnimating || newIndex === oldIndex || newIndex < 0 || newIndex >= sectionElements.length) return;
    isAnimating = true;

    const currentSectionEl = sectionElements[oldIndex];
    const targetSectionEl = sectionElements[newIndex];
    const direction = newIndex > oldIndex ? 1 : -1;

    sectionContentTimelines[oldIndex]?.progress(0).pause();
    sectionBackgroundZooms[oldIndex]?.progress(0).pause();
    gsap.set(targetSectionEl, { yPercent: direction * 100, autoAlpha: 1 });

    const masterTl = gsap.timeline({ onComplete: () => { 
      isAnimating = false; 
      currentSectionIndex = newIndex; 
      updateHashForSection(newIndex);
    } });
    masterTl.to(currentSectionEl, { yPercent: -direction * 100, autoAlpha: 0, duration: transitionDuration, ease: 'expo.out' }, 'slide');
    masterTl.to(targetSectionEl, { yPercent: 0, duration: transitionDuration, ease: 'expo.out' }, 'slide');
    masterTl.call(() => { sectionContentTimelines[newIndex]?.restart(); }, [], `slide+=${transitionDuration * 0.3}`);
    masterTl.call(() => { sectionBackgroundZooms[newIndex]?.restart(); }, [], `slide+=${transitionDuration * 0.1}`);
  }

  function updateHashForSection(index: number) {
    if (index < 0 || index >= allSubSections.length) return;
    const targetId = allSubSections[index].id;
    const currentHash = get(page).url.hash;
    if (currentHash === `#${targetId}`) return;
    suppressHashUpdate = true;
    history.replaceState(null, '', `#${targetId}`);
    setTimeout(() => (suppressHashUpdate = false), 60);
  }

  function handleHashChange() {
    if (suppressHashUpdate) return; // ignore internal updates
    const urlHash = get(page).url.hash;
    const clean = urlHash.startsWith('#') ? urlHash.substring(1) : '';
    if (!clean) return;
    const idx = allSubSections.findIndex(s => s.id === clean);
    if (idx !== -1 && idx !== currentSectionIndex) {
      navigateToSection(idx);
    }
  }

  function handleWheel(event: WheelEvent) {
    event.preventDefault();
    const currentTime = Date.now();
    if (currentTime - lastScrollTime < scrollDebounce || isAnimating) return;
    lastScrollTime = currentTime;
    navigateToSection(currentSectionIndex + (event.deltaY > 0 ? 1 : -1));
  }

  function handleKeyDown(event: KeyboardEvent) {
    if (isAnimating) { event.preventDefault(); return; }
    const currentTime = Date.now();
    if (currentTime - lastScrollTime < scrollDebounce) { event.preventDefault(); return; }
    let newIndex = currentSectionIndex; let shouldScroll = false;
    switch (event.key) {
      case 'ArrowDown': case 'PageDown': case ' ': newIndex++; shouldScroll = true; break;
      case 'ArrowUp': case 'PageUp': newIndex--; shouldScroll = true; break;
      case 'Home': newIndex = 0; shouldScroll = true; break;
      case 'End': newIndex = allSubSections.length - 1; shouldScroll = true; break;
    }
    if (shouldScroll && newIndex !== currentSectionIndex) { event.preventDefault(); lastScrollTime = currentTime; navigateToSection(newIndex); }
  }
</script>

<svelte:head>
  <title>{project.headline} | {siteConfig.author}</title>
  <meta name="description" content={project.summary} />
</svelte:head>

<div class="subpage-container" class:loaded={$isContentLoaded}>
  {#each allSubSections as section, i (section.id)}
    <section id={section.id} class="subpage-fullscreen-section">
      {#if section.background}
        <div class="subpage-background-image" style="background-image: url({section.background.value});"></div>
      {/if}
      <div class="subpage-content-overlay">
        <h2>{section.title}</h2>
        <p>{section.content}</p>
      </div>
    </section>
  {/each}
  
</div>

<style>
  .subpage-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #000; overflow: hidden; opacity: 0; transition: opacity 0.6s ease-in-out; }
  .subpage-container.loaded { opacity: 1; }
  .subpage-fullscreen-section { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; color: white; padding: 2rem; box-sizing: border-box; }
  .subpage-background-image { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center; z-index: 0; transform: scale(1); }
  .subpage-content-overlay { position: relative; z-index: 1; max-width: 800px; text-align: center; padding: 2rem 3rem; background-color: rgba(9,9,11,0.75); backdrop-filter: blur(10px); border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); opacity: 0; visibility: hidden; }
  .subpage-content-overlay h2 { font-size: clamp(2.2rem, 5vw, 3.5rem); font-weight: 700; font-family: 'Playfair Display', serif; margin-bottom: 1.5rem; text-shadow: 0 2px 20px rgba(0,0,0,0.5); opacity: 0; visibility: hidden; }
  .subpage-content-overlay p { font-size: clamp(1rem, 2.5vw, 1.15rem); line-height: 1.8; max-width: 700px; margin: 0 auto; color: #e2e8f0; opacity: 0; visibility: hidden; }
</style>

--- END OF FILE src\routes\[lang=lang]\projects\[slug]\+page.svelte ---

--- START OF FILE src\routes\[lang=lang]\projects\[slug]\+page.ts ---
import { error } from '@sveltejs/kit';
import { getProjects } from '$lib/data/projectsData';
import type { PageLoad } from './$types';

export const load: PageLoad = ({ params }) => {
  const locale = (params.lang === 'de' ? 'de' : 'en');
  const project = getProjects(locale).find(p => p.slug === params.slug);
  if (!project) {
    throw error(404, 'Project not found');
  }
  return { project };
};

--- END OF FILE src\routes\[lang=lang]\projects\[slug]\+page.ts ---

