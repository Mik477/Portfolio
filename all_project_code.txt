--- START OF FILE src\app.css ---
/* src/app.css */
:root {
    --keyboard-background-2: #09090b;
    --keyboard-background-3: #232b34;
    --keyboard-contrast: #fff;
    --keyboard-key-base-size: 4rem;
}

@keyframes fade-in-bottom {
    0% {
        transform: translateY(50px) rotateY(0.05turn) rotateX(-0.1turn);
        opacity: 0;
        filter: blur(16px);
    }
    to {
        transform: translateY(0) rotateY(0.05turn) rotateX(-0.1turn);
        opacity: 1;
        filter: blur(0);
    }
}

@media (max-width: 768px) {
    :root { --keyboard-key-base-size: 3.5rem; }
}
@media (max-width: 640px) {
    :root { --keyboard-key-base-size: 3rem; }
}
--- END OF FILE src\app.css ---

--- START OF FILE src\app.d.ts ---
// src/app.d.ts
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

--- END OF FILE src\app.d.ts ---

--- START OF FILE src\app.html ---
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
		<style>
			/* Global Resets and Viewport Styling */
			html, body {
				margin: 0;
				padding: 0;
				height: 100%;
				width: 100%;
				overflow: hidden; /* Prevent scrollbars on html/body, main container should handle its own scroll/overflow */
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
			}

			/* Ensure SvelteKit's main div also takes full height if needed, though 'display: contents' usually negates its layout impact */
			body > div[style="display: contents"] {
				height: 100%; 
			}
		</style>
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
--- END OF FILE src\app.html ---

--- START OF FILE src\lib\index.ts ---
// place files you want to import through the `$lib` alias in this folder.

--- END OF FILE src\lib\index.ts ---

--- START OF FILE src\lib\components\AboutImageEffect.svelte ---
<!-- src/lib/components/AboutImageEffect.svelte -->
<script context="module" lang="ts">
  // This allows other components to know about and call them safely.
  export type AboutImageEffectInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    initializeEffect?: () => Promise<void>;
    onTransitionComplete?: () => void;
    // --- MODIFICATION: Expose the dispose method for the parent to call ---
    dispose?: () => void;
  };
</script>

<script lang="ts">
  import { onMount, onDestroy, tick } from 'svelte';
  import * as THREE from 'three';
  import { gsap } from 'gsap';
  import { BloomEffect } from '$lib/three/BloomEffect';

  export let imageUrl: string;
  export let fadeInDelay: number = 250;

  let mainContainer: HTMLDivElement;
  let imageElement: HTMLImageElement;
  let particleOverlayElement: HTMLDivElement;

  let effectInstance: DigitalDecayEffect | null = null;
  let isInitialized = false;
  let fadeInTimeoutId: number | undefined;

  // --- Component API ---

  export async function initializeEffect() {
    if (isInitialized) return;
    await tick();
    if (!particleOverlayElement || !imageElement) return;
    effectInstance = new DigitalDecayEffect(particleOverlayElement, imageElement);
    effectInstance.init();
    isInitialized = true;
  }

  /**
   * Exposes the internal dispose method and resets the initialization state,
   * making the component fully re-initializable by the preloader.
   */
  export function dispose() {
    if (effectInstance) {
      effectInstance.dispose();
      effectInstance = null;
      isInitialized = false; // CRITICAL: Reset for re-initialization
    }
  }

  export async function onEnterSection() {
    if (fadeInTimeoutId) clearTimeout(fadeInTimeoutId);

    fadeInTimeoutId = window.setTimeout(() => {
      gsap.to(mainContainer, { autoAlpha: 1, duration: 1.2, ease: 'power2.inOut' });
    }, fadeInDelay);
  }
  
  export function onTransitionComplete() {
    if (effectInstance) {
      effectInstance.onWindowResize();
      effectInstance.start();
    }
  }

  export function onLeaveSection() {
    if (fadeInTimeoutId) clearTimeout(fadeInTimeoutId);
    
    if (effectInstance) {
      effectInstance.beginLeaveAnimation();
      gsap.killTweensOf(mainContainer);
      gsap.set(mainContainer, { autoAlpha: 0 });
    }
  }
  
  // --- Lifecycle ---

  onMount(() => {
    // Initialization is fully deferred to the Animation API.
  });

  onDestroy(() => {
    if (fadeInTimeoutId) clearTimeout(fadeInTimeoutId);
    // Call our new exposed dispose function on component destruction
    dispose();
  });

  // --- DigitalDecayEffect Class ---

  interface GridCell { state: number; timer: number; opacity: number; }
  interface Particle { index: number; active: boolean; originalPos: THREE.Vector2; amplitude: number; timeOffset: number; speed: number; lifetime: number; age: number; size: number; color: THREE.Color; symbolIndex: number; gridCellIndex: number; lastSymbolChange: number; symbolChangeInterval: number; }

  class DigitalDecayEffect {
    private overlayContainer: HTMLElement;
    private image: HTMLImageElement;
    private clock: THREE.Clock | null = null;
    private animationFrameId: number | null = null;
    
    private width = 0;
    private height = 0;
    private scene!: THREE.Scene;
    private camera!: THREE.OrthographicCamera;
    private renderer!: THREE.WebGLRenderer;
    private bloomEffect!: BloomEffect;

    // =========================================================================
    // == EFFECT PARAMETERS ==
    // =========================================================================
    
    // --- Grid & Spawning ---
    private readonly CELL_SIZE = 9;                         // Size of each grid cell over the image.
    private readonly BASE_CHANCE = 0.003;                   // Base probability for a cell to become active per frame.
    private readonly PROBABILITY_DECAY_FACTOR = 9;          // How quickly the spawn chance decreases from left to right. Higher value = more concentrated on the left.
    private readonly SPAWN_AREA_WIDTH = 0.5;                // Percentage of the image width (from the left) where particles can spawn.
    private readonly REGENERATION_TIME = 1.5;               // Seconds a grid cell must wait after a particle dies before it can spawn another.
    private readonly ONSET_DURATION = 2.0;                  // Seconds over which the particle spawning ramps up to full intensity.
    
    // --- Particle Pool & Lifetime ---
    private readonly MAX_ACTIVE_PARTICLES = 2000;           // Maximum number of particles that can be on screen at once.
    private readonly PARTICLE_LIFETIME = { min: 4, max: 8 };// Min/max seconds a particle will exist.
    
    // --- Particle Movement & Appearance ---
    private readonly PARTICLE_SPEED = 0.25;                 // Base speed multiplier for horizontal travel.
    private readonly PARTICLE_SPEED_VARIATION = 0.5;        // Randomness in particle speed (e.g., 0.5 = +/- 50%).
    private readonly AMPLITUDE = { min: 90, max: 210 };     // Min/max horizontal distance a particle will travel over its lifetime.
    private readonly SYMBOL_CHANGE_INTERVAL = 2;          // Base time in seconds before a particle's symbol character changes.
    private readonly SYMBOL_CHANGE_VARIATION = 0.95;         // Randomness in the symbol change interval.
    
    // --- Particle Opacity & Fading ---
    private readonly PARTICLE_FADE_IN_DURATION = 0.4;       // Seconds for a particle to fade in.
    private readonly PARTICLE_FADEOUT_DURATION = 0.1;       // Seconds for a particle to fade out at the end of its life.
    private readonly PARTICLE_BASE_OPACITY = 0.9;           // The base opacity multiplied into the final particle color.
    private readonly BLACKOUT_FADE_DURATION = 0.35;         // Seconds for the black squares to fade in/out.
    
    // --- Visuals & Colors ---
    private readonly SYMBOLS = [ '日', '〇', 'ハ', 'ミ', 'ヒ', 'ウ', 'シ', 'ナ', 'モ', 'サ', 'ワ', 'ツ', 'オ', 'リ', 'ア', 'ホ', 'テ', 'マ', 'ケ', 'メ', 'エ', 'カ', 'キ', 'ム', 'ユ', 'ラ', 'セ', 'ネ', 'ヲ', 'イ', 'ク', 'コ', 'ソ', 'タ', 'チ', 'ト', 'ノ', 'フ', 'ヘ', 'ヤ', 'ヨ', 'ル', 'レ', 'ロ', '∆', 'δ', 'ε', 'ζ', 'η', 'θ', '∃', '∄', '∅', 'Д' ];
    private readonly SYMBOL_COLORS = [ new THREE.Color(0.0, 0.95, 0.05), new THREE.Color(0.0, 1.0, 0.0), new THREE.Color(0.3, 1.0, 0.3) ];
    private readonly BLACKOUT_COLOR = new THREE.Color('#09090b');
    
    // --- State & Control ---
    private STATE = { IDLE: 0, ACTIVE: 1, REGENERATING: 2 };
    private isFadingOut = false;
    private fadeOutTimer = 0;
    private onsetTimer = 0;
    private readonly SHUTDOWN_CLEANUP_DELAY = 1.0;          // Seconds after leave animation starts to fully stop the rAF loop.

    // =========================================================================
    
    private grid: { cols: number; rows: number; cells: GridCell[] } = { cols: 0, rows: 0, cells: [] };
    private particles: { pool: Particle[]; active: Map<number, Particle> } = { pool: [], active: new Map() };
    private imageRect: DOMRect | null = null;
    private particleSystem!: THREE.Points<THREE.BufferGeometry, THREE.ShaderMaterial>;
    private blackoutMesh!: THREE.InstancedMesh;
    private symbolsTexture!: THREE.CanvasTexture;
    private boundOnWindowResize = this.onWindowResize.bind(this);

    constructor(overlayContainer: HTMLElement, image: HTMLImageElement) {
        this.overlayContainer = overlayContainer;
        this.image = image;
    }

    public init(): void {
      if (this.image.complete && this.image.naturalHeight !== 0) {
          this.setupSceneOnce();
      } else {
          this.image.onload = () => this.setupSceneOnce();
      }
    }

    private setupSceneOnce(): void {
        this.setupScene();
        this.bloomEffect = new BloomEffect(this.renderer, this.scene, this.camera, this.width, this.height);
        this.createSymbolTexture();
        this.createBlackoutMesh();
        this.createParticleSystem();

        if (this.bloomEffect && this.bloomEffect.composer) {
            this.bloomEffect.composer.render(0.01);
        }

        window.addEventListener('resize', this.boundOnWindowResize);
    }
    
    private animate(): void {
        this.animationFrameId = requestAnimationFrame(() => this.animate());
        if (!this.clock || !this.imageRect) return;

        const deltaTime = this.clock.getDelta();

        if (this.isFadingOut) {
            this.fadeOutTimer += deltaTime;
            this.updateParticles(deltaTime);
            const fadeProgress = Math.max(0, 1.0 - (this.fadeOutTimer / this.PARTICLE_FADEOUT_DURATION));
            this.particleSystem.material.uniforms.globalOpacity.value = fadeProgress;

            if (this.fadeOutTimer >= this.SHUTDOWN_CLEANUP_DELAY) {
                this.stop();
                this.fullReset();
            }
        } else {
            this.updateGrid(deltaTime);
            this.updateParticles(deltaTime);
            this.updateBlackout();
        }

        this.bloomEffect.render(deltaTime);
    }

    public onWindowResize(): void {
        this.width = window.innerWidth;
        this.height = window.innerHeight;

        this.camera.left = -this.width / 2;
        this.camera.right = this.width / 2;
        this.camera.top = this.height / 2;
        this.camera.bottom = -this.height / 2;
        this.camera.updateProjectionMatrix();

        this.renderer.setSize(this.width, this.height);
        if (this.bloomEffect) {
            this.bloomEffect.setSize(this.width, this.height);
        }

        this.setupGrid();
    }
    
    public dispose(): void {
      this.stop();
      window.removeEventListener('resize', this.boundOnWindowResize);
      if (this.renderer) {
        if (this.renderer.domElement.parentElement) {
          this.renderer.domElement.parentElement.removeChild(this.renderer.domElement);
        }
        this.renderer.dispose();
      }
      if (this.bloomEffect) {
        this.bloomEffect.dispose();
      }
      if (this.scene) {
        // Dispose of all scene objects, geometries, materials, textures
        this.scene.traverse(object => {
          const obj = object as any;
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) {
            if (Array.isArray(obj.material)) {
              obj.material.forEach((material: any) => this.disposeMaterial(material));
            } else {
              this.disposeMaterial(obj.material);
            }
          }
        });
      }
    }

    private disposeMaterial(material: any) {
      material.dispose();
      for (const key of Object.keys(material)) {
        const value = material[key];
        if (value && typeof value === 'object' && 'isTexture' in value) {
          value.dispose();
        }
      }
    }

    public start(): void {
        if (this.animationFrameId === null) {
            this.fullReset();
            this.clock = new THREE.Clock();
            this.animate();
        }
    }
    
    public stop(): void {
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
        this.clock = null;
      }
    }

    public beginLeaveAnimation(): void {
      if (!this.isFadingOut) {
        this.isFadingOut = true;
        this.fadeOutTimer = 0;
        this.resetBlackoutGrid();
      }
    }

    private setupScene(): void {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.scene = new THREE.Scene();
        
        this.camera = new THREE.OrthographicCamera(-this.width / 2, this.width / 2, this.height / 2, -this.height / 2, 1, 1000);
        this.camera.position.z = 100;
        
        this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        this.renderer.setPixelRatio(window.devicePixelRatio);
        this.renderer.setSize(this.width, this.height);
        
        this.overlayContainer.appendChild(this.renderer.domElement);
    }

    private fullReset(): void {
        this.isFadingOut = false;
        this.fadeOutTimer = 0;
        this.onsetTimer = 0;
        if(this.particleSystem) {
            this.particleSystem.material.uniforms.globalOpacity.value = 1.0;
        }
        this.resetBlackoutGrid();
        this.resetAllParticles();
    }

    private resetBlackoutGrid(): void {
        if (!this.blackoutMesh) return;
        for (const cell of this.grid.cells) {
            cell.state = this.STATE.IDLE;
            cell.timer = 0;
            cell.opacity = 0;
        }
        this.blackoutMesh.count = 0;
        this.blackoutMesh.instanceMatrix.needsUpdate = true;
        (this.blackoutMesh.geometry.attributes.instanceOpacity as THREE.InstancedBufferAttribute).needsUpdate = true;
    }

    private resetAllParticles(): void {
        if (!this.particleSystem) return;

        const positions = (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).array as Float32Array;
        
        this.particles.active.forEach(p => {
            p.active = false;
            positions[p.index * 3 + 1] = -99999; // Move off-screen
            this.particles.pool.push(p);
        });
        this.particles.active.clear();

        (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;
    }

    private createSymbolTexture(): void {
        const symbolsPerRow = 8;
        const symbolSize = 64;
        const rows = Math.ceil(this.SYMBOLS.length / symbolsPerRow);
        
        const canvas = document.createElement('canvas');
        canvas.width = symbolsPerRow * symbolSize;
        canvas.height = rows * symbolSize;
        
        const ctx = canvas.getContext('2d')!;
        ctx.font = `bold ${symbolSize * 0.8}px monospace`;
        ctx.fillStyle = '#FFFFFF';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        for (let i = 0; i < this.SYMBOLS.length; i++) {
            const x = (i % symbolsPerRow) * symbolSize + symbolSize / 2;
            const y = Math.floor(i / symbolsPerRow) * symbolSize + symbolSize / 2;
            ctx.fillText(this.SYMBOLS[i], x, y);
        }
        
        this.symbolsTexture = new THREE.CanvasTexture(canvas);
    }

    private createBlackoutMesh(): void {
        const quadGeom = new THREE.PlaneGeometry(this.CELL_SIZE, this.CELL_SIZE);
        quadGeom.setAttribute('instanceOpacity', new THREE.InstancedBufferAttribute(new Float32Array(200 * 200), 1));
        
        const material = new THREE.ShaderMaterial({
            uniforms: { color: { value: this.BLACKOUT_COLOR } },
            vertexShader: `
                attribute float instanceOpacity;
                varying float vOpacity;
                void main() {
                    vOpacity = instanceOpacity;
                    gl_Position = projectionMatrix * instanceMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                varying float vOpacity;
                void main() {
                    gl_FragColor = vec4(color, vOpacity);
                }
            `,
            transparent: true,
        });

        this.blackoutMesh = new THREE.InstancedMesh(quadGeom, material, 150 * 200);
        this.scene.add(this.blackoutMesh);
    }

    private createParticleSystem(): void {
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(this.MAX_ACTIVE_PARTICLES * 3), 3));
        geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(new Float32Array(this.MAX_ACTIVE_PARTICLES * 3), 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(new Float32Array(this.MAX_ACTIVE_PARTICLES), 1));
        geometry.setAttribute('symbolIndex', new THREE.Float32BufferAttribute(new Float32Array(this.MAX_ACTIVE_PARTICLES), 1));
        geometry.setAttribute('particleOpacity', new THREE.Float32BufferAttribute(new Float32Array(this.MAX_ACTIVE_PARTICLES), 1));

        const material = new THREE.ShaderMaterial({
            uniforms: {
                symbolsTexture: { value: this.symbolsTexture },
                globalOpacity: { value: 1.0 },
            },
            vertexShader: `
                attribute float size;
                attribute vec3 customColor;
                attribute float symbolIndex;
                attribute float particleOpacity;
                varying vec3 vColor;
                varying float vSymbolIndex;
                varying float vOpacity;
                void main() {
                    vColor = customColor;
                    vSymbolIndex = symbolIndex;
                    vOpacity = particleOpacity;
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_PointSize = size;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform sampler2D symbolsTexture;
                uniform float globalOpacity;
                varying vec3 vColor;
                varying float vSymbolIndex;
                varying float vOpacity;
                void main() {
                    float symbolsPerRow = 8.0;
                    float totalRows = ${Math.ceil(this.SYMBOLS.length / 8)}.0;
                    vec2 symbolCoord = gl_PointCoord;
                    symbolCoord.x = (symbolCoord.x + mod(vSymbolIndex, symbolsPerRow)) / symbolsPerRow;
                    symbolCoord.y = (symbolCoord.y + floor(vSymbolIndex / symbolsPerRow)) / totalRows;
                    
                    vec4 tex = texture2D(symbolsTexture, symbolCoord);
                    if (tex.a < 0.3) discard;
                    
                    gl_FragColor = vec4(vColor, tex.a * vOpacity * ${this.PARTICLE_BASE_OPACITY} * globalOpacity);
                }
            `,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true
        });

        this.particleSystem = new THREE.Points(geometry, material);
        this.scene.add(this.particleSystem);

        const symbolIndices = (geometry.attributes.symbolIndex as THREE.BufferAttribute).array as Float32Array;
        for (let i = 0; i < this.MAX_ACTIVE_PARTICLES; i++) {
            symbolIndices[i] = Math.floor(Math.random() * this.SYMBOLS.length);
        }
        (geometry.attributes.symbolIndex as THREE.BufferAttribute).needsUpdate = true;

        for (let i = 0; i < this.MAX_ACTIVE_PARTICLES; i++) {
            this.particles.pool.push({
                index: i, active: false, originalPos: new THREE.Vector2(),
                amplitude: 0, timeOffset: 0, speed: 0, lifetime: 0, age: 0, size: 0,
                color: new THREE.Color(), symbolIndex: 0, gridCellIndex: -1,
                lastSymbolChange: 0, symbolChangeInterval: 0
            });
        }
    }

    private getSymbolColor(): THREE.Color {
        return this.SYMBOL_COLORS[Math.floor(Math.random() * this.SYMBOL_COLORS.length)];
    }

    private setupGrid(): void {
        this.imageRect = this.image.getBoundingClientRect();
        if (!this.imageRect || !this.imageRect.width) return;
        
        this.grid.cols = Math.floor(this.imageRect.width / this.CELL_SIZE);
        this.grid.rows = Math.floor(this.imageRect.height / this.CELL_SIZE);
        this.grid.cells = [];
        
        for (let i = 0; i < this.grid.cols * this.grid.rows; i++) {
            this.grid.cells.push({ state: this.STATE.IDLE, timer: 0, opacity: 0 });
        }
    }

    private updateGrid(deltaTime: number): void {
        if (this.particles.active.size >= this.MAX_ACTIVE_PARTICLES) return;
        
        this.onsetTimer = Math.min(this.ONSET_DURATION, this.onsetTimer + deltaTime);
        const onsetMultiplier = this.ONSET_DURATION > 0 ? this.onsetTimer / this.ONSET_DURATION : 1;
        const spawnCols = Math.floor(this.grid.cols * this.SPAWN_AREA_WIDTH);

        for (let i = 0; i < this.grid.cells.length; i++) {
            const cell = this.grid.cells[i];
            const fadeSpeed = deltaTime / this.BLACKOUT_FADE_DURATION;

            if (cell.state === this.STATE.ACTIVE) {
                cell.opacity = Math.min(1.0, cell.opacity + fadeSpeed);
            } else {
                cell.opacity = Math.max(0.0, cell.opacity - fadeSpeed);
            }

            if (cell.state === this.STATE.IDLE) {
                const col = i % this.grid.cols;
                if (col < spawnCols) {
                    const normalizedX = col / spawnCols;
                    const probability = this.BASE_CHANCE * onsetMultiplier * Math.exp(-this.PROBABILITY_DECAY_FACTOR * normalizedX) * deltaTime * 60;
                    if (Math.random() < probability) {
                        cell.state = this.STATE.ACTIVE;
                        this.spawnParticleForCell(i);
                    }
                }
            } else if (cell.state === this.STATE.REGENERATING) {
                cell.timer += deltaTime;
                if (cell.timer >= this.REGENERATION_TIME && cell.opacity <= 0) {
                    cell.state = this.STATE.IDLE;
                    cell.timer = 0;
                }
            }
        }
    }

    private spawnParticleForCell(cellIndex: number): void {
        if (this.particles.pool.length === 0 || !this.imageRect) return;

        const particle = this.particles.pool.pop()!;
        particle.active = true;
        particle.gridCellIndex = cellIndex;

        const col = cellIndex % this.grid.cols;
        const row = Math.floor(cellIndex / this.grid.cols);
        const xOnImage = col * this.CELL_SIZE + this.CELL_SIZE / 2;
        const yOnImage = row * this.CELL_SIZE + this.CELL_SIZE / 2;
        const x = this.imageRect.left + xOnImage - this.width / 2;
        const y = -(this.imageRect.top + yOnImage) + this.height / 2;
        
        particle.originalPos.set(x, y);
        const speedVariation = (Math.random() * 2 - 1) * this.PARTICLE_SPEED_VARIATION;
        particle.speed = this.PARTICLE_SPEED * (1 + speedVariation);
        particle.amplitude = this.AMPLITUDE.min + Math.random() * (this.AMPLITUDE.max - this.AMPLITUDE.min);
        particle.timeOffset = Math.random() * Math.PI * 2;
        particle.lifetime = this.PARTICLE_LIFETIME.min + Math.random() * (this.PARTICLE_LIFETIME.max - this.PARTICLE_LIFETIME.min);
        particle.age = 0;
        particle.size = this.CELL_SIZE * (1 + 1.1 * Math.random());
        particle.symbolIndex = Math.floor(Math.random() * this.SYMBOLS.length);
        particle.color.copy(this.getSymbolColor());
        particle.lastSymbolChange = 0;
        const variation = 1 + (Math.random() * 2 - 1) * this.SYMBOL_CHANGE_VARIATION;
        particle.symbolChangeInterval = this.SYMBOL_CHANGE_INTERVAL * variation;

        this.particles.active.set(particle.index, particle);
    }

    private updateParticles(deltaTime: number): void {
        if (!this.particleSystem) return;
        const positions = (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).array as Float32Array;
        const opacities = (this.particleSystem.geometry.attributes.particleOpacity as THREE.BufferAttribute).array as Float32Array;
        const colors = (this.particleSystem.geometry.attributes.customColor as THREE.BufferAttribute).array as Float32Array;
        const sizes = (this.particleSystem.geometry.attributes.size as THREE.BufferAttribute).array as Float32Array;
        const symbolIndices = (this.particleSystem.geometry.attributes.symbolIndex as THREE.BufferAttribute).array as Float32Array;
        let needsUpdate = false;

        this.particles.active.forEach(p => {
            p.age += deltaTime;
            if (p.age >= p.lifetime && !this.isFadingOut) {
                this.grid.cells[p.gridCellIndex].state = this.STATE.REGENERATING;
                p.active = false;
                this.particles.active.delete(p.index);
                this.particles.pool.push(p);
                positions[p.index * 3 + 1] = -99999;
                opacities[p.index] = 0;
                needsUpdate = true;
                return;
            }

            if (p.age < this.PARTICLE_FADE_IN_DURATION) {
                opacities[p.index] = p.age / this.PARTICLE_FADE_IN_DURATION;
            } else if (p.age > p.lifetime - this.PARTICLE_FADEOUT_DURATION && !this.isFadingOut) {
                opacities[p.index] = (p.lifetime - p.age) / this.PARTICLE_FADEOUT_DURATION;
            } else {
                opacities[p.index] = 1.0;
            }

            p.lastSymbolChange += deltaTime;
            if(p.lastSymbolChange > p.symbolChangeInterval) {
                symbolIndices[p.index] = Math.floor(Math.random() * this.SYMBOLS.length);
                p.lastSymbolChange = 0;
            }

            const offsetX = -p.age * p.speed * p.amplitude;
            const offsetY = Math.sin(p.age * 1.5 + p.timeOffset) * 10;

            positions[p.index * 3] = p.originalPos.x + offsetX;
            positions[p.index * 3 + 1] = p.originalPos.y + offsetY;
            positions[p.index * 3 + 2] = 1;
            p.color.toArray(colors, p.index * 3);
            sizes[p.index] = p.size;
            needsUpdate = true;
        });
        
        if (needsUpdate) {
            (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.customColor as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.size as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.symbolIndex as THREE.BufferAttribute).needsUpdate = true;
            (this.particleSystem.geometry.attributes.particleOpacity as THREE.BufferAttribute).needsUpdate = true;
        }
    }
    
    private updateBlackout(): void {
        if (!this.imageRect || !this.blackoutMesh) return;

        const dummy = new THREE.Object3D();
        const opacities = (this.blackoutMesh.geometry.attributes.instanceOpacity as THREE.InstancedBufferAttribute).array as Float32Array;
        let instanceIdx = 0;

        for (let i = 0; i < this.grid.cells.length; i++) {
            if (this.grid.cells[i].opacity > 0) {
                const col = i % this.grid.cols;
                const row = Math.floor(i / this.grid.cols);
                const xOnImage = col * this.CELL_SIZE + this.CELL_SIZE / 2;
                const yOnImage = row * this.CELL_SIZE + this.CELL_SIZE / 2;
                const x = this.imageRect.left + xOnImage - this.width / 2;
                const y = -(this.imageRect.top + yOnImage) + this.height / 2;
                
                dummy.position.set(x, y, 0);
                dummy.updateMatrix();
                
                if (instanceIdx < this.blackoutMesh.count) {
                    this.blackoutMesh.setMatrixAt(instanceIdx, dummy.matrix);
                    opacities[instanceIdx] = this.grid.cells[i].opacity;
                }
                instanceIdx++;
            }
        }
        
        this.blackoutMesh.count = instanceIdx;
        this.blackoutMesh.instanceMatrix.needsUpdate = true;
        (this.blackoutMesh.geometry.attributes.instanceOpacity as THREE.InstancedBufferAttribute).needsUpdate = true;
    }
  }
</script>

<div class="main-container" bind:this={mainContainer}>
  <div class="image-pane">
    <img src={imageUrl} alt="Profile" bind:this={imageElement}/>
  </div>
</div>

<div class="particle-overlay" bind:this={particleOverlayElement}></div>

<style>
  .main-container {
    position: relative;
    z-index: 1;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    visibility: hidden;
    opacity: 0;
  }
  .image-pane {
    position: relative;
    height: 100%;
    flex-shrink: 0;
    display: flex;
    justify-content: flex-end;
    align-items: center;
  }
  .image-pane img {
    height: 100vh;
    width: auto;
    display: block;
    object-fit: cover;
  }
  .particle-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: 2;
    pointer-events: none;
  }
</style>
--- END OF FILE src\lib\components\AboutImageEffect.svelte ---

--- START OF FILE src\lib\components\HeroParticleEffect.svelte ---
<!-- src/lib/components/HeroParticleEffect.svelte -->
<script lang="ts">
  import { onMount, onDestroy, tick } from 'svelte';
  import { createEventDispatcher } from 'svelte';
  import *  as THREE from 'three';
  import { FontLoader, type Font } from 'three/examples/jsm/loaders/FontLoader.js';
  import { Environment as ParticleEnvironment } from '$lib/three/heroParticleLogic';
  import { preloadingStore, startLoadingTask, preloadAssets } from '$lib/stores/preloadingStore';

  export let activeSectionIndex: number;
  export let isTransitioning: boolean = false;
  export let transitionDuration: number = 1.1;
  export let isInitialLoad: boolean = false;

  const dispatch = createEventDispatcher();

  const HERO_SECTION_LOGICAL_INDEX = 0;
  const HERO_ASSETS_TASK_ID = 'heroEffectAssets';
  const HERO_INIT_TASK_ID = 'heroEffectInitialization';

  let threeContainerElement: HTMLDivElement | undefined;
  let particleSystemInstance: ParticleEnvironment | null = null;
  let loadedFontAsset: Font | null = null;
  let loadedParticleTextureMap: THREE.Texture | null = null;

  let isThreeJsLoopRunning = false;
  let areInteractionsBound = false;
  let animationLoopPauseTimeoutId: number | undefined;
  
  let initialOpacity = isInitialLoad ? '0' : '1';

  const FONT_ASSET_PATH = '/fonts/Inter_18pt_ExtraLight.json';
  const PARTICLE_TEXTURE_ASSET_PATH = 'https://res.cloudinary.com/dfvtkoboz/image/upload/v1605013866/particle_a64uzf.png';

  async function _preloadAssets() {
    const currentStatus = preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID);
    if (currentStatus === 'loaded' && loadedFontAsset && loadedParticleTextureMap) return;
    if (currentStatus === 'loading') return;

    startLoadingTask(HERO_ASSETS_TASK_ID);

    try {
      await preloadAssets([FONT_ASSET_PATH, PARTICLE_TEXTURE_ASSET_PATH]);
    } catch (error) {
      console.error("HPE: Asset preloading with preloadAssets failed:", error);
      preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'error', (error as Error).message);
      return;
    }

    const manager = new THREE.LoadingManager();
    manager.onLoad = () => preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'loaded');
    manager.onError = (url) => {
      console.error(`HPE: Error loading asset for Three.js: ${url}`);
      preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'error', `Failed to load ${url}`);
    };
    const fontLoader = new FontLoader(manager);
    const textureLoader = new THREE.TextureLoader(manager);

    try {
      const [font, texture] = await Promise.all([
        fontLoader.loadAsync(FONT_ASSET_PATH),
        textureLoader.loadAsync(PARTICLE_TEXTURE_ASSET_PATH)
      ]);
      loadedFontAsset = font;
      loadedParticleTextureMap = texture;
    } catch (error) {
      console.error("HPE: Asset loading promise for Three.js failed:", error);
      if (preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID) !== 'error') {
        preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'error', 'Asset loading failed.');
      }
    }
  }

  async function _ensureInstanceAndStartLoop() {
    if (preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID) !== 'loaded' || !loadedFontAsset || !loadedParticleTextureMap) {
      console.warn("HPE: Assets not ready for _ensureInstanceAndStartLoop.");
      await _preloadAssets(); 
      if (preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID) !== 'loaded') return; 
    }
    if (!threeContainerElement) {
      console.warn("HPE: DOM container not ready for _ensureInstanceAndStartLoop.");
      return;
    }

    if (!particleSystemInstance) {
      preloadingStore.updateTaskStatus(HERO_INIT_TASK_ID, 'loading');
      try {
        particleSystemInstance = new ParticleEnvironment(loadedFontAsset!, loadedParticleTextureMap!, threeContainerElement);
        preloadingStore.updateTaskStatus(HERO_INIT_TASK_ID, 'loaded');
        console.log("HPE: Created new Three.js instance.");
      } catch (error) {
        console.error("HPE: Error during ParticleEnvironment instantiation:", error);
        preloadingStore.updateTaskStatus(HERO_INIT_TASK_ID, 'error', 'Instantiation failed.');
        particleSystemInstance = null;
        return;
      }
    }

    if (particleSystemInstance && !particleSystemInstance.isLooping()) {
      particleSystemInstance.startAnimationLoop();
      isThreeJsLoopRunning = true;
      console.log("HPE: Three.js animation loop STARTED.");
    }
  }

  function _pauseThreeJsLoop() {
    if (particleSystemInstance && particleSystemInstance.isLooping()) {
      particleSystemInstance.stopAnimationLoop();
      isThreeJsLoopRunning = false;
      console.log("HPE: Three.js animation loop PAUSED.");
    }
  }

  function _bindInteractionEvents() {
    if (particleSystemInstance?.createParticles && !areInteractionsBound) {
      particleSystemInstance.createParticles.bindInteractionEvents();
      particleSystemInstance.createParticles.resetParticleState(); 
      areInteractionsBound = true;
      console.log("HPE: Interaction events BOUND and particle state RESET.");
    }
  }

  function _unbindInteractionEvents() {
    if (particleSystemInstance?.createParticles && areInteractionsBound) {
      particleSystemInstance.createParticles.unbindInteractionEvents();
      particleSystemInstance.createParticles.neutralizeLastMousePosition(); 
      areInteractionsBound = false;
      console.log("HPE: Interaction events UNBOUND and mouse position neutralized.");
    }
  }
  function _fadeInVisuals() {
    if (threeContainerElement) {
      if (isInitialLoad) {
        threeContainerElement.style.opacity = '0';
        requestAnimationFrame(() => {
          if (threeContainerElement) {
            threeContainerElement.style.opacity = '1';
          }
        });
      } else {
        threeContainerElement.style.opacity = '1';
      }
    }
  }

  function _fadeOutVisuals() {
    if (threeContainerElement) threeContainerElement.style.opacity = '0';
  }

  // --- EXPORTED METHODS FOR +page.svelte ---
  export async function onTransitionToHeroStart() {
    console.log("HPE Method: onTransitionToHeroStart triggered.");
    clearTimeout(animationLoopPauseTimeoutId);
    await _ensureInstanceAndStartLoop();
    _fadeInVisuals();
    _unbindInteractionEvents();
  }

  export function onTransitionToHeroComplete() {
    console.log("HPE Method: onTransitionToHeroComplete triggered.");
    _bindInteractionEvents();
  }

  export function onTransitionFromHeroStart() {
    console.log("HPE Method: onTransitionFromHeroStart triggered.");
    _unbindInteractionEvents();
    _fadeOutVisuals();
    clearTimeout(animationLoopPauseTimeoutId);
    animationLoopPauseTimeoutId = window.setTimeout(() => {
      if (particleSystemInstance?.createParticles) {
        particleSystemInstance.createParticles.resetParticleState();
        console.log("HPE: Particle state RESET after fade out.");
      }
      _pauseThreeJsLoop();
    }, transitionDuration * 1000);
  }

  async function _handleSettledState() {
    if (activeSectionIndex === HERO_SECTION_LOGICAL_INDEX) {
      console.log("HPE: Settled on Hero.");
      clearTimeout(animationLoopPauseTimeoutId);
      await _ensureInstanceAndStartLoop();
      _fadeInVisuals();
      _bindInteractionEvents();
    } else {
      console.log("HPE: Settled off Hero.");
      _unbindInteractionEvents();
      _fadeOutVisuals();

      if (isThreeJsLoopRunning && particleSystemInstance?.isLooping() && animationLoopPauseTimeoutId === undefined) {
        console.log("HPE (SettledOff): Scheduling deferred pause and reset.");
        animationLoopPauseTimeoutId = window.setTimeout(() => {
          if (particleSystemInstance?.createParticles) {
            particleSystemInstance.createParticles.resetParticleState();
            console.log("HPE (SettledOff): Particle state RESET.");
          }
          _pauseThreeJsLoop();
          animationLoopPauseTimeoutId = undefined;
        }, transitionDuration * 1000);
      } else if (!isThreeJsLoopRunning && particleSystemInstance?.createParticles) {
        console.log("HPE (SettledOff): Loop already paused. Ensuring particle state is reset.");
        particleSystemInstance.createParticles.resetParticleState();
      }
    }
  }

  let isMountedAndInitialized = false;
  onMount(async () => {
    await tick(); 
    
    // Register the tasks this component is responsible for.
    if (!preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID)) {
      preloadingStore.registerTask(HERO_ASSETS_TASK_ID, 'pending');
    }
    if (!preloadingStore.getTaskStatus(HERO_INIT_TASK_ID)) {
      preloadingStore.registerTask(HERO_INIT_TASK_ID, 'pending');
    }

    // Await the asset loading before proceeding.
    await _preloadAssets();
    isMountedAndInitialized = true;
    
    // FIX: The reactive `$: ` block won't fire for the initial state,
    // so we must manually call the state handler on mount to ensure
    // the Three.js instance is created during the loading screen phase.
    if (!isTransitioning) {
      await _handleSettledState();
    }
    
    // Only after all assets are loaded and the instance is created,
    // we signal that this component is fully ready.
    dispatch('ready');
  });

  onDestroy(() => {
    clearTimeout(animationLoopPauseTimeoutId);
    _unbindInteractionEvents();
    if (particleSystemInstance?.createParticles) {
        particleSystemInstance.createParticles.resetParticleState();
    }
    _pauseThreeJsLoop();
    if (particleSystemInstance) {
      particleSystemInstance.dispose();
      particleSystemInstance = null;
      console.log("HPE: Three.js instance disposed.");
    }
  });

  // This reactive block handles all subsequent navigation after the initial load.
  $: if (isMountedAndInitialized && typeof activeSectionIndex === 'number') {
    if (!isTransitioning) {
        _handleSettledState();
    }
  }

</script>

<div
  class="hero-particle-container"
  bind:this={threeContainerElement}
  id="magic"
  style="opacity: {initialOpacity}; transition: opacity {transitionDuration}s ease-in-out;"
>
</div>

<style>
  .hero-particle-container {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    background-color: rgb(9 9 11);
    overflow: hidden;
    pointer-events: auto;
  }
</style>
--- END OF FILE src\lib\components\HeroParticleEffect.svelte ---

--- START OF FILE src\lib\components\KeyboardButtons.svelte ---
<!-- src/lib/components/KeyboardButtons.svelte -->

<script context="module" lang="ts">
  export type KeyboardButtonsInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
  };
</script>

<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import { gsap } from 'gsap';
  import type { SocialLink } from '$lib/data/siteConfig';

  const dispatch = createEventDispatcher();

  export let title: string;
  export let introduction: string;
  export let socialLinks: SocialLink[] = [];
  export let contactSectionIndex: number;
  export let navigateToSection: (index: number) => void;

  let wrapperElement: HTMLDivElement;
  let h2El: HTMLHeadingElement;
  let pEl: HTMLParagraphElement;
  let keyPositionElements: Element[] = [];

  onMount(() => {
    if (wrapperElement) {
        keyPositionElements = gsap.utils.toArray(wrapperElement.querySelectorAll('.key-position'));
    }
  });

  export function onEnterSection() {
    if (!h2El || !pEl || keyPositionElements.length === 0) return;

    // 1. Set the initial "hidden" state for all elements.
    gsap.set(h2El, { autoAlpha: 0, y: 30 });
    gsap.set(pEl, { autoAlpha: 0, y: 20 });
    // Give the buttons a consistent "slide-up" starting position.
    gsap.set(keyPositionElements, { autoAlpha: 0, y: 15 });

    // 2. Create the animation timeline.
    gsap.timeline({
      // Increase the delay significantly. This makes the animation wait
      // until the parent section has mostly finished its transition into view.
      delay: 0.5,
      onComplete: () => {
        dispatch('animationComplete');
      }
    })
      // 3. Animate the elements in a staggered sequence.
      .to(h2El, { 
          autoAlpha: 1, 
          y: 0, 
          duration: 0.9, 
          ease: 'power3.out' 
      }, 0) // Headline starts at time 0.
      .to(pEl, { 
          autoAlpha: 1, 
          y: 0, 
          duration: 0.8, 
          ease: 'power3.out' 
      }, 0.1) // Paragraph starts 0.1s after the headline.
      .to(keyPositionElements, {
          autoAlpha: 1,
          y: 0,
          duration: 0.7,
          ease: 'power3.out',
          stagger: 0.08, // A quick stagger for the buttons.
        }, 
        0.25 // The button sequence starts 0.25s after the headline.
      );
  }

  export function onLeaveSection() {
    const allElements = [h2El, pEl, ...keyPositionElements];
    if (allElements.some(el => !el)) return;
    
    // Hard reset for interrupt-safety.
    gsap.killTweensOf(allElements);
    gsap.set(allElements, { autoAlpha: 0 });
  }

  const getLink = (name: string): string => {
    const link = socialLinks.find(l => l.name.toLowerCase() === name.toLowerCase());
    return link ? link.url : '#';
  };

  const handleContactClick = () => {
    if (typeof navigateToSection === 'function' && contactSectionIndex !== -1) {
      navigateToSection(contactSectionIndex);
    }
  };
</script>

<div class="about-text-block" bind:this={wrapperElement}>
  <h2 bind:this={h2El}>{title}</h2>
  <p bind:this={pEl}>{introduction}</p>

  <div class="keyboard-buttons-wrapper">
    {#if socialLinks.find(l => l.name.toLowerCase() === 'github')}
    <div class="key-position gpu-prewarm-target">
      <a aria-label="Github" class="key" target="_blank" rel="noopener noreferrer" href={getLink('GitHub')}>
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" color="currentColor"><path d="M10 20.568c-3.429 1.157-6.286 0-8-3.568"></path><path d="M10 22v-3.242c0-.598.184-1.118.48-1.588c.204-.322.064-.78-.303-.88C7.134 15.452 5 14.107 5 9.645c0-1.16.38-2.25 1.048-3.2c.166-.236.25-.354.27-.46c.02-.108-.015-.247-.085-.527c-.283-1.136-.264-2.343.16-3.43c0 0 .877-.287 2.874.96c.456.285.684.428.885.46s.469-.035 1.005-.169A9.5 9.5 0 0 1 13.5 3a9.6 9.6 0 0 1 2.343.28c.536.134.805.2 1.006.169c.2-.032.428-.175.884-.46c1.997-1.247 2.874-.96 2.874-.96c.424 1.087.443 2.294.16 3.43c-.07.28-.104.42-.084.526s.103.225.269.461c.668.95 1.048 2.04 1.048 3.2c0 4.462-2.364 5.807-5.177 6.643c-.367.101-.507.559-.303.88c.296.47.48.99.48 1.589V22"></path></g></svg>
      </a>
    </div>
    {/if}
    {#if socialLinks.find(l => l.name.toLowerCase() === 'linkedin')}
    <div class="key-position gpu-prewarm-target">
      <a aria-label="LinkedIn" class="key" target="_blank" rel="noopener noreferrer" href={getLink('LinkedIn')}>
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4.5 9.5H4c-.943 0-1.414 0-1.707.293S2 10.557 2 11.5V20c0 .943 0 1.414.293 1.707S3.057 22 4 22h.5c.943 0 1.414 0 1.707-.293S6.5 20.943 6.5 20v-8.5c0-.943 0-1.414-.293-1.707S5.443 9.5 4.5 9.5m2-5.25a2.25 2.25 0 1 1-4.5 0a2.25 2.25 0 0 1 4.5 0m5.826 5.25H11.5c-.943 0-1.414 0-1.707.293S9.5 10.557 9.5 11.5V20c0 .943 0 1.414.293 1.707S10.557 22 11.5 22h.5c.943 0 1.414 0 1.707-.293S14 20.943 14 20v-3.5c0-1.657.528-3 2.088-3c.78 0 1.412.672 1.412 1.5v4.5c0 .943 0 1.414.293 1.707s.764.293 1.707.293h.499c.942 0 1.414 0 1.707-.293c.292-.293.293-.764.293-1.706L22 14c0-2.486-2.364-4.5-4.703-4.5c-1.332 0-2.52.652-3.297 1.673c0-.63 0-.945-.137-1.179a1 1 0 0 0-.358-.358c-.234-.137-.549-.137-1.179-.137" color="currentColor"></path></svg>
      </a>
    </div>
    {/if}
    {#if socialLinks.find(l => l.name.toLowerCase() === 'email')}
    <div class="key-position gpu-prewarm-target">
      <a aria-label="Email" class="key" target="_blank" rel="noopener noreferrer" href={getLink('Email')}>
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" color="currentColor"><path d="m2 6l6.913 3.917c2.549 1.444 3.625 1.444 6.174 0L22 6"></path><path d="M2.016 13.476c.065 3.065.098 4.598 1.229 5.733c1.131 1.136 2.705 1.175 5.854 1.254c1.94.05 3.862.05 5.802 0c3.149-.079 4.723-.118 5.854-1.254c1.131-1.135 1.164-2.668 1.23-5.733c.02-.986.02-1.966 0-2.952c-.066-3.065-.099-4.598-1.23-5.733c-1.131-1.136-2.705-1.175-5.854-1.254a115 115 0 0 0-5.802 0c-3.149.079-4.723.118-5.854 1.254c-1.131 1.135-1.164 2.668-1.23 5.733a69 69 0 0 0 0 2.952"></path></g></svg>
      </a>
    </div>
    {/if}
    <div class="key-position gpu-prewarm-target">
      <button type="button" id="about-contact-me-btn" class="key call-to-action peer" on:click={handleContactClick}>
        <span class="call-to-action-content">Contact Me</span>
      </button>
    </div>
  </div>
</div>

<style>
  .about-text-block { max-width: 580px; }
  .about-text-block > p { 
    font-size: clamp(1rem, 2.2vw, 1.15rem); 
    line-height: 1.8; 
    margin-bottom: 2.5rem; 
    color: rgb(212 212 216); 
    opacity: 0;
    visibility: hidden;
  }
  .about-text-block h2 {
    font-size: clamp(2.2rem, 4.5vw, 3rem);
    margin-bottom: 1.5rem;
    font-weight: 300;
    letter-spacing: -0.02em;
    color: rgb(245 245 247);
    opacity: 0;
    visibility: hidden;
  }
  .keyboard-buttons-wrapper svg { width: 1.75rem; height: 1.75rem; color: var(--keyboard-contrast); }
  .keyboard-buttons-wrapper { display: flex; align-items: flex-start; text-align: center; gap: calc(var(--keyboard-key-base-size) * 0.01); }
  .key-position { 
    perspective: 800px; 
    transform: rotateY(0.05turn) rotateX(-0.1turn); 
    /* --- MODIFICATION: Set initial state for pre-warming --- */
    opacity: 0; 
    visibility: hidden;
  }
  .key.call-to-action { width: 140px; font-size: 13px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  .call-to-action-content { position: relative; }
  .call-to-action-content:after { position: absolute; content: ""; width: 0; left: 0; bottom: -4px; background: var(--keyboard-contrast); height: 1.5px; transition: 0.3s ease-out; }
  .key.call-to-action:hover .call-to-action-content:after { width: 100%;}
  .key { 
    position: relative; 
    width: var(--keyboard-key-base-size); 
    height: var(--keyboard-key-base-size); 
    font-size: calc(var(--keyboard-key-base-size) / 2.2); 
    border: 0.1rem solid var(--keyboard-background-3); 
    border-radius: calc(var(--keyboard-key-base-size) * 0.2); 
    background: var(--keyboard-background-2); 
    color: var(--keyboard-contrast); 
    box-shadow: 0.15rem 0.15rem 0 0 var(--keyboard-background-3), 0.3rem 0.3rem 0 0 var(--keyboard-background-3), 0.45rem 0.45rem 0 0 var(--keyboard-background-3), 0.6rem 0.6rem 0 0 var(--keyboard-background-3); 
    transition: transform 0.2s ease, box-shadow 0.2s ease; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    text-decoration: none; 
    transform-style: preserve-3d;
  }
  .key span { color: inherit; margin: 0; padding: 0; }
  .key:hover { cursor: pointer; transform: translate(0.3rem, 0.3rem); }
  .key:active { cursor: grabbing; transform: translate(0.8rem, 0.8rem); box-shadow: 0.1rem 0.1rem 0 0 var(--keyboard-background-3), 0.1rem 0.1rem 0 0 var(--keyboard-background-3), 0.2rem 0.2rem 0 0 var(--keyboard-background-3), 0.2rem 0.2rem 0 0 var(--keyboard-background-3); filter: blur(0.02rem); }
  @media (max-width: 640px) { .keyboard-buttons-wrapper { flex-direction: column; align-items: center; gap: 1rem; } }
</style>
--- END OF FILE src\lib\components\KeyboardButtons.svelte ---

--- START OF FILE src\lib\components\LoadingScreen.svelte ---
<!-- src/lib/components/LoadingScreen.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { overallLoadingState, initialSiteLoadComplete, minimumLoadingDuration } from '$lib/stores/preloadingStore';
  import { get } from 'svelte/store';

  let showScreen = !get(initialSiteLoadComplete);
  let isFadingOut = false;
  let textElement: HTMLDivElement;
  let tickerInstance: Ticker | null = null;
  
  const fadeOutDuration = 800; // ms
  const fadeOutDelay = 200; // ms
  
  let loadingStartTime = Date.now();
  let minimumDurationTimer: number | undefined;
  
  // Ticker class for continuous matrix-like animation
  class Ticker {
    private done = false;
    private cycleCount = 8;
    private cycleCurrent = 0;
    private chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-_=+{}|[]\\;\':"<>?,./`~'.split('');
    private charsCount = this.chars.length;
    private letters: HTMLSpanElement[] = [];
    private letterCount = 0;
    private letterCurrent = 0;
    private animationFrameId: number | null = null;
    private originalText: string;
    private continuousMode = false;

    constructor(element: HTMLDivElement, text: string) {
      this.originalText = text;
      this.setupLetters(element);
    }

    private setupLetters(element: HTMLDivElement) {
      element.innerHTML = '';
      this.letters = [];
      for (let i = 0; i < this.originalText.length; i++) {
        const span = document.createElement('span');
        span.setAttribute('data-orig', this.originalText[i]);
        span.textContent = '-';
        span.style.display = 'inline-block';
        element.appendChild(span);
        this.letters.push(span);
      }
      this.letterCount = this.letters.length;
    }

    private getChar(): string {
      return this.chars[Math.floor(Math.random() * this.charsCount)];
    }

    public start(): void {
      this.loop();
    }
    
    private loop = (): void => {
      if (this.continuousMode) {
        // In continuous mode, randomly glitch some letters periodically
        this.letters.forEach((letter) => {
          const orig = letter.getAttribute('data-orig');
          if (orig !== ' ' && Math.random() < 0.1) { // 10% chance per frame
            letter.textContent = this.getChar();
            letter.style.opacity = String(0.5 + Math.random() * 0.5);
            
            setTimeout(() => {
              letter.textContent = orig || '';
              letter.style.opacity = '1';
            }, 100 + Math.random() * 200);
          }
        });
      } else {
        // Original progressive reveal animation
        this.letters.forEach((letter, index) => {
          if (index >= this.letterCurrent) {
            const orig = letter.getAttribute('data-orig');
            if (orig !== ' ') {
              letter.textContent = this.getChar();
              letter.style.opacity = String(Math.random());
            }
          }
        });

        if (this.cycleCurrent < this.cycleCount) {
          this.cycleCurrent++;
        } else if (this.letterCurrent < this.letterCount) {
          const currLetter = this.letters[this.letterCurrent];
          this.cycleCurrent = 0;
          currLetter.textContent = currLetter.getAttribute('data-orig') || '';
          currLetter.style.opacity = '1';
          currLetter.style.transform = 'translateX(0) scale(1)';
          currLetter.classList.add('done');
          this.letterCurrent++;
        } else {
          this.done = true;
          // Switch to continuous mode after initial reveal
          this.continuousMode = true;
          this.done = false;
        }
      }

      if (!this.done) {
        this.animationFrameId = requestAnimationFrame(this.loop);
      }
    };

    public destroy(): void {
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      this.done = true;
    }
  }

  function handleLoadingComplete() {
    if (isFadingOut) return;
    
    const elapsedTime = Date.now() - loadingStartTime;
    const remainingMinimumTime = Math.max(0, minimumLoadingDuration - elapsedTime);
    
    minimumDurationTimer = setTimeout(() => {
      if (tickerInstance) {
        tickerInstance.destroy();
      }
      isFadingOut = true;
      
      setTimeout(() => {
        showScreen = false;
      }, fadeOutDuration + fadeOutDelay);
    }, remainingMinimumTime);
  }

  const unsubInitialLoad = initialSiteLoadComplete.subscribe(completed => {
    if (completed && showScreen && !isFadingOut) {
      handleLoadingComplete();
    }
  });

  const unsubOverallState = overallLoadingState.subscribe(status => {
    if (get(initialSiteLoadComplete)) return;
    
    if (status === 'error' && textElement) {
      clearTimeout(minimumDurationTimer);
      if (tickerInstance) tickerInstance.destroy();
      tickerInstance = new Ticker(textElement, "ERROR LOADING");
      tickerInstance.start();
    }
  });

  onMount(() => {
    loadingStartTime = Date.now();
    if (!get(initialSiteLoadComplete) && textElement) {
      tickerInstance = new Ticker(textElement, "LOADING...");
      tickerInstance.start();
    }
  });

  onDestroy(() => {
    if (tickerInstance) tickerInstance.destroy();
    clearTimeout(minimumDurationTimer);
    unsubOverallState();
    unsubInitialLoad();
  });
</script>

{#if showScreen}
  <div class="loading-overlay" class:fade-out={isFadingOut} style="--fade-duration: {fadeOutDuration}ms;">
    <div class="loading-content">
      <div class="word" bind:this={textElement}></div>
      <div class="scanline-overlay"></div>
    </div>
  </div>
{/if}

<style>
  .loading-overlay {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: radial-gradient(ellipse at center, #0a1a0a 0%, #000500 100%);
    display: flex; justify-content: center; align-items: center; z-index: 10000;
    opacity: 1; transition: opacity var(--fade-duration) cubic-bezier(0.4, 0, 0.2, 1);
  }
  .loading-overlay.fade-out { opacity: 0; pointer-events: none; }
  .loading-content { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
  .word {
    color: #fff; font-family: 'Source Code Pro', 'Courier New', monospace; font-weight: 400; font-size: clamp(1.5rem, 4vw, 2.5rem); text-transform: uppercase; letter-spacing: 0.15em;
    text-shadow: 0 0 10px rgba(50, 255, 50, 0.5), 0 0 20px rgba(100, 255, 100, 0.5), 0 0 30px rgba(50, 255, 50, 0.3), 0 0 40px rgba(100, 255, 100, 0.2);
    position: relative; z-index: 2; animation: flicker 4s linear infinite;
  }
  .word :global(span) { display: inline-block; transform: translateX(100%) scale(0.9); transition: transform 500ms cubic-bezier(0.4, 0, 0.2, 1); will-change: transform, opacity; }
  .word :global(.done) { color: #6f6; transform: translateX(0) scale(1) !important; }
  .scanline-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: repeating-linear-gradient( 0deg, transparent, transparent 2px, rgba(50, 255, 50, 0.03) 2px, rgba(50, 255, 50, 0.03) 4px ); background-size: 100% 4px; animation: scanline 8s linear infinite; pointer-events: none; z-index: 1; }
  .scanline-overlay::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient( 180deg, transparent 0%, rgba(50, 255, 50, 0.02) 50%, transparent 100% ); animation: scanline-move 3s linear infinite; }
  @keyframes scanline { 0% { background-position: 0 0; } 100% { background-position: 0 10px; } }
  @keyframes scanline-move { 0% { transform: translateY(-100%); } 100% { transform: translateY(100%); } }
  @keyframes flicker { 0%, 100% { opacity: 1; } 92% { opacity: 0.95; } 94% { opacity: 1; } 96% { opacity: 0.97; } }
  @media (max-width: 640px) { .word { font-size: 1.25rem; letter-spacing: 0.1em; } }
  @media (prefers-reduced-motion: reduce) { .word :global(span) { transition: none; } .scanline-overlay, .scanline-overlay::before { animation: none; } }
</style>
--- END OF FILE src\lib\components\LoadingScreen.svelte ---

--- START OF FILE src\lib\components\ParallaxCard.svelte ---
<!-- src/lib/components/ParallaxCard.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import type { ProjectCard } from '$lib/data/projectsData';

  export let cardData: ProjectCard;
  export let width: string = '240px';
  export let height: string = '320px';

  let cardWrapElement: HTMLDivElement;
  let elementWidth: number = 0;
  let elementHeight: number = 0;
  let mouseX: number = 0;
  let mouseY: number = 0;
  let mouseLeaveDelay: number | null = null;

  onMount(() => {
    if (cardWrapElement) {
      elementWidth = cardWrapElement.offsetWidth;
      elementHeight = cardWrapElement.offsetHeight;
    }
  });

  onDestroy(() => {
    if (mouseLeaveDelay) clearTimeout(mouseLeaveDelay);
  });

  $: mousePX = mouseX / elementWidth;
  $: mousePY = mouseY / elementHeight;
  $: rX = !isNaN(mousePX) ? mousePX * 30 : 0;
  $: rY = !isNaN(mousePY) ? mousePY * -30 : 0;
  $: tX = !isNaN(mousePX) ? mousePX * -40 : 0;
  $: tY = !isNaN(mousePY) ? mousePY * -40 : 0;
  $: cardStyle = `transform: rotateY(${rX}deg) rotateX(${rY}deg);`;
  $: cardBgTransform = `transform: translateX(${tX}px) translateY(${tY}px);`;
  $: cardBgImage = `background-image: url(${cardData.image});`;

  function handleMouseMove(e: MouseEvent) {
    if (!cardWrapElement) return;
    const rect = cardWrapElement.getBoundingClientRect();
    mouseX = e.clientX - rect.left - elementWidth / 2;
    mouseY = e.clientY - rect.top - elementHeight / 2;
  }

  function handleMouseEnter() {
    if (mouseLeaveDelay) clearTimeout(mouseLeaveDelay);
  }

  function handleMouseLeave() {
    mouseLeaveDelay = window.setTimeout(() => {
      mouseX = 0;
      mouseY = 0;
    }, 1000);
  }
</script>

<!-- Add the 'gpu-prewarm-target' class here -->
<div
  class="card-wrap gpu-prewarm-target"
  style:width
  style:height
  on:mousemove={handleMouseMove}
  on:mouseenter={handleMouseEnter}
  on:mouseleave={handleMouseLeave}
  bind:this={cardWrapElement}
  role="group"
  aria-label="Interactive project card for {cardData.title}"
>
  <div class="card" style={cardStyle}>
    <div class="card-bg" style="{cardBgTransform} {cardBgImage}" id="card-bg-{cardData.id}"></div>
    <div class="card-info">
      <h1 class="card-title">{cardData.title}</h1>
      {#if cardData.description}
        <p class="card-description">{cardData.description}</p>
      {/if}
    </div>
  </div>
</div>

<style>
  .card-wrap {
    margin: 10px;
    transform: perspective(800px);
    transform-style: preserve-3d;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    /* --- MODIFICATION: Set initial state for pre-warming --- */
    opacity: 0;
    visibility: hidden;
    will-change: transform;
  }
  .card-wrap:hover .card-info {
    transform: translateY(0);
  }
  .card-wrap:hover .card-description {
    opacity: 1;
  }
  .card-wrap:hover .card-info,
  .card-wrap:hover .card-info p {
    transition: 0.6s cubic-bezier(0.23, 1, 0.32, 1);
  }
  .card-wrap:hover .card-info:after {
    transition: 5s cubic-bezier(0.23, 1, 0.32, 1);
    opacity: 1;
    transform: translateY(0);
  }
  .card-wrap:hover .card-bg {
    transition: 0.6s cubic-bezier(0.23, 1, 0.32, 1), opacity 5s cubic-bezier(0.23, 1, 0.32, 1);
    opacity: 0.8;
  }
  .card-wrap:hover .card {
    transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1), box-shadow 2s cubic-bezier(0.23, 1, 0.32, 1);
    box-shadow: rgba(255, 255, 255, 0.2) 0 0 40px 5px, white 0 0 0 1px, rgba(0, 0, 0, 0.66) 0 30px 60px 0, inset #333 0 0 0 5px, inset white 0 0 0 6px;
  }

  .card {
    position: relative;
    width: 100%;
    height: 100%;
    background-color: #333;
    overflow: hidden;
    border-radius: 10px;
    box-shadow: inset #333 0 0 0 5px, inset rgba(255, 255, 255, 0.5) 0 0 0 6px;
    transition: transform 1s cubic-bezier(0.445, 0.05, 0.55, 0.95), box-shadow 1s cubic-bezier(0.445, 0.05, 0.55, 0.95);
  }

  .card-bg {
    opacity: 0.5;
    position: absolute;
    top: -20px;
    left: -20px;
    width: calc(100% + 40px);
    height: calc(100% + 40px);
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
    transition: 1s cubic-bezier(0.445, 0.05, 0.55, 0.95), opacity 5s 1s cubic-bezier(0.445, 0.05, 0.55, 0.95);
    pointer-events: none;
  }

  .card-info {
    padding: 20px;
    position: absolute;
    bottom: 0;
    color: #fff;
    transform: translateY(40%);
    transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1);
  }
  
  .card-description {
    opacity: 0;
    transition: opacity 0.6s cubic-bezier(0.23, 1, 0.32, 1);
    text-shadow: black 0 2px 3px;
    font-size: 0.9rem;
    line-height: 1.5;
    will-change: opacity, transform;
  }
  
  .card-info * {
    position: relative;
    z-index: 1;
  }
  .card-info:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
    width: 100%;
    height: 100%;
    background-image: linear-gradient(to bottom, transparent 0%, rgba(0, 0, 0, 0.6) 100%);
    background-blend-mode: overlay;
    opacity: 0;
    transform: translateY(100%);
    transition: 5s 1s cubic-bezier(0.445, 0.05, 0.55, 0.95);
  }
  
  .card-info .card-title {
    font-size: clamp(1.4rem, 10vw, 2rem);
    font-family: 'Playfair Display', serif;
    font-weight: 700;
    text-shadow: rgba(0, 0, 0, 0.5) 0 10px 10px;
    margin-bottom: 0.5rem;
    opacity: 1; 
  }
</style>
--- END OF FILE src\lib\components\ParallaxCard.svelte ---

--- START OF FILE src\lib\components\sections\AboutSection.svelte ---
<!-- src/lib/components/sections/AboutSection.svelte -->
<script context="module" lang="ts">
  export type AboutSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    initializeEffect?: () => Promise<void>;
    onTransitionComplete?: () => void;
    // --- MODIFICATION: Add the new cooldown method to the interface ---
    onCooldown?: () => void;
  };
</script>

<script lang="ts">
  import { siteConfig } from '$lib/data/siteConfig';

  import KeyboardButtons from '$lib/components/KeyboardButtons.svelte';
  import AboutImageEffect from '$lib/components/AboutImageEffect.svelte';
  import type { KeyboardButtonsInstance } from '$lib/components/KeyboardButtons.svelte';
  import type { AboutImageEffectInstance } from '$lib/components/AboutImageEffect.svelte';

  type AboutSectionData = typeof siteConfig.aboutSection;
  export let data: AboutSectionData;
  export let contactSectionIndex: number;
  export let navigateToSection: (index: number) => void;

  let keyboardButtonsInstance: KeyboardButtonsInstance | null = null;
  let aboutImageEffectInstance: AboutImageEffectInstance | null = null;

  // --- MODIFICATION: Implement the onCooldown method ---
  /**
   * Called by the orchestrator when this section is no longer a neighbor
   * of the active section. This releases heavy resources.
   */
  export function onCooldown() {
    // Tell the Three.js effect to dispose of its resources and reset itself.
    if (aboutImageEffectInstance?.dispose) {
      aboutImageEffectInstance.dispose();
    }
    // The KeyboardButtons component is lightweight, but we should reset it
    // to its hidden state as well.
    if (keyboardButtonsInstance) {
      keyboardButtonsInstance.onLeaveSection();
    }
  }
  // --- END MODIFICATION ---

  // This is called by the preload manager while the section is off-screen.
  export async function initializeEffect() {
    if (aboutImageEffectInstance?.initializeEffect) {
      await aboutImageEffectInstance.initializeEffect();
    }
  }

  // This is called at the START of the page transition.
  export function onEnterSection(): void {
    if (keyboardButtonsInstance) {
      keyboardButtonsInstance.onEnterSection();
    }
    if (aboutImageEffectInstance) {
      aboutImageEffectInstance.onEnterSection();
    }
  }
  
  // This is called at the END of the page transition.
  export function onTransitionComplete() {
    if (aboutImageEffectInstance?.onTransitionComplete) {
      aboutImageEffectInstance.onTransitionComplete();
    }
  }

  // This is called when navigating away from the section.
  export function onLeaveSection(): void {
    if (keyboardButtonsInstance) {
      keyboardButtonsInstance.onLeaveSection();
    }
    if (aboutImageEffectInstance) {
      aboutImageEffectInstance.onLeaveSection();
    }
  }
</script>

<div class="about-section-wrapper">
  <div class="about-content-wrapper">
    <KeyboardButtons 
      bind:this={keyboardButtonsInstance}
      title={data.title}
      introduction={data.introduction}
      socialLinks={data.socialLinks}
      {contactSectionIndex}
      {navigateToSection}
    />
  </div>

  <AboutImageEffect
    bind:this={aboutImageEffectInstance}
    imageUrl={data.imageUrl}
  />
</div>

<style>
  .about-section-wrapper {
    width: 100%;
    height: 100%;
    padding: 0;
    text-align: left;
    background-color: transparent;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
  }

  .about-content-wrapper {
    position: relative;
    z-index: 3;
    flex-grow: 1;
    height: 100%;
    display: flex;
    justify-content: flex-start;
    align-items: center;
    padding: 3rem max(calc(env(safe-area-inset-left, 0px) + 6vw), 3rem);
    padding-right: 2rem;
    box-sizing: border-box;
  }
  
  @media (max-width: 768px) {
    .about-section-wrapper { 
      flex-direction: column;
      justify-content: center;
      padding: 2rem; 
      align-items: center;
    }

    .about-content-wrapper { 
      justify-content: center; 
      text-align: center; 
      padding: 1rem;
      width: 100%;
      flex-grow: 0;
      z-index: 2;
    }
    
    .about-section-wrapper :global(.main-container) {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0.15 !important;
      z-index: 1;
    }

    .about-section-wrapper :global(.image-pane) {
      justify-content: center;
    }

    .about-section-wrapper :global(.image-pane img) {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
    }
  }
</style>
--- END OF FILE src\lib\components\sections\AboutSection.svelte ---

--- START OF FILE src\lib\components\sections\ContactSection.svelte ---
<!-- src/lib/components/sections/ContactSection.svelte -->
<script context="module" lang="ts">
  export type ContactSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
  };
</script>

<script lang="ts">
  import { onMount } from 'svelte';
  import { gsap } from 'gsap';
  import { siteConfig } from '$lib/data/siteConfig';

  type ContactSectionData = typeof siteConfig.contactSection;
  export let data: ContactSectionData;

  let sectionWrapper: HTMLElement;
  let animatableElements: Element[] = [];

  onMount(() => {
    if (sectionWrapper) {
        animatableElements = gsap.utils.toArray(sectionWrapper.querySelectorAll('h2, p, a'));
    }
  });

  export function onEnterSection(): void {
    if (animatableElements.length === 0) return;

    gsap.set(animatableElements, { autoAlpha: 0, y: 30 });

    // Create the staggered entrance timeline.
    // The onComplete callback is no longer needed here.
    gsap.to(animatableElements, {
      autoAlpha: 1,
      y: 0,
      duration: 0.8,
      stagger: 0.15,
      ease: 'power2.out',
    });
  }

  export function onLeaveSection(): void {
    if (animatableElements.length === 0) return;
    
    gsap.killTweensOf(animatableElements);
    gsap.set(animatableElements, { autoAlpha: 0 });
  }
</script>

<div class="contact-content-wrapper" bind:this={sectionWrapper}>
  <div class="content-center">
    <h2>{data.title}</h2>
    <p>{data.outroMessage}</p>
    <p>Email: <a href="mailto:{data.email}">{data.email}</a></p>
    {#if data.additionalLinks}
      <div class="additional-links">
        {#each data.additionalLinks as link}
          <a href={link.url} target="_blank" rel="noopener noreferrer">{link.name}</a>
        {/each}
      </div>
    {/if}
  </div>
</div>

<style>
  .contact-content-wrapper {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    background-color: rgb(24 24 27);
    color: rgb(245 245 247);
  }

  .content-center {
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
  }

  h2, p, a {
    opacity: 0;
    visibility: hidden;
  }

  h2 {
    font-size: 2.5rem;
    margin-bottom: 2rem;
    font-weight: 300;
    letter-spacing: -0.02em;
  }

  p {
    font-size: 1.15rem;
    line-height: 1.8;
    margin-bottom: 1.5rem;
    color: rgb(212 212 216);
  }

  a {
    color: rgb(99 102 241);
    text-decoration: none;
    font-weight: 500;
    transition: color 0.3s ease;
  }

  a:hover {
    color: rgb(129 140 248);
    text-decoration: underline;
  }

  .additional-links {
    margin-top: 2rem;
    display: flex;
    gap: 2rem;
    justify-content: center;
  }
</style>
--- END OF FILE src\lib\components\sections\ContactSection.svelte ---

--- START OF FILE src\lib\components\sections\HeroSection.svelte ---
<!-- src/lib/components/sections/HeroSection.svelte -->
<script context="module" lang="ts">
  import type { SvelteComponent } from 'svelte';

  // The instance type must now be a superset, including our standard API
  // and the specific Hero API for the orchestrator to use.
  export interface HeroSectionInstance {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    // We still expose the underlying component's methods for fine-grained control
    // during the initial site reveal sequence in +page.svelte.
    onTransitionToHeroStart: () => Promise<void>;
    onTransitionToHeroComplete: () => void;
    onTransitionFromHeroStart: () => void;
  }

  // A more specific type for the internal HeroParticleEffect component instance.
  interface HeroParticleEffectComponent extends SvelteComponent {
    onTransitionToHeroStart: () => Promise<void>;
    onTransitionToHeroComplete: () => void;
    onTransitionFromHeroStart: () => void;
  }
</script>

<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import HeroParticleEffect from '$lib/components/HeroParticleEffect.svelte';

  const dispatch = createEventDispatcher();

  // Props that will be passed down from the orchestrator (+page.svelte)
  export let activeSectionIndex: number;
  export let isTransitioning: boolean;
  export let transitionDuration: number;
  export let isInitialLoad: boolean;

  // Binding for the child particle effect component
  let heroParticleEffectInstance: HeroParticleEffectComponent | null = null;
  
  // --- Standard Animation API Implementation ---

  /**
   * This is the "enter" function for standard section-to-section navigation.
   * It proxies the generic call to the specific method on the particle effect component.
   */
  export function onEnterSection(): void {
    heroParticleEffectInstance?.onTransitionToHeroStart();
  }

  /**
   * This is the "leave" function for standard section-to-section navigation.
   * It proxies the generic call to the specific method on the particle effect component.
   */
  export function onLeaveSection(): void {
    heroParticleEffectInstance?.onTransitionFromHeroStart();
  }


  // --- Exposing the underlying API for fine-grained control ---
  // These are needed for the initial site load/reveal sequence in +page.svelte,
  // which has slightly different logic than a standard section transition.

  export function onTransitionToHeroStart(): Promise<void> {
    return heroParticleEffectInstance?.onTransitionToHeroStart() ?? Promise.resolve();
  }

  export function onTransitionToHeroComplete(): void {
    heroParticleEffectInstance?.onTransitionToHeroComplete();
  }

  export function onTransitionFromHeroStart(): void {
    heroParticleEffectInstance?.onTransitionFromHeroStart();
  }

</script>

<!-- 
  This wrapper contains the HeroParticleEffect. It ensures the effect is
  always present in the DOM, ready to be animated. The `div` itself
  doesn't need styling as the particle effect creates its own full-screen canvas.
-->
<div class="hero-section-wrapper">
  <HeroParticleEffect
    bind:this={heroParticleEffectInstance}
    {activeSectionIndex}
    {isTransitioning}
    {transitionDuration}
    {isInitialLoad}
    on:ready={() => dispatch('ready')}
  />
</div>

<style>
  .hero-section-wrapper {
    /* 
      This wrapper needs to occupy the full space of its parent <section>
      to ensure the particle effect's container (which is appended inside it)
      can correctly calculate its dimensions.
    */
    width: 100%;
    height: 100%;
    position: relative;
  }
</style>
--- END OF FILE src\lib\components\sections\HeroSection.svelte ---

--- START OF FILE src\lib\components\sections\ProjectOneSection.svelte ---
<!-- src/lib/components/sections/ProjectOneSection.svelte -->
<script context="module" lang="ts">
  export type ProjectOneSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
  };
</script>

<script lang="ts">
  import { onMount } from 'svelte';
  import { goto } from '$app/navigation';
  import { gsap } from 'gsap';
  import type { Project, ProjectCard } from '$lib/data/projectsData';
  import ParallaxCard from '$lib/components/ParallaxCard.svelte';

  export let project: Project;

  let sectionEl: HTMLElement;
  let headlineEl: HTMLHeadingElement;
  let summaryEl: HTMLParagraphElement;
  let readMoreBtn: HTMLButtonElement | null = null;
  let cardWrapsToAnimate: HTMLElement[] = [];
  
  onMount(() => {
    if (sectionEl) {
      // --- MODIFICATION: Find the pre-warmable targets for the animation ---
      cardWrapsToAnimate = gsap.utils.toArray(sectionEl.querySelectorAll('.gpu-prewarm-target'));
    }
  });
  
  export function onEnterSection() {
    if (!headlineEl || !summaryEl || cardWrapsToAnimate.length === 0) return;

    gsap.set(headlineEl, { autoAlpha: 0, y: 50 });
    gsap.set(summaryEl, { autoAlpha: 0, y: 40 });
    // The ParallaxCard component now starts as invisible by default for pre-warming.
    // We just need to set its scale for the animation.
    gsap.set(cardWrapsToAnimate, { scale: 0.97 });
    if(readMoreBtn) gsap.set(readMoreBtn, { autoAlpha: 0 });

    const tl = gsap.timeline(); // The onComplete callback is no longer needed.
    tl.to(headlineEl, { autoAlpha: 1, y: 0, duration: 0.8, ease: 'power2.out' }, "start")
      .to(summaryEl, { autoAlpha: 1, y: 0, duration: 0.7, ease: 'power2.out' }, "start+=0.1")
      .to(cardWrapsToAnimate, { 
          autoAlpha: 1, // Animate opacity to 1
          scale: 1, 
          duration: 2.8, 
          stagger: 0.15, 
          ease: 'expo.out' 
      }, "start+=0.2");

    if (readMoreBtn) {
      tl.to(readMoreBtn, { autoAlpha: 1, duration: 0.5, ease: 'power2.out' }, "start+=0.4");
    }
  }

  export function onLeaveSection() {
    if (!headlineEl || !summaryEl || cardWrapsToAnimate.length === 0) return;
    
    const allElements = [headlineEl, summaryEl, ...cardWrapsToAnimate];
    if (readMoreBtn) allElements.push(readMoreBtn);
    
    gsap.killTweensOf(allElements);
    gsap.set(allElements, { autoAlpha: 0 });
  }
  
  function handleCardClick(card: ProjectCard) {
    const aspectLink = card.aspectLink || '';
    goto(`/projects/${project.slug}${aspectLink}`);
  }
</script>

<div class="project-section-wrapper" bind:this={sectionEl}>
  <div class="background-image-container" style="background-image: url({project.background.value});"></div>
  <div class="content-overlay">
    <div class="project-content">
      <h2 bind:this={headlineEl}>{project.headline}</h2>
      <p class="project-summary" bind:this={summaryEl}>{project.summary}</p>
      
      <div class="project-cards-container">
        {#each project.cards as card (card.id)}
          <button type="button" class="card-click-wrapper" on:click={() => handleCardClick(card)}>
            <ParallaxCard cardData={card} width="220px" height="290px" />
          </button>
        {/each}
      </div>
      
      {#if project.readMoreLinkText}
        <button class="read-more-btn" on:click={() => goto(`/projects/${project.slug}`)} bind:this={readMoreBtn}>
            {project.readMoreLinkText}
        </button>
      {/if}
    </div>
  </div>
</div>

<style>
    .project-section-wrapper { 
        width: 100%; 
        height: 100%; 
        color: rgb(245 245 247); 
        z-index: 2; 
        background-color: transparent; 
        display: flex; 
        flex-direction: column; 
        justify-content: center; 
        align-items: center; 
    }
    .background-image-container { 
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background-size: cover; 
        background-position: center; 
        z-index: -1; 
        transform: scale(1); 
    }
    .content-overlay { 
        background-color: rgba(9 9 11 / 0.85); 
        backdrop-filter: blur(8px); 
        padding: 2rem 3rem; 
        border-radius: 16px; 
        width: 90%; 
        max-width: 1100px; 
        z-index: 1; 
        position: relative; 
        border: 1px solid rgba(255 255 255 / 0.1); 
    }
    .project-content { 
        text-align: center; 
    }
    h2 { 
        opacity: 0; 
        visibility: hidden;
        font-size: 2.5rem; 
        font-weight: 300; 
        margin-bottom: 1rem; 
        letter-spacing: -0.02em; 
    }
    p.project-summary { 
        opacity: 0; 
        visibility: hidden;
        font-size: 1.15rem; 
        color: rgb(212 212 216); 
        line-height: 1.7; 
        margin-bottom: 2rem; 
        max-width: 800px; 
        margin-left: auto; 
        margin-right: auto; 
    }
    .project-cards-container { 
        display: flex; 
        justify-content: center; 
        gap: 1rem; 
        margin-top: 1rem; 
        margin-bottom: 2rem; 
        flex-wrap: wrap; 
    }
    .card-click-wrapper { 
        background: none; 
        border: none; 
        padding: 0; 
        cursor: pointer; 
        border-radius: 10px; 
        transition: transform 0.3s ease, box-shadow 0.3s ease; 
    }
    .card-click-wrapper:hover { 
        transform: translateY(-5px); 
        box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
    }
    .card-click-wrapper:focus-visible { 
        outline: 2px solid rgb(99 102 241); 
        outline-offset: 4px; 
    }
    button.read-more-btn { 
        opacity: 0; 
        visibility: hidden;
        padding: 0.875rem 2rem; 
        background-color: rgb(99 102 241); 
        color: white; 
        border: none; 
        border-radius: 8px; 
        cursor: pointer; 
        font-size: 1rem; 
        font-weight: 500; 
        transition: all 0.3s ease; 
        margin-top: 1rem; 
    }
    button.read-more-btn:hover { 
        background-color: rgb(79 70 229); 
        transform: translateY(-2px); 
        box-shadow: 0 4px 20px rgba(99 102 241 / 0.4); 
    }
</style>
--- END OF FILE src\lib\components\sections\ProjectOneSection.svelte ---

--- START OF FILE src\lib\components\sections\ProjectTwoSection.svelte ---
<!-- src/lib/components/sections/ProjectTwoSection.svelte -->
<script context="module" lang="ts">
  export type ProjectTwoSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
  };
</script>

<script lang="ts">
  import { onMount } from 'svelte';
  import { goto } from '$app/navigation';
  import { gsap } from 'gsap';
  import type { Project, ProjectCard } from '$lib/data/projectsData';
  import ParallaxCard from '$lib/components/ParallaxCard.svelte';
  
  export let project: Project;

  let sectionEl: HTMLElement;
  let headlineEl: HTMLHeadingElement;
  let summaryEl: HTMLParagraphElement;
  let readMoreBtn: HTMLButtonElement | null = null;
  let cardWrapsToAnimate: HTMLElement[] = [];
  
  onMount(() => {
    if (sectionEl) {
      // Find the pre-warmable targets for the animation
      cardWrapsToAnimate = gsap.utils.toArray(sectionEl.querySelectorAll('.gpu-prewarm-target'));
    }
  });
  
  export function onEnterSection() {
    if (!headlineEl || !summaryEl || cardWrapsToAnimate.length === 0) return;

    gsap.set(headlineEl, { autoAlpha: 0, y: 50 });
    gsap.set(summaryEl, { autoAlpha: 0, y: 40 });
    // The ParallaxCard component now starts as invisible by default for pre-warming.
    // We just need to set its scale for the animation.
    gsap.set(cardWrapsToAnimate, { scale: 0.97 });
    if(readMoreBtn) gsap.set(readMoreBtn, { autoAlpha: 0 });

    const tl = gsap.timeline(); // The onComplete callback is no longer needed.
    tl.to(headlineEl, { autoAlpha: 1, y: 0, duration: 0.8, ease: 'power2.out' }, "start")
      .to(summaryEl, { autoAlpha: 1, y: 0, duration: 0.7, ease: 'power2.out' }, "start+=0.1")
      .to(cardWrapsToAnimate, { 
          autoAlpha: 1, // Animate opacity to 1
          scale: 1, 
          duration: 2.8, 
          stagger: 0.15, 
          ease: 'expo.out' 
      }, "start+=0.2");

    if (readMoreBtn) {
      tl.to(readMoreBtn, { autoAlpha: 1, duration: 0.5, ease: 'power2.out' }, "start+=0.4");
    }
  }

  export function onLeaveSection() {
    if (!headlineEl || !summaryEl || cardWrapsToAnimate.length === 0) return;
    
    const allElements = [headlineEl, summaryEl, ...cardWrapsToAnimate];
    if (readMoreBtn) allElements.push(readMoreBtn);
    
    gsap.killTweensOf(allElements);
    gsap.set(allElements, { autoAlpha: 0 });
  }
  
  function handleCardClick(card: ProjectCard) {
    const aspectLink = card.aspectLink || '';
    goto(`/projects/${project.slug}${aspectLink}`);
  }
</script>

<div class="project-section-wrapper" bind:this={sectionEl}>
  <div class="background-image-container" style="background-image: url({project.background.value});"></div>
  <div class="content-overlay">
    <div class="project-content">
      <h2 bind:this={headlineEl}>{project.headline}</h2>
      <p class="project-summary" bind:this={summaryEl}>{project.summary}</p>
      
      <div class="project-cards-container">
        {#each project.cards as card (card.id)}
          <button type="button" class="card-click-wrapper" on:click={() => handleCardClick(card)}>
            <ParallaxCard cardData={card} width="220px" height="290px" />
          </button>
        {/each}
      </div>
      
      {#if project.readMoreLinkText}
        <button class="read-more-btn" on:click={() => goto(`/projects/${project.slug}`)} bind:this={readMoreBtn}>
            {project.readMoreLinkText}
        </button>
      {/if}
    </div>
  </div>
</div>

<style>
    .project-section-wrapper { 
        width: 100%; 
        height: 100%; 
        color: rgb(245 245 247); 
        z-index: 2; 
        background-color: transparent; 
        display: flex; 
        flex-direction: column; 
        justify-content: center; 
        align-items: center; 
    }
    .background-image-container { 
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background-size: cover; 
        background-position: center; 
        z-index: -1; 
        transform: scale(1); 
    }
    .content-overlay { 
        background-color: rgba(9 9 11 / 0.85); 
        backdrop-filter: blur(8px); 
        padding: 2rem 3rem; 
        border-radius: 16px; 
        width: 90%; 
        max-width: 1100px; 
        z-index: 1; 
        position: relative; 
        border: 1px solid rgba(255 255 255 / 0.1); 
    }
    .project-content { 
        text-align: center; 
    }
    h2 { 
        opacity: 0; 
        visibility: hidden;
        font-size: 2.5rem; 
        font-weight: 300; 
        margin-bottom: 1rem; 
        letter-spacing: -0.02em; 
    }
    p.project-summary { 
        opacity: 0; 
        visibility: hidden;
        font-size: 1.15rem; 
        color: rgb(212 212 216); 
        line-height: 1.7; 
        margin-bottom: 2rem; 
        max-width: 800px; 
        margin-left: auto; 
        margin-right: auto; 
    }
    .project-cards-container { 
        display: flex; 
        justify-content: center; 
        gap: 1rem; 
        margin-top: 1rem; 
        margin-bottom: 2rem; 
        flex-wrap: wrap; 
    }
    .card-click-wrapper { 
        background: none; 
        border: none; 
        padding: 0; 
        cursor: pointer; 
        border-radius: 10px; 
        transition: transform 0.3s ease, box-shadow 0.3s ease; 
    }
    .card-click-wrapper:hover { 
        transform: translateY(-5px); 
        box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
    }
    .card-click-wrapper:focus-visible { 
        outline: 2px solid rgb(99 102 241); 
        outline-offset: 4px; 
    }
    button.read-more-btn { 
        opacity: 0; 
        visibility: hidden;
        padding: 0.875rem 2rem; 
        background-color: rgb(99 102 241); 
        color: white; 
        border: none; 
        border-radius: 8px; 
        cursor: pointer; 
        font-size: 1rem; 
        font-weight: 500; 
        transition: all 0.3s ease; 
        margin-top: 1rem; 
    }
    button.read-more-btn:hover { 
        background-color: rgb(79 70 229); 
        transform: translateY(-2px); 
        box-shadow: 0 4px 20px rgba(99 102 241 / 0.4); 
    }
</style>
--- END OF FILE src\lib\components\sections\ProjectTwoSection.svelte ---

--- START OF FILE src\lib\data\projectsData.ts ---
// src/lib/data/projectsData.ts

export interface ProjectCard {
  id: string; // Unique ID for this card, e.g., 'data-exploration'
  title: string;
  image: string; // Path to card image, e.g., '/images/projects/project-one/card1.jpg'
  description?: string; // Short description for the card
  effect?: string; // Identifier for the card's hover/interaction effect
  aspectLink?: string; // Anchor link for the subpage section, e.g., '#data-exploration-section'
}

// --- MODIFICATION START ---
// Add a background property to the sub-page section interface
export interface ProjectSubPageSection {
    id: string; // Corresponds to aspectLink from a card, used for scrolling
    title: string;
    content: string; // Can be HTML or Markdown, we'll decide how to render it
    background: {
      type: 'image' | 'video' | 'color';
      value: string;
    };
}
// --- MODIFICATION END ---

export interface Project {
  id: string; // Unique ID for the project, e.g., 'project-alpha'
  slug: string; // URL-friendly slug for the project subpage, e.g., 'customer-churn-prediction'
  headline: string;
  headlineAnimation?: { // Optional: override default headline animation
    type?: string;
    duration?: number;
    delay?: number;
    stagger?: number;
    ease?: string;
  };
  summary: string; // A few sentences introducing the project
  background: {
    type: 'image' | 'video' | 'color'; // Type of background
    value: string; // Path to image/video or color code
  };
  tags?: string[]; // e.g., ['Machine Learning', 'Python', 'TensorFlow']
  cards: ProjectCard[];
  subPageSections: ProjectSubPageSection[]; // Content for the project detail page
  readMoreLinkText?: string;
}

export const projects: Project[] = [
  // Project 1 (Placeholder)
  {
    id: 'project-one',
    slug: 'ai-churn-prediction',
    headline: 'AI-Powered Customer Churn Prediction',
    summary: 'Leveraging machine learning to proactively identify and mitigate customer churn, improving retention rates.',
    background: {
      type: 'image',
      value: '/images/projects/project-one/background.jpg',
    },
    tags: ['Machine Learning', 'Python', 'Scikit-learn', 'Data Analysis'],
    cards: [
      {
        id: 'p1-data-exploration',
        title: 'Data Exploration',
        image: '/images/projects/project-one/card-data.jpg',
        description: 'Deep dive into dataset characteristics.',
        aspectLink: '#data-exploration' // This #hash is important
      },
      {
        id: 'p1-model-building',
        title: 'Model Building',
        image: '/images/projects/project-one/card-printing.webp',
        description: 'Developing predictive models.',
        aspectLink: '#model-building'
      },
      {
        id: 'p1-results',
        title: 'Results & Impact',
        image: '/images/projects/project-one/card-meWorking.webp',
        description: 'Analyzing model performance and business impact.',
        aspectLink: '#results'
      }
    ],
    // --- MODIFICATION START: Add background data to each sub-section ---
    subPageSections: [
        {
            id: 'data-exploration',
            title: 'In-Depth: Data Exploration',
            content: 'Detailed walkthrough of the data sources, features, and initial findings... This section describes the extensive process of cleaning, analyzing, and visualizing the raw customer data to identify patterns and potential predictors of churn.',
            background: { type: 'image', value: '/images/projects/project-one/card-data.jpg' } // Using card images for now
        },
        {
            id: 'model-building',
            title: 'Model Building Strategy',
            content: 'Explanation of the algorithms chosen, feature engineering, and training process... We tested several models, including Logistic Regression, Random Forest, and Gradient Boosting, using cross-validation to ensure robustness.',
            background: { type: 'image', value: '/images/projects/project-one/card-printing.webp' }
        },
        {
            id: 'results',
            title: 'Achieved Results and Business Value',
            content: 'Presentation of model accuracy, key metrics, and the tangible benefits realized... The final model achieved an accuracy of 88% and an F1-score of 0.75, enabling targeted retention campaigns that reduced churn by 15%.',
            background: { type: 'image', value: '/images/projects/project-one/card-meWorking.webp' }
        }
    ],
    // --- MODIFICATION END ---
    readMoreLinkText: "Explore Churn Prediction Project"
  },
  // Project 2 (Placeholder)
  {
    id: 'project-two',
    slug: 'interactive-data-visualization',
    // ... (same structure, remember to add backgrounds to its subPageSections as well)
    headline: 'Interactive Dashboard for Sales Analytics',
    summary: 'Developing a dynamic dashboard to visualize sales trends and provide actionable insights for stakeholders.',
    background: {
      type: 'image',
      value: '/images/projects/project-two/background.jpg',
    },
    tags: ['Data Visualization', 'Tableau (or similar)', 'JavaScript', 'SQL'],
    cards: [
      {
        id: 'p2-data-sourcing',
        title: 'Data Sourcing & ETL',
        image: '/images/projects/project-one/card-data.jpg',
        description: 'Gathering and preparing data.',
        aspectLink: '#data-sourcing'
      },
      {
        id: 'p2-dashboard-design',
        title: 'Dashboard Design (UX/UI)',
        image: '/images/projects/project-one/card-data.jpg',
        description: 'User-centric design.',
        aspectLink: '#dashboard-design'
      },
      {
        id: 'p2-key-insights',
        title: 'Key Insights & Features',
        image: '/images/projects/project-one/card-data.jpg',
        description: 'Impactful visualizations.',
        aspectLink: '#key-insights'
      }
    ],
    subPageSections: [
        {
            id: 'data-sourcing',
            title: 'Data Pipeline and ETL Processes',
            content: 'Overview of how data was collected, cleaned, and transformed...',
            background: { type: 'image', value: '/images/projects/project-two/card-data.jpg' }
        },
        {
            id: 'dashboard-design',
            title: 'Designing for User Experience',
            content: 'The thought process behind the dashboard layout and interactivity...',
            background: { type: 'image', value: '/images/projects/project-two/card-design.jpg' }
        },
        {
            id: 'key-insights',
            title: 'Unlocking Actionable Insights',
            content: 'Examples of how the dashboard helps users discover trends...',
            background: { type: 'image', value: '/images/projects/project-two/card-insights.jpg' }
        }
    ],
    readMoreLinkText: "Discover Interactive Sales Dashboard"
  }
];
--- END OF FILE src\lib\data\projectsData.ts ---

--- START OF FILE src\lib\data\siteConfig.ts ---
// src/lib/data/siteConfig.ts

export interface ParticleEffectConfig {
  type: string; // e.g., 'default', 'starryNight', etc.
  //options?: any; // This will hold the actual tsParticles JSON config
}

export interface SocialLink {
  name: string; // e.g., 'LinkedIn', 'GitHub', 'Email'
  url: string;
  icon?: string; // Optional: path to an icon or an icon library class name
}

export const siteConfig = {
  title: "Your Name - Data Scientist Portfolio",
  author: "Your Name",
  description: "A portfolio showcasing data science projects and expertise.",

  heroSection: {
    greeting: "Hello, I'm",
    name: "Your Name", // Or however you want to display it
    introduction: "A Data Scientist passionate about uncovering insights and building intelligent solutions.",
    particleEffect: {
      type: 'defaultGreetingParticles', // We'll define this later
    } as ParticleEffectConfig,
  },

  aboutSection: {
    title: "About Me", // MODIFIED
    introduction: "This is where you'll learn about who I am and what I do.", // MODIFIED
    imageUrl: "/images/profile.webp", // MODIFIED - ensure this image exists in static/images
    imageParticleEffect: {
      type: 'imageAuraParticles', // We'll define this later
    } as ParticleEffectConfig,
    socialLinks: [ // Existing links, will be used by KeyboardButtons
      { name: "GitHub", url: "https://github.com/yourusername" }, // Replace with your actual URL
      { name: "LinkedIn", url: "https://www.linkedin.com/in/yourprofile/" }, // Replace with your actual URL
      { name: "Email", url: "mailto:youremail@example.com" }, // Replace with your actual email
    ] as SocialLink[],
  },

  contactSection: {
    title: "Get in Touch",
    outroMessage: "I'm always excited to discuss new projects, collaborations, or opportunities. Feel free to reach out!",
    email: "youremail@example.com", // Replace with your actual email
    additionalLinks: [
        { name: "View My Resume", url: "/resume.pdf" } // Place resume in `static` folder
    ]
  },

  defaultHeadlineAnimation: {
    type: 'fadeInUp',
    duration: 0.8,
    delay: 0.2,
    stagger: 0.1,
  },
};
--- END OF FILE src\lib\data\siteConfig.ts ---

--- START OF FILE src\lib\stores\preloadingStore.ts ---
// src/lib/stores/preloadingStore.ts
import { writable, derived, get } from 'svelte/store';

// --- NEW: A type to define the possible states for a main page section ---
export type SectionState = 'IDLE' | 'PRELOADING' | 'READY' | 'ACTIVE' | 'COOLING';

export type TaskStatus = 'idle' | 'pending' | 'loading' | 'loaded' | 'error';
export type AssetStatus = 'idle' | 'loading' | 'loaded' | 'error';

export interface PreloadTask {
  id: string;
  status: TaskStatus;
  progress?: number;
  message?: string;
  priority?: number;
}

// This store tracks individual asset URLs to prevent re-downloads
const assetLoadingStatus = writable<Record<string, AssetStatus>>({});

// This store tracks tasks for the initial site loading screen
const tasks = writable<Record<string, PreloadTask>>({});

// --- NEW: A store to manage the state of each main page section for the Neighbor Preloader ---
const sectionStates = writable<Map<number, SectionState>>(new Map());

export const sectionStateStore = {
  subscribe: sectionStates.subscribe,
  /** Initializes the state map for all sections. Should be called once on mount. */
  init: (sectionCount: number) => {
    sectionStates.update(map => {
      for (let i = 0; i < sectionCount; i++) {
        // Initialize all sections to IDLE, except for the first one which starts as ACTIVE
        map.set(i, i === 0 ? 'ACTIVE' : 'IDLE');
      }
      return map;
    });
  },
  /** Updates the state of a specific section. */
  setState: (index: number, state: SectionState) => {
    sectionStates.update(map => map.set(index, state));
  },
  /** Retrieves the current state of a specific section. */
  getState: (index: number): SectionState | undefined => {
    return get(sectionStates).get(index);
  },
  /** Resets the store. */
  reset: () => {
    sectionStates.set(new Map());
  }
};
// --- END NEW ---

// Configuration for the initial loading screen
export const minimumLoadingDuration = 1780; // Minimum time to show loading screen (ms)

/**
 * Tracks whether the initial, full-site loading sequence has completed.
 * Once true, the main loading screen should not reappear.
 */
export const initialSiteLoadComplete = writable<boolean>(false);

/**
 * Overall loading progress from 0 to 1 for the initial loading screen
 */
export const loadingProgress = derived(tasks, $tasks => {
  const allTasksArray = Object.values($tasks);
  if (allTasksArray.length === 0) return 0;
  
  let totalWeight = 0;
  let weightedProgress = 0;
  
  allTasksArray.forEach(task => {
    const weight = task.priority || 1;
    totalWeight += weight;
    
    let taskProgress = 0;
    switch (task.status) {
      case 'loaded': taskProgress = 1; break;
      case 'error': taskProgress = 1; break;
      case 'loading': taskProgress = task.progress || 0.5; break;
      default: taskProgress = 0; break;
    }
    
    weightedProgress += taskProgress * weight;
  });
  
  return totalWeight > 0 ? weightedProgress / totalWeight : 0;
});

export const preloadingStore = {
  subscribe: tasks.subscribe,
  
  registerTask: (taskId: string, initialStatus: TaskStatus = 'pending', priority: number = 1) => {
    tasks.update(currentTasks => {
      if (!currentTasks[taskId] || currentTasks[taskId].status === 'idle' || currentTasks[taskId].status === 'error') {
        currentTasks[taskId] = { 
          id: taskId, 
          status: initialStatus,
          priority,
          progress: initialStatus === 'loading' ? 0.5 : undefined
        };
      } else {
        currentTasks[taskId].priority = priority;
      }
      return currentTasks;
    });
  },
  
  updateTaskStatus: (taskId: string, status: TaskStatus, message?: string) => {
    tasks.update(currentTasks => {
      if (currentTasks[taskId]) {
        if (currentTasks[taskId].status !== 'loaded' || status !== 'loading') {
          currentTasks[taskId].status = status;
          if (message) currentTasks[taskId].message = message;
          if (status === 'loaded' || status === 'error') {
            currentTasks[taskId].progress = 1;
          }
        }
      } else {
        currentTasks[taskId] = { 
          id: taskId, 
          status: status, 
          message: message,
          progress: status === 'loaded' ? 1 : 0
        };
      }
      return currentTasks;
    });
  },
  
  updateTaskProgress: (taskId: string, progress: number) => {
    tasks.update(currentTasks => {
      if (currentTasks[taskId]) {
        currentTasks[taskId].progress = Math.max(0, Math.min(1, progress));
      }
      return currentTasks;
    });
  },
  
  getTaskStatus: (taskId: string): TaskStatus | undefined => {
    const currentTasks = get(tasks);
    return currentTasks[taskId]?.status;
  },
  
  resetTasks: () => {
    tasks.set({});
    initialSiteLoadComplete.set(false);
    assetLoadingStatus.set({});
    // --- MODIFICATION: Reset the section state store as well ---
    sectionStateStore.reset();
  },

  getAssetStatus: (url: string): AssetStatus => {
    return get(assetLoadingStatus)[url] || 'idle';
  },

  setAssetStatus: (url: string, status: AssetStatus) => {
    assetLoadingStatus.update(current => {
      current[url] = status;
      return current;
    });
  }
};

export const overallLoadingState = derived(tasks, $tasks => {
  const allTasksArray = Object.values($tasks);

  if (allTasksArray.length === 0) return 'idle';
  if (allTasksArray.some(task => task.status === 'error')) return 'error';
  if (allTasksArray.every(task => task.status === 'loaded')) return 'loaded';
  if (allTasksArray.some(task => task.status === 'loading' || task.status === 'pending')) return 'loading';
  return 'idle';
});

export const startLoadingTask = (taskId: string, priority: number = 1) => {
  preloadingStore.registerTask(taskId, 'loading', priority);
};

/**
 * A robust, generic function to preload an array of assets (images, fonts, etc.).
 * It updates the central asset status store to prevent re-downloads.
 * @param urls An array of asset URLs to load.
 * @returns A promise that resolves when all assets are loaded, or rejects on the first error.
 */
export async function preloadAssets(urls: string[]): Promise<void> {
  const promises: Promise<unknown>[] = [];

  for (const url of urls) {
    const status = preloadingStore.getAssetStatus(url);
    if (status === 'loaded' || status === 'loading') {
      continue;
    }
    
    preloadingStore.setAssetStatus(url, 'loading');

    const promise = new Promise((resolve, reject) => {
      // Basic image preloader
      if (/\.(jpg|jpeg|png|webp|gif|svg)$/i.test(url)) {
        const img = new Image();
        img.src = url;
        img.onload = () => {
          preloadingStore.setAssetStatus(url, 'loaded');
          resolve(url);
        };
        img.onerror = () => {
          preloadingStore.setAssetStatus(url, 'error');
          reject(new Error(`Failed to load image: ${url}`));
        };
      } 
      // Basic font preloader (for .json from FontLoader)
      else if (/\.json$/i.test(url)) {
        fetch(url)
          .then(response => {
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return response.json();
          })
          .then(() => {
            preloadingStore.setAssetStatus(url, 'loaded');
            resolve(url);
          })
          .catch(error => {
            preloadingStore.setAssetStatus(url, 'error');
            reject(new Error(`Failed to load font data: ${url} - ${error.message}`));
          });
      }
      // Add other file types (videos, etc.) here if needed
      else {
        console.warn(`Preloading not implemented for file type: ${url}`);
        resolve(url); // Resolve unsupported types immediately
      }
    });
    promises.push(promise);
  }

  await Promise.all(promises);
}
--- END OF FILE src\lib\stores\preloadingStore.ts ---

--- START OF FILE src\lib\three\BloomEffect.ts ---
// src/lib/three/BloomEffect.ts
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';

export class BloomEffect {
    private renderer: THREE.WebGLRenderer;
    private scene: THREE.Scene;
    // MODIFIED: Camera type is now more generic to support Orthographic camera
    private camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;
    
    public composer: EffectComposer;
    private renderPass: RenderPass;
    private bloomPass: UnrealBloomPass;
    private outputPass: OutputPass;

    // Bloom Parameters (shared default configuration)
    private bloomParams = {
        threshold: 0.4,
        strength: 0.15,
        radius: 0.1,
    };

    constructor(
        renderer: THREE.WebGLRenderer, 
        scene: THREE.Scene, 
        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,
        width: number, 
        height: number
    ) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;

        this.composer = new EffectComposer(this.renderer);
        this.composer.setSize(width, height);
        this.composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // 1. Render the original scene
        this.renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(this.renderPass);

        // 2. Apply bloom
        this.bloomPass = new UnrealBloomPass(
            new THREE.Vector2(width, height),
            this.bloomParams.strength,
            this.bloomParams.radius,
            this.bloomParams.threshold
        );
        this.composer.addPass(this.bloomPass);
        
        // 3. Output the result (handles tone mapping and color space conversion)
        this.outputPass = new OutputPass();
        this.composer.addPass(this.outputPass);
    }

    public render(deltaTime: number): void {
        this.composer.render(deltaTime);
    }

    public setSize(width: number, height: number): void {
        this.composer.setSize(width, height);
        this.composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }

    public updateParameters(params: { threshold?: number; strength?: number; radius?: number }): void {
        if (params.threshold !== undefined) this.bloomPass.threshold = params.threshold;
        if (params.strength !== undefined) this.bloomPass.strength = params.strength;
        if (params.radius !== undefined) this.bloomPass.radius = params.radius;
    }

    public dispose(): void {
        // EffectComposer automatically disposes its passes' render targets
        // if they were created internally by the composer or pass.
    }
}
--- END OF FILE src\lib\three\BloomEffect.ts ---

--- START OF FILE src\lib\three\heroParticleLogic.ts ---
// src/lib/three/heroParticleLogic.ts
import * as THREE from 'three';
import type { Font } from 'three/examples/jsm/loaders/FontLoader.js';
import { BloomEffect } from './BloomEffect';

// Shaders (VERTEX_SHADER and FRAGMENT_SHADER remain the same)
export const VERTEX_SHADER = `
attribute float size;
attribute vec3 customColor;
attribute float symbolState;
attribute float symbolIndex;
attribute float variability;

varying vec3 vColor;
varying float vSymbolState;
varying float vSymbolIndex;
varying float vVariability;

void main() {
  vColor = customColor;
  vSymbolState = symbolState;
  vSymbolIndex = symbolIndex;
  vVariability = variability;
  
  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
  gl_PointSize = size * (300.0 / -mvPosition.z);
  gl_Position = projectionMatrix * mvPosition;
}
`;

export const FRAGMENT_SHADER = `
uniform sampler2D pointTexture;
uniform sampler2D symbolsTexture;
uniform float symbolRows;

varying vec3 vColor;
varying float vSymbolState;
varying float vSymbolIndex;
varying float vVariability;

void main() {
  if(vSymbolState < 0.5) { // It's a normal particle (dot)
    gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
  } 
  else { // It's a symbol
    const float symbolsPerRow = 8.0;
    float symbolIndexVal = vSymbolIndex;
    
    float columnIndex = mod(symbolIndexVal, symbolsPerRow);
    float rowIndex = floor(symbolIndexVal / symbolsPerRow);
    
    vec2 symbolCoord = gl_PointCoord;
    symbolCoord.x = (symbolCoord.x + columnIndex) / symbolsPerRow;
    symbolCoord.y = (symbolCoord.y + rowIndex) / symbolRows; // Use dynamic row count
    
    vec4 symbolTexColor = texture2D(symbolsTexture, symbolCoord);
    
    if(symbolTexColor.a < 0.3) discard; // Discard transparent parts of the symbol
    
    gl_FragColor = vec4(vColor, symbolTexColor.a); 
  }
}
`;

export class Environment {
  public font: Font;
  public particleTexture: THREE.Texture;
  public container: HTMLElement;
  public scene!: THREE.Scene;
  public camera!: THREE.PerspectiveCamera;
  public renderer!: THREE.WebGLRenderer;
  public createParticles!: CreateParticles;
  private animationLoopCallback: (() => void) | null = null;

  private clock!: THREE.Clock; 
  private bloomEffect!: BloomEffect;

  constructor(font: Font, particleTexture: THREE.Texture, container: HTMLElement) {
    this.font = font;
    this.particleTexture = particleTexture;
    this.container = container;
    
    if (!this.container) {
      console.error("HeroParticleLogic: Container not provided to Environment!");
      return;
    }
    
    this.clock = new THREE.Clock(); 

    this.scene = new THREE.Scene();
    this.createCamera();
    this.createRenderer();
    
    this.bloomEffect = new BloomEffect(
        this.renderer, 
        this.scene, 
        this.camera, 
        this.container.clientWidth, 
        this.container.clientHeight
    );

    this.setup(); 
    this.bindWindowResize();

    if (this.renderer) {
        this.startAnimationLoop();
    }
  }

  public startAnimationLoop() {
    if (this.renderer && !this.animationLoopCallback) {
        this.animationLoopCallback = () => { this.render(); };
        this.renderer.setAnimationLoop(this.animationLoopCallback);
        console.log("HeroParticleLogic: Animation loop started.");
    }
  }

  public stopAnimationLoop() {
    if (this.renderer && this.animationLoopCallback) {
        this.renderer.setAnimationLoop(null);
        this.animationLoopCallback = null;
        console.log("HeroParticleLogic: Animation loop stopped.");
    }
  }

  public isLooping(): boolean {
    return !!this.animationLoopCallback;
  }

  private bindWindowResize() {
    window.addEventListener('resize', this.onWindowResize.bind(this));
  }

  private unbindWindowResize() {
    window.removeEventListener('resize', this.onWindowResize.bind(this));
  }

  private setup() {
    this.createParticles = new CreateParticles(
      this.scene, 
      this.font, 
      this.particleTexture, 
      this.camera, 
      this.renderer, 
      this.container 
    );
  }

  public render() {
    const deltaTime = this.clock.getDelta();

    if (this.createParticles) {
      this.createParticles.render(); 
    }
    
    if (this.bloomEffect) {
      this.bloomEffect.render(deltaTime);
    } else if (this.renderer && this.scene && this.camera) { 
      this.renderer.render(this.scene, this.camera);
    }
  }

  private createCamera() {
    this.camera = new THREE.PerspectiveCamera(
      65, 
      this.container.clientWidth / this.container.clientHeight, 
      1, 
      10000
    );
    this.camera.position.set(0, 0, 100);
  }

  private createRenderer() {
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true 
    });
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    if (THREE.ColorManagement.enabled) { 
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
    } else { 
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
    }
    
    this.container.appendChild(this.renderer.domElement);
  }
  public onWindowResize() {
    if (this.camera && this.renderer && this.container) {
      const newWidth = this.container.clientWidth;
      const newHeight = this.container.clientHeight;

      this.camera.aspect = newWidth / newHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(newWidth, newHeight);
      
      if (this.bloomEffect) {
        this.bloomEffect.setSize(newWidth, newHeight);
      }
      
      // Check for screen size changes and regenerate particles if needed
      if (this.createParticles) {
        if (this.createParticles.checkScreenSizeChange()) {
          this.createParticles.regenerateParticles();
        }
      }
    }
  }

  public dispose() {
    console.log("HeroParticleLogic: Disposing Environment");
    this.stopAnimationLoop();
    this.unbindWindowResize();
    if (this.createParticles) {
      this.createParticles.dispose();
    }
    if (this.bloomEffect) {
        this.bloomEffect.dispose();
    }
    if (this.renderer) {
      this.renderer.dispose();
      if (this.renderer.domElement && this.renderer.domElement.parentNode) {
        this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
      }
    }
    if (this.scene) {
        this.scene.traverse(object => {
            const obj = object as THREE.Mesh; 
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach((material: THREE.Material) => material.dispose());
                } else {
                    (obj.material as THREE.Material).dispose();
                }
            }
        });
    }
  }
}

interface ParticleData {
  text: string;
  amount: number;
  particleSize: number;
  textSize: number;
  area: number;
  ease: number;
  distortionThreshold: number;
  // maxCooldownTime: number; // REMOVED - Replaced by min/max duration
  minFadeOutRate: number;
  maxFadeOutRate: number;
  minSymbolSize: number;
  maxSymbolSize: number;
  symbolMinThreshold: number;
  symbolMidThreshold: number;
  symbolMaxThreshold: number;
  symbolMinProb: number;
  symbolMaxProb: number;
  symbolHeatRequirement: number;
  // --- NEW Cooldown Parameters ---
  particleCooldownDurationMin: number;
  particleCooldownDurationMax: number;
  symbolCooldownSpeedMultiplier: number;  // --- END NEW Cooldown Parameters ---
}

// Screen size categories for responsive design
type ScreenSizeType = 'mobile' | 'tablet' | 'laptop' | 'desktop' | 'large' | 'ultrawide';

export class CreateParticles {
  private scene: THREE.Scene;
  private font: Font;
  private particleImg: THREE.Texture;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer; 
  private hostContainer: HTMLElement; 

  private raycaster: THREE.Raycaster;
  private mouse: THREE.Vector2;
  private isPressed: boolean = false;
  private hasMouseMoved: boolean = false; 

  private matrixSymbols: string[];
  private matrixColors: { [key: string]: THREE.Color };
  private bloomSymbolColor: THREE.Color; 
  
  private particleStates: number[] = [];
  private heatLevels: number[] = [];
  private cooldownRates: number[] = [];
  private symbolIndicesAttributeValues: number[] = [];
  private fadeOutRates: number[] = [];

  private data: ParticleData;
  private symbolsTexture!: THREE.Texture;
  private planeArea!: THREE.Mesh; 
  public particles!: THREE.Points;
  private geometryCopy!: THREE.BufferGeometry;

  private boundOnMouseDown: (event: MouseEvent) => void;
  private boundOnMouseMove: (event: MouseEvent) => void;
  private boundOnMouseUp: (event: MouseEvent) => void;
  private boundOnTouchStart: (event: TouchEvent) => void;
  private boundOnTouchMove: (event: TouchEvent) => void;
  private boundOnTouchEnd: (event: TouchEvent) => void;

  // Responsive design related properties
  private currentScreenSizeType: ScreenSizeType = 'desktop';
  private lastKnownWidth: number = 0;
  private lastKnownHeight: number = 0;
  private needsParticleRegeneration: boolean = false;

  // These constants control the symbol color variation
  private readonly SYMBOL_HUE_SHIFT_RANGE = 0.03;           // Controls hue variation (green tint shifts)
  private readonly SYMBOL_LUMINANCE_REDUCTION_MAX = 0.08;  // Controls brightness variation
  private readonly SYMBOL_MIN_LUMINANCE_TARGET = 0.45;      // Minimum brightness to prevent too-dark symbols

  // Screen size breakpoints
  private readonly SCREEN_SIZES = {
    mobile: { maxWidth: 640 },
    tablet: { minWidth: 641, maxWidth: 1024 },
    laptop: { minWidth: 1025, maxWidth: 1440 },
    desktop: { minWidth: 1441, maxWidth: 1920 },
    large: { minWidth: 1921, maxWidth: 2560 },
    ultrawide: { minWidth: 2561 }
  };

  // Responsive particle parameters for different screen sizes
  private readonly RESPONSIVE_PARAMS: Record<ScreenSizeType, Partial<ParticleData>> = {
    mobile: {
      amount: 1200,
      particleSize: 1.0,
      textSize: 12,
      minSymbolSize: 7,
      maxSymbolSize: 11,
      area: 150
    },
    tablet: {
      amount: 1800,
      particleSize: 1.1,
      textSize: 14,
      minSymbolSize: 7,
      maxSymbolSize: 11,
      area: 200
    },
    laptop: {
      amount: 2200,
      particleSize: 1.2,
      textSize: 15,
      minSymbolSize: 6.5,
      maxSymbolSize: 11,
      area: 230
    },
    desktop: {
      amount: 2400,
      particleSize: 1.4,
      textSize: 16,
      minSymbolSize: 7,
      maxSymbolSize: 11,
      area: 250
    },
    large: {
      amount: 2700,
      particleSize: 1.55,
      textSize: 18,
      minSymbolSize: 8,
      maxSymbolSize: 11,
      area: 280
    },
    ultrawide: {
      amount: 2900,
      particleSize: 1.6,
      textSize: 20,
      minSymbolSize: 9,
      maxSymbolSize: 16,
      area: 300
    }
  };

  private symbolTextureRows: number = 6; // Add this property declaration

  constructor(scene: THREE.Scene, font: Font, particleImg: THREE.Texture, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, hostContainer: HTMLElement) {
    this.scene = scene;
    this.font = font;
    this.particleImg = particleImg;
    this.camera = camera;
    this.renderer = renderer; 
    this.hostContainer = hostContainer;
    this.isPressed = false;

    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2(1e5, 1e5);

    this.matrixSymbols = [ 
      '日', '〇', 'ﾊ', 'ﾐ', 'ﾋ', 'ｰ', 'ｳ', 'ｼ', 'ﾅ', 'ﾓ', 'ﾆ', 'ｻ', 'ﾜ',
      'ﾂ', 'ｵ', 'ﾘ', 'ｱ', 'ﾎ', 'ﾃ', 'ﾏ', 'ｹ', 'ﾒ', 'ｴ', 'ｶ', 'ｷ', 'ﾑ', 
      'ﾕ', 'ﾗ', 'ｾ', 'ﾈ', 'ｦ', 'ｲ', 'ｸ', 'ｺ', 'ｿ', 'ﾀ', 'ﾁ', 'ﾄ', 'ﾉ', 'ﾌ', 'ﾍ', 'ﾏ', 'ﾔ', 'ﾖ', 'ﾙ', 'ﾚ', 'ﾛ',
      '∆','δ', 'ε', 'ζ', 'η', 'θ', '∃', '∄','∅','ﾊ', 'ﾍ', 'ﾎ', 'ﾞ', 'ﾟ', 'ｧ', 'ｨ', 'ｩ', 'ｪ', 'ｫ', 'ｬ', 'ｭ', 'ｮ', 'ｯ','Д'
    ];
    
    this.matrixColors = {
      white: new THREE.Color(1.0, 1.0, 1.0),
      verySubtleGreenTint: new THREE.Color(0.9, 1.0, 0.9), 
      almostWhiteGreen: new THREE.Color(0.8, 1.0, 0.8),
      paleGreen: new THREE.Color(0.58, 1.0, 0.58),
      lightMatrixGreen: new THREE.Color(0.3, 1.0, 0.3),
      classicMatrixGreen: new THREE.Color(0.0, 1.0, 0.0),
      deepMatrixGreen: new THREE.Color(0.0, 0.85, 0.0)
    };

    this.bloomSymbolColor = new THREE.Color(0.0, 0.95, 0.05); 

    // Base configuration (will be adjusted for screen size)
    this.data = { 
      text: "Hi, I'm\nMiká",
      amount: 2700,
      particleSize: 1.5,
      textSize: 16,
      area: 250, 
      ease: .05, 
      distortionThreshold: 12,
      minFadeOutRate: 0.09,
      maxFadeOutRate: 0.12,
      minSymbolSize: 7,
      maxSymbolSize: 12,
      symbolMinThreshold: 13,
      symbolMidThreshold: 20,
      symbolMaxThreshold: 40,
      symbolMinProb: 0.001,
      symbolMaxProb: 0.15,
      symbolHeatRequirement: 0.4,
      particleCooldownDurationMin: 200, 
      particleCooldownDurationMax: 340,
      symbolCooldownSpeedMultiplier: 3.1,
    };
    
    // Track the container dimensions to detect significant changes
    this.lastKnownWidth = this.hostContainer.clientWidth;
    this.lastKnownHeight = this.hostContainer.clientHeight;
    
    // Determine initial screen size and apply responsive settings
    this.currentScreenSizeType = this.getScreenSizeType();
    this.applyResponsiveParameters(this.currentScreenSizeType);
    
    // Log the detected screen size and particle configuration
    console.log(`🖥️ Hero Particle Effect - Screen Size Detection:`);
    console.log(`   Screen dimensions: ${this.lastKnownWidth}x${this.lastKnownHeight}px`);
    console.log(`   Detected screen type: ${this.currentScreenSizeType.toUpperCase()}`);
    console.log(`   Particle configuration:`);
    console.log(`     • Particle count: ${this.data.amount}`);
    console.log(`     • Particle size: ${this.data.particleSize}`);
    console.log(`     • Text size: ${this.data.textSize}px`);
    console.log(`     • Symbol size range: ${this.data.minSymbolSize} - ${this.data.maxSymbolSize}`);
    console.log(`     • Effect area: ${this.data.area}`);
    
    this.boundOnMouseDown = this.onMouseDown.bind(this);
    this.boundOnMouseMove = this.onMouseMove.bind(this);
    this.boundOnMouseUp = this.onMouseUp.bind(this);
    this.boundOnTouchStart = this.onTouchStart.bind(this);
    this.boundOnTouchMove = this.onTouchMove.bind(this);
    this.boundOnTouchEnd = this.onTouchEnd.bind(this);
    
    this.createMatrixSymbolsTexture();
    this.setupPlaneArea();
    this.createText();
  }

  private getMatrixColor(heatLevel: number): THREE.Color {
    if (heatLevel <= 0.05) return this.matrixColors.white;                
    if (heatLevel <= 0.18) return this.matrixColors.verySubtleGreenTint; 
    if (heatLevel <= 0.35) return this.matrixColors.almostWhiteGreen;     
    if (heatLevel <= 0.55) return this.matrixColors.paleGreen;            
    if (heatLevel <= 0.75) return this.matrixColors.lightMatrixGreen;
    if (heatLevel <= 0.92) return this.matrixColors.classicMatrixGreen;   
    return this.matrixColors.deepMatrixGreen;                             
  }

  private getSymbolProbability(distortion: number): number {
    const { symbolMinThreshold, symbolMidThreshold, symbolMaxThreshold, symbolMinProb, symbolMaxProb } = this.data;
    if (distortion < symbolMinThreshold) return 0;
    if (distortion >= symbolMaxThreshold) return symbolMaxProb; 
    if (distortion < symbolMidThreshold) {
      const ratio = (distortion - symbolMinThreshold) / (symbolMidThreshold - symbolMinThreshold);
      return symbolMinProb + (symbolMaxProb / 10) * Math.pow(ratio, 3);
    } else {
      const ratio = (distortion - symbolMidThreshold) / (symbolMaxThreshold - symbolMidThreshold);
      return (symbolMaxProb / 10) + 
             (symbolMaxProb - symbolMaxProb / 10) * Math.pow(ratio, 1.5);
    }
  }

  private initParticleStates(count: number) { 
    this.particleStates = new Array(count).fill(0);
    this.heatLevels = new Array(count).fill(0);
    this.cooldownRates = new Array(count);
    this.symbolIndicesAttributeValues = new Array(count);
    this.fadeOutRates = new Array(count);
    // Remove symbolSizesMultipliers array since we generate sizes dynamically
    
    for (let i = 0; i < count; i++) {
      this.symbolIndicesAttributeValues[i] = Math.floor(Math.random() * this.matrixSymbols.length);
      
      // --- MODIFIED Cooldown Rate Calculation ---
      const randomDuration = this.data.particleCooldownDurationMin + 
                             Math.random() * (this.data.particleCooldownDurationMax - this.data.particleCooldownDurationMin);
      this.cooldownRates[i] = 1 / Math.max(1, randomDuration); // Rate is 1/duration. Ensure duration > 0.
      // --- END MODIFIED ---

      this.fadeOutRates[i] = this.data.minFadeOutRate + Math.random() * (this.data.maxFadeOutRate - this.data.minFadeOutRate);
      // Remove pre-calculation of symbol sizes
    }
  }

  private createMatrixSymbolsTexture() {
    // Calculate required rows based on symbol count
    const cols = 8;
    const symbolSize = 64;
    const rows = Math.ceil(this.matrixSymbols.length / cols);
    
    const canvas = document.createElement('canvas');
    canvas.width = cols * symbolSize; 
    canvas.height = rows * symbolSize;
    const ctx = canvas.getContext('2d')!;
    
    // Clear canvas with transparent background
    ctx.fillStyle = 'rgba(0,0,0,0)'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Improved font rendering settings
    ctx.font = 'bold 48px "Courier New", monospace';
    ctx.textAlign = 'center'; 
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#00FF00';
    
    // Enable better text rendering (remove invalid textRenderingOptimization)
    if (ctx.imageSmoothingEnabled !== undefined) {
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
    }
    
    for (let i = 0; i < this.matrixSymbols.length; i++) {
      const col = i % cols; 
      const row = Math.floor(i / cols);
      const x = col * symbolSize + symbolSize / 2; 
      const y = row * symbolSize + symbolSize / 2;
      
      // Add slight padding to prevent edge clipping
      const symbol = this.matrixSymbols[i];
      ctx.fillText(symbol, x, y);
    }
    
    this.symbolsTexture = new THREE.Texture(canvas);
    this.symbolsTexture.needsUpdate = true;
    this.symbolsTexture.generateMipmaps = false;
    this.symbolsTexture.minFilter = THREE.LinearFilter;
    this.symbolsTexture.magFilter = THREE.LinearFilter;
    this.symbolsTexture.wrapS = THREE.ClampToEdgeWrapping;
    this.symbolsTexture.wrapT = THREE.ClampToEdgeWrapping;
    
    // Store the row count for the shader
    this.symbolTextureRows = rows;
    
    // Log texture info for debugging
    console.log(`Symbol texture created: ${cols}x${rows} grid (${this.matrixSymbols.length} symbols)`);
  }

  private setupPlaneArea() {
    const planeZ = 0;
    const planeWidth = this.visibleWidthAtZDepth(planeZ, this.camera);
    const planeHeight = this.visibleHeightAtZDepth(planeZ, this.camera);

    const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
    const material = new THREE.MeshBasicMaterial({ 
        transparent: true, 
        opacity: 0, 
        depthWrite: false 
    });
    this.planeArea = new THREE.Mesh(geometry, material);
    this.planeArea.position.z = planeZ;
    this.planeArea.visible = true;
    this.scene.add(this.planeArea);
  }

  private createText() {
    const thePoints: THREE.Vector3[] = [];
    const colorsArr: number[] = []; 
    const sizesArr: number[] = []; 
    const symbolStatesArr: number[] = []; 
    const symbolIndicesArrForAttribute: number[] = []; 
    const variabilitiesArr: number[] = [];

    if (!this.font) { console.error("HeroParticleLogic: Font not available for createText"); return; }

    const mainShapes = this.font.generateShapes(this.data.text, this.data.textSize);
    const allPaths: THREE.Path[] = [];
    mainShapes.forEach(shape => {
        allPaths.push(shape); 
        if (shape.holes && shape.holes.length > 0) {
            allPaths.push(...shape.holes); 
        }
    });
    
    const tempShapeGeometry = new THREE.ShapeGeometry(mainShapes); 
    tempShapeGeometry.computeBoundingBox();
    const xMid = -0.5 * (tempShapeGeometry.boundingBox!.max.x - tempShapeGeometry.boundingBox!.min.x);
    const yMid = (tempShapeGeometry.boundingBox!.max.y - tempShapeGeometry.boundingBox!.min.y) / 2.85; 
    tempShapeGeometry.dispose();

    let totalLength = 0;
    allPaths.forEach(path => totalLength += path.getLength());
    if (totalLength === 0) totalLength = 1; 

    const initialColor = this.matrixColors.white; 

    allPaths.forEach(path => {
      const pathLength = path.getLength();
      const numPointsForThisPath = Math.max(10, Math.floor((pathLength / totalLength) * this.data.amount));
      const points = path.getSpacedPoints(numPointsForThisPath);
      
      points.forEach(p => {
        thePoints.push(new THREE.Vector3(p.x, p.y, 0));
        colorsArr.push(initialColor.r, initialColor.g, initialColor.b); 
        sizesArr.push(this.data.particleSize);
        symbolStatesArr.push(0); 
        symbolIndicesArrForAttribute.push(Math.floor(Math.random() * this.matrixSymbols.length));
        variabilitiesArr.push(Math.random());
      });
    });
    
    const finalPointCount = thePoints.length;
    if (colorsArr.length / 3 !== finalPointCount) { colorsArr.length = finalPointCount * 3; for(let i=0; i<finalPointCount; ++i) colorsArr.splice(i*3, 3, initialColor.r, initialColor.g, initialColor.b); }
    if (sizesArr.length !== finalPointCount) { sizesArr.length = finalPointCount; sizesArr.fill(this.data.particleSize); }
    if (symbolStatesArr.length !== finalPointCount) { symbolStatesArr.length = finalPointCount; symbolStatesArr.fill(0); }
    if (symbolIndicesArrForAttribute.length !== finalPointCount) { symbolIndicesArrForAttribute.length = finalPointCount; for(let i=0; i<finalPointCount; ++i) symbolIndicesArrForAttribute[i] = Math.floor(Math.random() * this.matrixSymbols.length); }
    if (variabilitiesArr.length !== finalPointCount) { variabilitiesArr.length = finalPointCount; for(let i=0; i<finalPointCount; ++i) variabilitiesArr[i] = Math.random(); }


    const geoParticles = new THREE.BufferGeometry().setFromPoints(thePoints);
    geoParticles.translate(xMid, yMid, 0); 
    geoParticles.setAttribute('customColor', new THREE.Float32BufferAttribute(colorsArr, 3));
    geoParticles.setAttribute('size', new THREE.Float32BufferAttribute(sizesArr, 1));
    geoParticles.setAttribute('symbolState', new THREE.Float32BufferAttribute(symbolStatesArr, 1));
    geoParticles.setAttribute('symbolIndex', new THREE.Float32BufferAttribute(symbolIndicesArrForAttribute, 1));
    geoParticles.setAttribute('variability', new THREE.Float32BufferAttribute(variabilitiesArr, 1));

    const particleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        pointTexture: { value: this.particleImg },
        symbolsTexture: { value: this.symbolsTexture },
        symbolRows: { value: this.symbolTextureRows } // Add dynamic row count uniform
      },
      vertexShader: VERTEX_SHADER,
      fragmentShader: FRAGMENT_SHADER,
      blending: THREE.NormalBlending, 
      depthTest: false, 
      transparent: true, 
    });

    this.particles = new THREE.Points(geoParticles, particleMaterial);
    this.scene.add(this.particles);
    this.geometryCopy = new THREE.BufferGeometry().copy(this.particles.geometry);
    this.initParticleStates(thePoints.length);
   }

  public bindInteractionEvents() {
    this.hostContainer.addEventListener('mousedown', this.boundOnMouseDown);
    this.hostContainer.addEventListener('mousemove', this.boundOnMouseMove);
    document.addEventListener('mouseup', this.boundOnMouseUp); 

    this.hostContainer.addEventListener('touchstart', this.boundOnTouchStart, { passive: false });
    this.hostContainer.addEventListener('touchmove', this.boundOnTouchMove, { passive: false });
    this.hostContainer.addEventListener('touchend', this.boundOnTouchEnd, { passive: false });
    this.isPressed = false;
  }

  public unbindInteractionEvents() {
    this.hostContainer.removeEventListener('mousedown', this.boundOnMouseDown);
    this.hostContainer.removeEventListener('mousemove', this.boundOnMouseMove);
    document.removeEventListener('mouseup', this.boundOnMouseUp);

    this.hostContainer.removeEventListener('touchstart', this.boundOnTouchStart);
    this.hostContainer.removeEventListener('touchmove', this.boundOnTouchMove);
    this.hostContainer.removeEventListener('touchend', this.boundOnTouchEnd);
    
    this.neutralizeLastMousePosition();
  }

  public neutralizeLastMousePosition() {
    this.mouse.set(1e5, 1e5); 
    this.hasMouseMoved = false; 
    this.isPressed = false; 
  }

  private onMouseDown(event: MouseEvent) { this.updateMousePosition(event.clientX, event.clientY); this.isPressed = true; this.data.ease = .01; }
  private onMouseUp() { this.isPressed = false; this.data.ease = .05; }
  private onMouseMove(event: MouseEvent) { 
    if (!this.hasMouseMoved) this.hasMouseMoved = true; 
    this.updateMousePosition(event.clientX, event.clientY); 
  }
  private onTouchStart(event: TouchEvent) { if (event.touches.length > 0) { this.updateMousePosition(event.touches[0].clientX, event.touches[0].clientY); this.isPressed = true; this.data.ease = .01; this.hasMouseMoved = true; } event.preventDefault(); }
  private onTouchMove(event: TouchEvent) { if (event.touches.length > 0) { this.hasMouseMoved = true; this.updateMousePosition(event.touches[0].clientX, event.touches[0].clientY); } event.preventDefault(); }
  private onTouchEnd(event: TouchEvent) { this.isPressed = false; this.data.ease = .05; event.preventDefault(); }
  
  private updateMousePosition(clientX: number, clientY: number) {
    const rect = this.hostContainer.getBoundingClientRect();
    this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
  }

  private getVariedSymbolColor(): THREE.Color {
    const variedColor = this.bloomSymbolColor.clone(); // Base color: (0.0, 0.95, 0.05)
    const hsl = { h: 0, s: 0, l: 0 };
    variedColor.getHSL(hsl); 

    // HUE VARIATION: Shifts the green tint slightly
    const hueOffset = (Math.random() - 0.5) * this.SYMBOL_HUE_SHIFT_RANGE;
    hsl.h += hueOffset;
    hsl.h = (hsl.h + 1.0) % 1.0; 

    // LUMINANCE VARIATION: Makes some symbols brighter/dimmer
    const luminanceReduction = Math.random() * this.SYMBOL_LUMINANCE_REDUCTION_MAX;
    hsl.l -= luminanceReduction;
    
    // Ensure minimum brightness
    hsl.l = Math.max(this.SYMBOL_MIN_LUMINANCE_TARGET, hsl.l);
    hsl.l = Math.min(1.0, hsl.l);

    variedColor.setHSL(hsl.h, hsl.s, hsl.l); 
    return variedColor;
  }

  public render() {
    if (!this.particles || !this.planeArea || !this.camera) return; 

    if (!this.hasMouseMoved && !this.isPressed) {
        if (this.particles && this.geometryCopy) {
            const pos = this.particles.geometry.attributes.position as THREE.BufferAttribute;
            const copyPos = this.geometryCopy.attributes.position as THREE.BufferAttribute;
            let changed = false;
            for (let i = 0, l = pos.count; i < l; i++) {
                const initX = copyPos.getX(i); const initY = copyPos.getY(i); const initZ = copyPos.getZ(i);
                let px = pos.getX(i); let py = pos.getY(i); let pz = pos.getZ(i);
                const prevPx = px; const prevPy = py; const prevPz = pz;

                px += (initX - px) * this.data.ease; 
                py += (initY - py) * this.data.ease; 
                pz += (initZ - pz) * this.data.ease;
                pos.setXYZ(i, px, py, pz);
                if (px !== prevPx || py !== prevPy || pz !== prevPz) changed = true;
            }
            if (changed) pos.needsUpdate = true;
        }
        return; 
    }

    this.raycaster.setFromCamera(this.mouse, this.camera);
    const intersects = this.raycaster.intersectObject(this.planeArea);

    let attributesNeedUpdate = false;

    if (intersects.length > 0) {
      const pos = this.particles.geometry.attributes.position as THREE.BufferAttribute;
      const copyPos = this.geometryCopy.attributes.position as THREE.BufferAttribute;
      const colors = this.particles.geometry.attributes.customColor as THREE.BufferAttribute;
      const sizes = this.particles.geometry.attributes.size as THREE.BufferAttribute;
      const symbolStates = this.particles.geometry.attributes.symbolState as THREE.BufferAttribute;
      const symbolIndicesBuffer = this.particles.geometry.attributes.symbolIndex as THREE.BufferAttribute;

      const mx = intersects[0].point.x;
      const my = intersects[0].point.y;

      for (let i = 0, l = pos.count; i < l; i++) {
        const initX = copyPos.getX(i); const initY = copyPos.getY(i); const initZ = copyPos.getZ(i);
        let px = pos.getX(i); let py = pos.getY(i); let pz = pos.getZ(i);

        const dx = mx - px; const dy = my - py;
        const mouseDistance = Math.sqrt(dx * dx + dy * dy);
        const dSquared = Math.max(1e-5, dx * dx + dy * dy); 
        const f = -this.data.area / dSquared;

        if (this.isPressed) {
          const t = Math.atan2(dy, dx);
          px -= f * Math.cos(t); py -= f * Math.sin(t);
          this.heatLevels[i] = Math.min(this.heatLevels[i] + 0.1, 1.0);
          attributesNeedUpdate = true;
        } else if (mouseDistance < this.data.area) {
          const t = Math.atan2(dy, dx);
          px += f * Math.cos(t); py += f * Math.sin(t);
          attributesNeedUpdate = true;
          const distortion = Math.sqrt(Math.pow(px - initX, 2) + Math.pow(py - initY, 2));
          
          if (distortion > this.data.distortionThreshold) {
            this.heatLevels[i] = Math.min(this.heatLevels[i] + Math.min(distortion / 50, 0.1), 1.0);
            if (this.particleStates[i] === 0 && this.heatLevels[i] > this.data.symbolHeatRequirement) {
              if (Math.random() < this.getSymbolProbability(distortion)) {
                this.particleStates[i] = 1; 
                symbolStates.setX(i, 1.0);
                
                // FIXED: Generate random size and symbol index each time a particle becomes a symbol
                const randomSymbolSize = this.data.minSymbolSize + Math.random() * (this.data.maxSymbolSize - this.data.minSymbolSize);
                const randomSymbolIndex = Math.floor(Math.random() * this.matrixSymbols.length);
                
                sizes.setX(i, this.data.particleSize * randomSymbolSize);
                symbolIndicesBuffer.setX(i, randomSymbolIndex);
                
                const symbolColorToRender = this.getVariedSymbolColor();
                colors.setXYZ(i, symbolColorToRender.r, symbolColorToRender.g, symbolColorToRender.b);
                attributesNeedUpdate = true; 
              }
            }
          }
        }

        if (this.particleStates[i] === 1) { 
          const currentSize = sizes.getX(i);
          const newSize = Math.max(this.data.particleSize, currentSize - this.fadeOutRates[i]);
          if (currentSize !== newSize) {
             sizes.setX(i, newSize);
             attributesNeedUpdate = true;
          }
          // --- MODIFIED Symbol Cooldown ---
          this.heatLevels[i] = Math.max(0, this.heatLevels[i] - (this.cooldownRates[i] * this.data.symbolCooldownSpeedMultiplier));
          // --- END MODIFIED ---
          
          // FIXED: Use a small tolerance instead of exact comparison to handle floating point precision
          const fadeThreshold = this.data.particleSize + 0.01; // Small tolerance for floating point comparison
          if (newSize <= fadeThreshold) {
            this.particleStates[i] = 0; 
            symbolStates.setX(i, 0.0);
            sizes.setX(i, this.data.particleSize); 
            attributesNeedUpdate = true;
          }
        } else { 
          const matrixColor = this.getMatrixColor(this.heatLevels[i]);
          if (colors.getX(i) !== matrixColor.r || colors.getY(i) !== matrixColor.g || colors.getZ(i) !== matrixColor.b) {
            colors.setXYZ(i, matrixColor.r, matrixColor.g, matrixColor.b);
            attributesNeedUpdate = true;
          }
        }
        
        if (this.heatLevels[i] > 0 && this.particleStates[i] === 0) { // For normal particles
          this.heatLevels[i] = Math.max(0, this.heatLevels[i] - this.cooldownRates[i]);
        }

        const prevPx = px; const prevPy = py; const prevPz = pz;
        px += (initX - px) * this.data.ease; 
        py += (initY - py) * this.data.ease; 
        pz += (initZ - pz) * this.data.ease;
        
        if (px !== prevPx || py !== prevPy || pz !== prevPz) {
            pos.setXYZ(i, px, py, pz);
            attributesNeedUpdate = true;
        }
      }
    } else { 
        const pos = this.particles.geometry.attributes.position as THREE.BufferAttribute;
        const copyPos = this.geometryCopy.attributes.position as THREE.BufferAttribute;
        for (let i = 0, l = pos.count; i < l; i++) {
            const initX = copyPos.getX(i); const initY = copyPos.getY(i); const initZ = copyPos.getZ(i);
            let px = pos.getX(i); let py = pos.getY(i); let pz = pos.getZ(i);
            const prevPx = px; const prevPy = py; const prevPz = pz;
            px += (initX - px) * this.data.ease; 
            py += (initY - py) * this.data.ease; 
            pz += (initZ - pz) * this.data.ease;
            if (px !== prevPx || py !== prevPy || pz !== prevPz) {
                pos.setXYZ(i, px, py, pz);
                attributesNeedUpdate = true;
            }
        }
    }
    
    if (attributesNeedUpdate) {
        (this.particles.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;
        (this.particles.geometry.attributes.customColor as THREE.BufferAttribute).needsUpdate = true;
        (this.particles.geometry.attributes.size as THREE.BufferAttribute).needsUpdate = true;
        (this.particles.geometry.attributes.symbolState as THREE.BufferAttribute).needsUpdate = true;
        (this.particles.geometry.attributes.symbolIndex as THREE.BufferAttribute).needsUpdate = true;
    }
  }
  
  public resetParticleState() {
    if (!this.particles || !this.particles.geometry) return;
    
    const colors = this.particles.geometry.attributes.customColor as THREE.BufferAttribute;
    const sizes = this.particles.geometry.attributes.size as THREE.BufferAttribute;
    const symbolStates = this.particles.geometry.attributes.symbolState as THREE.BufferAttribute;
    const symbolIndicesBuffer = this.particles.geometry.attributes.symbolIndex as THREE.BufferAttribute;

    if (!colors || !sizes || !symbolStates || !symbolIndicesBuffer) return;

    const initialColor = this.matrixColors.white;

    for (let i = 0; i < colors.count; i++) {
      colors.setXYZ(i, initialColor.r, initialColor.g, initialColor.b); 
      this.particleStates[i] = 0; 
      this.heatLevels[i] = 0; 
      sizes.setX(i, this.data.particleSize); 
      symbolStates.setX(i, 0.0); 
      
      // Generate fresh random symbol indices
      this.symbolIndicesAttributeValues[i] = Math.floor(Math.random() * this.matrixSymbols.length);
      symbolIndicesBuffer.setX(i, this.symbolIndicesAttributeValues[i]);

      // Generate fresh random fade out rates
      this.fadeOutRates[i] = this.data.minFadeOutRate + Math.random() * (this.data.maxFadeOutRate - this.data.minFadeOutRate);
      // Don't pre-calculate symbol sizes anymore - they're generated when particles become symbols
    }
    colors.needsUpdate = true; sizes.needsUpdate = true; 
    symbolStates.needsUpdate = true; symbolIndicesBuffer.needsUpdate = true;
  }

  private visibleHeightAtZDepth(depth: number, camera: THREE.PerspectiveCamera): number {
    const cameraOffset = camera.position.z;
    const relativeDepth = depth - cameraOffset; 
    const vFOV = camera.fov * Math.PI / 180; 
    return 2 * Math.tan(vFOV / 2) * Math.abs(relativeDepth);
  }
  private visibleWidthAtZDepth(depth: number, camera: THREE.PerspectiveCamera): number {
    return this.visibleHeightAtZDepth(depth, camera) * camera.aspect;
  }

  // Responsive design methods
  private getScreenSizeType(): ScreenSizeType {
    const width = this.hostContainer.clientWidth;
    
    if (width <= this.SCREEN_SIZES.mobile.maxWidth) {
      return 'mobile';
    } else if (width >= this.SCREEN_SIZES.tablet.minWidth && width <= this.SCREEN_SIZES.tablet.maxWidth) {
      return 'tablet';
    } else if (width >= this.SCREEN_SIZES.laptop.minWidth && width <= this.SCREEN_SIZES.laptop.maxWidth) {
      return 'laptop';
    } else if (width >= this.SCREEN_SIZES.desktop.minWidth && width <= this.SCREEN_SIZES.desktop.maxWidth) {
      return 'desktop';
    } else if (width >= this.SCREEN_SIZES.large.minWidth && width <= this.SCREEN_SIZES.large.maxWidth) {
      return 'large';
    } else {
      return 'ultrawide';
    }
  }
  private applyResponsiveParameters(screenType: ScreenSizeType): void {
    const params = this.RESPONSIVE_PARAMS[screenType];
    
    // Apply the responsive parameters to the data object
    if (params.amount !== undefined) this.data.amount = params.amount;
    if (params.particleSize !== undefined) this.data.particleSize = params.particleSize;
    if (params.textSize !== undefined) this.data.textSize = params.textSize;
    if (params.minSymbolSize !== undefined) this.data.minSymbolSize = params.minSymbolSize;
    if (params.maxSymbolSize !== undefined) this.data.maxSymbolSize = params.maxSymbolSize;
    if (params.area !== undefined) this.data.area = params.area;
  }

  public checkScreenSizeChange(): boolean {
    const currentWidth = this.hostContainer.clientWidth;
    const currentHeight = this.hostContainer.clientHeight;
    
    // Check if dimensions have changed significantly (more than 10% or 100px)
    const widthChange = Math.abs(currentWidth - this.lastKnownWidth);
    const heightChange = Math.abs(currentHeight - this.lastKnownHeight);
    const significantChange = widthChange > 100 || heightChange > 100 || 
                             widthChange / this.lastKnownWidth > 0.1 || 
                             heightChange / this.lastKnownHeight > 0.1;
    
    if (significantChange) {
      const newScreenType = this.getScreenSizeType();
      
      if (newScreenType !== this.currentScreenSizeType) {
        console.log(`🖥️ Screen size change detected: ${this.currentScreenSizeType} → ${newScreenType}`);
        this.currentScreenSizeType = newScreenType;
        this.applyResponsiveParameters(newScreenType);
        this.lastKnownWidth = currentWidth;
        this.lastKnownHeight = currentHeight;
        this.needsParticleRegeneration = true;
        return true;
      }
    }
    
    return false;
  }

  public regenerateParticles(): void {
    if (!this.needsParticleRegeneration) return;
    
    console.log(`🔄 Regenerating particles for ${this.currentScreenSizeType} screen size:`);
    console.log(`   New particle count: ${this.data.amount}`);
    console.log(`   New particle size: ${this.data.particleSize}`);
    
    // Remove existing particles
    if (this.particles) {
      this.scene.remove(this.particles);
      this.particles.geometry.dispose();
      const material = this.particles.material as THREE.Material;
      if (material) material.dispose();
    }
    
    // Recreate particles with new parameters
    this.createText();
    
    this.needsParticleRegeneration = false;
  }
  
  public dispose() {
    this.unbindInteractionEvents();
    if (this.particles) {
      this.scene.remove(this.particles);
      this.particles.geometry.dispose();
      const material = this.particles.material as THREE.Material | THREE.Material[];
      if (Array.isArray(material)) {
        material.forEach(m => m.dispose());
      } else {
        material.dispose();
      }
    }
    if (this.geometryCopy) this.geometryCopy.dispose();
    if (this.symbolsTexture) this.symbolsTexture.dispose();
    if (this.planeArea) {
      this.scene.remove(this.planeArea);
      this.planeArea.geometry.dispose();
      const material = this.planeArea.material as THREE.Material | THREE.Material[];
      if (Array.isArray(material)) {
         material.forEach(m => m.dispose());
      } else {
        (material as THREE.Material).dispose();
      }
    }
  }
}
--- END OF FILE src\lib\three\heroParticleLogic.ts ---

--- START OF FILE src\routes\+layout.svelte ---
<!-- src/routes/+layout.svelte -->
<script lang="ts">
  import '../app.css'; // Import global styles for keyboard buttons etc.
</script>

<slot />
--- END OF FILE src\routes\+layout.svelte ---

--- START OF FILE src\routes\+page.svelte ---
<!-- src/routes/+page.svelte -->
<script lang="ts">
  import { onMount, onDestroy, tick } from 'svelte';
  import { writable, get } from 'svelte/store';
  import { siteConfig } from '$lib/data/siteConfig';
  import { projects, type Project } from '$lib/data/projectsData';
  import { initialSiteLoadComplete, preloadingStore, startLoadingTask, preloadAssets, sectionStateStore, type SectionState } from '$lib/stores/preloadingStore';
  import { gsap } from 'gsap';

  // Component Imports
  import LoadingScreen from '$lib/components/LoadingScreen.svelte';
  import HeroSection from '$lib/components/sections/HeroSection.svelte';
  import AboutSection from '$lib/components/sections/AboutSection.svelte';
  import ProjectOneSection from '$lib/components/sections/ProjectOneSection.svelte';
  import ProjectTwoSection from '$lib/components/sections/ProjectTwoSection.svelte';
  import ContactSection from '$lib/components/sections/ContactSection.svelte';

  // Type Imports
  interface IAnimatedComponent {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    initializeEffect?: () => Promise<void>;
    onTransitionComplete?: () => void;
    onCooldown?: () => void; // New optional method for resource cleanup
  }
  import type { HeroSectionInstance } from '$lib/components/sections/HeroSection.svelte';

  // Section Data
  const allSectionsData = [
    { id: 'hero', component: HeroSection, data: siteConfig.heroSection },
    { id: 'about', component: AboutSection, data: siteConfig.aboutSection },
    { id: `project-${projects[0].id}`, component: ProjectOneSection, data: projects[0] },
    { id: `project-${projects[1].id}`, component: ProjectTwoSection, data: projects[1] },
    { id: 'contact', component: ContactSection, data: siteConfig.contactSection }
  ];
  const contactSectionIndex = allSectionsData.findIndex(s => s.id === 'contact');

  // Instance Management
  let heroSectionInstance: HeroSectionInstance | null = null;
  let sectionInstancesArray: (IAnimatedComponent | null)[] = new Array(allSectionsData.length).fill(null);
  let sectionInstances = new Map<string, IAnimatedComponent>();
  $: if (sectionInstancesArray.length > 0) {
    const newMap = new Map<string, IAnimatedComponent>();
    allSectionsData.forEach((section, index) => {
      const instance = index === 0 ? heroSectionInstance : sectionInstancesArray[index];
      if (instance) newMap.set(section.id, instance);
    });
    sectionInstances = newMap;
  }
  
  // Core State
  const isAnimating = writable(false);
  const currentSectionIndex = writable(0);
  const isTransitioning = writable(false);
  const isInitialReveal = writable(true);

  // Page & Animation State
  let visibilityHideTimeoutId: number | undefined;
  let isTabHiddenAndPaused = false;
  const HIDE_BUFFER_DURATION = 15000;
  let sectionElements: HTMLElement[] = [];
  let sectionBackgroundZooms: (gsap.core.Tween | null)[] = [];
  const transitionDuration = 1.1;
  const projectBgZoomDuration = 3;
  const minSectionDisplayDuration = 1.2;
  const initialRevealDelay = 300;
  const particleFadeInDuration = 1.5;
  let unsubInitialLoadComplete: (() => void) | undefined;
  let hasStartedInitialReveal = false;
  
  let particleLayerPointerEvents = 'none';
  $: particleLayerPointerEvents = ($currentSectionIndex === 0 && !$isInitialReveal) ? 'auto' : 'none';
  let mainContainerPointerEvents = 'auto';
  $: mainContainerPointerEvents = ($currentSectionIndex === 0 || $isInitialReveal) ? 'none' : 'auto';

  // Promise setup for initial load
  let heroReadyResolver: () => void;
  const heroReadyPromise = new Promise<void>(resolve => {
    heroReadyResolver = resolve;
  });

  // --- The New Neighbor Preload Manager ---
  const preloadManager = {
    _isPreparing: new Set<number>(), // Prevents redundant parallel preparations
    _isPrewarmingGpu: false,

    getSectionAssetUrls(index: number): string[] {
      if (index < 0 || index >= allSectionsData.length) return [];
      const section = allSectionsData[index];
      let urls: string[] = [];
      if (section.id === 'about') {
        urls.push((section.data as typeof siteConfig.aboutSection).imageUrl);
      } else if (section.id.startsWith('project-')) {
        const p = section.data as Project;
        urls.push(p.background.value);
        p.cards.forEach(card => urls.push(card.image));
      }
      return urls.filter(Boolean);
    },
    
    _preWarmGpuLayers(sectionElement: HTMLElement | undefined) {
      if (this._isPrewarmingGpu || !sectionElement) return;
      this._isPrewarmingGpu = true;
      
      setTimeout(() => {
        const targets = sectionElement.querySelectorAll('.gpu-prewarm-target');
        if (targets.length === 0) {
          this._isPrewarmingGpu = false;
          return;
        }
        
        gsap.set(targets, {
          autoAlpha: 0.001,
          stagger: 0.05,
          onComplete: () => {
            gsap.set(targets, { autoAlpha: 0 });
            this._isPrewarmingGpu = false;
          }
        });
      }, 100);
    },

    async _prepare(index: number) {
      if (index < 0 || index >= allSectionsData.length || this._isPreparing.has(index)) return;
      
      const currentState = sectionStateStore.getState(index);
      if (currentState === 'READY' || currentState === 'ACTIVE' || currentState === 'PRELOADING') return;

      this._isPreparing.add(index);
      sectionStateStore.setState(index, 'PRELOADING');
      console.log(`[Preloader] START preparation for Section ${index}`);

      try {
        const instance = sectionInstances.get(allSectionsData[index].id);
        const urls = this.getSectionAssetUrls(index);
        
        if (urls.length > 0) await preloadAssets(urls);
        if (instance?.initializeEffect) await instance.initializeEffect();
        
        const targetSectionElement = sectionElements[index];
        this._preWarmGpuLayers(targetSectionElement);

        sectionStateStore.setState(index, 'READY');
        console.log(`[Preloader] FINISH preparation for Section ${index}. State: READY.`);
      } catch (error) {
        console.error(`[Preloader] FAILED preparation for Section ${index}:`, error);
        sectionStateStore.setState(index, 'IDLE');
      } finally {
        this._isPreparing.delete(index);
      }
    },

    _cooldown(index: number) {
      if (index < 0 || index >= allSectionsData.length) return;
      const currentState = sectionStateStore.getState(index);
      if (currentState === 'IDLE' || currentState === 'COOLING' || currentState === 'ACTIVE') return;

      sectionStateStore.setState(index, 'COOLING');
      console.log(`[Preloader] COOLING DOWN Section ${index}`);

      const instance = sectionInstances.get(allSectionsData[index].id);
      instance?.onCooldown?.();
      
      sectionStateStore.setState(index, 'IDLE');
    },

    updateNeighborStates(activeIndex: number) {
      console.log(`[Preloader] Updating neighbor states around active index: ${activeIndex}`);
      const neighborhood = [activeIndex - 1, activeIndex, activeIndex + 1];

      for (let i = 0; i < allSectionsData.length; i++) {
        const isNeighbor = neighborhood.includes(i);
        const currentState = sectionStateStore.getState(i);

        if (i === activeIndex) {
          if (currentState !== 'ACTIVE') sectionStateStore.setState(i, 'ACTIVE');
          continue;
        }

        if (isNeighbor) {
          if (currentState === 'IDLE') this._prepare(i);
        } else { // Is NOT a neighbor
          if (currentState === 'READY') this._cooldown(i);
        }
      }
    }
  };

  function handleVisibilityChange() {
    const currentIndex = get(currentSectionIndex);
    const currentInstance = sectionInstances.get(allSectionsData[currentIndex].id);
    if (document.hidden) {
      visibilityHideTimeoutId = window.setTimeout(() => {
        if (document.hidden && !isTabHiddenAndPaused) {
          currentInstance?.onLeaveSection();
          isTabHiddenAndPaused = true;
        }
      }, HIDE_BUFFER_DURATION);
    } else {
      clearTimeout(visibilityHideTimeoutId);
      if (isTabHiddenAndPaused) {
        console.log("[Visibility] Tab refocused. Re-validating preloader state.");
        preloadManager.updateNeighborStates(currentIndex);
        currentInstance?.onEnterSection();
        requestAnimationFrame(() => {
          currentInstance?.onTransitionComplete?.();
        });
        isTabHiddenAndPaused = false;
      }
    }
  }

  onMount(() => {
    const mountLogic = async () => {
      await tick();

      sectionElements = allSectionsData.map(section => document.getElementById(section.id) as HTMLElement);
      if (sectionElements.some(el => !el)) {
        console.error("Could not find all section elements in the DOM.");
        return;
      }
      
      sectionStateStore.init(allSectionsData.length);

      sectionElements.forEach((sectionEl, index) => {
        const bgTarget = sectionEl.querySelector('.background-image-container') as HTMLElement;
        sectionBackgroundZooms[index] = bgTarget ? gsap.to(bgTarget, { scale: 1.05, duration: projectBgZoomDuration, ease: 'power1.out', paused: true }) : null;
        gsap.set(sectionEl, { yPercent: index === 0 ? 0 : 100, autoAlpha: index === 0 ? 1 : 0 });
      });

      const setupInitialLoad = async () => {
        const heroInitializationPromise = heroReadyPromise;
        const aboutInitializationPromise = preloadManager._prepare(1);

        await Promise.all([heroInitializationPromise, aboutInitializationPromise]);
        initialSiteLoadComplete.set(true);
      };

      setupInitialLoad();

      window.addEventListener('wheel', handleWheel, { passive: false });
      window.addEventListener('keydown', handleKeyDown);
      document.addEventListener('visibilitychange', handleVisibilityChange);
    };

    mountLogic();
    
    unsubInitialLoadComplete = initialSiteLoadComplete.subscribe(complete => {
        if (complete && !hasStartedInitialReveal) {
            startInitialReveal();
        }
    });

    return () => {
      window.removeEventListener('wheel', handleWheel);
      window.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      if (unsubInitialLoadComplete) unsubInitialLoadComplete();
      sectionBackgroundZooms.forEach(tween => tween?.kill());
      clearTimeout(visibilityHideTimeoutId);
    };
  });

  function onParticleEffectReady() {
    if (heroReadyResolver) heroReadyResolver();
  }

  function startInitialReveal() {
    if (hasStartedInitialReveal) return;
    hasStartedInitialReveal = true;

    setTimeout(() => {
      if (heroSectionInstance) {
        heroSectionInstance.onTransitionToHeroComplete();
        preloadManager.updateNeighborStates(0);
      }
      setTimeout(() => { isInitialReveal.set(false); }, particleFadeInDuration * 1000);
    }, initialRevealDelay);
  }
  
  function navigateToSection(newIndex: number) { 
    if (get(isInitialReveal)) return; 
    const oldIndex = get(currentSectionIndex); 
    if (get(isAnimating) || newIndex === oldIndex || newIndex < 0 || newIndex >= sectionElements.length) return; 
    
    isAnimating.set(true); 
    isTransitioning.set(true); 

    const oldInstance = sectionInstances.get(allSectionsData[oldIndex].id);
    const newInstance = sectionInstances.get(allSectionsData[newIndex].id);
    
    oldInstance?.onLeaveSection();
    sectionBackgroundZooms[oldIndex]?.progress(0).pause(); 
    newInstance?.onEnterSection();

    const currentSectionEl = sectionElements[oldIndex]; 
    const targetSectionEl = sectionElements[newIndex]; 
    const direction = newIndex > oldIndex ? 1 : -1; 
    
    const masterTransitionTl = gsap.timeline({ 
      onComplete: () => { 
        currentSectionIndex.set(newIndex); 
        isTransitioning.set(false);
        sectionBackgroundZooms[newIndex]?.restart();
        
        requestAnimationFrame(() => {
          newInstance?.onTransitionComplete?.();
        });

        if (allSectionsData[newIndex].id === 'hero' && heroSectionInstance) {
           heroSectionInstance.onTransitionToHeroComplete();
        }

        preloadManager.updateNeighborStates(newIndex);
      } 
    }); 
    
    gsap.set(targetSectionEl, { yPercent: direction * 100, autoAlpha: 1 }); 
    masterTransitionTl.to(currentSectionEl, { yPercent: -direction * 100, autoAlpha: 0, duration: transitionDuration, ease: 'expo.out' }, "slide"); 
    masterTransitionTl.to(targetSectionEl, { yPercent: 0, duration: transitionDuration, ease: 'expo.out' }, "slide"); 
    
    gsap.delayedCall(Math.max(transitionDuration, minSectionDisplayDuration), () => { 
      isAnimating.set(false); 
    }); 
  }

  let lastScrollTime = 0;
  const scrollDebounce = 200;
  function handleWheel(event: WheelEvent) { event.preventDefault(); if (get(isInitialReveal)) return; const currentTime = Date.now(); if (currentTime - lastScrollTime < scrollDebounce || get(isAnimating)) return; lastScrollTime = currentTime; navigateToSection(get(currentSectionIndex) + (event.deltaY > 0 ? 1 : -1)); }
  function handleKeyDown(event: KeyboardEvent) { if (get(isInitialReveal) || get(isAnimating)) { if (['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', ' ', 'Home', 'End'].includes(event.key)) event.preventDefault(); return; } const currentTime = Date.now(); if (currentTime - lastScrollTime < scrollDebounce) { if (['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', ' ', 'Home', 'End'].includes(event.key)) event.preventDefault(); return; } let newIndex = get(currentSectionIndex); let shouldScroll = false; switch (event.key) { case 'ArrowDown': case 'PageDown': case ' ': newIndex++; shouldScroll = true; break; case 'ArrowUp': case 'PageUp': newIndex--; shouldScroll = true; break; case 'Home': newIndex = 0; shouldScroll = true; break; case 'End': newIndex = sectionElements.length - 1; shouldScroll = true; break; } if (shouldScroll && newIndex !== get(currentSectionIndex)) { event.preventDefault(); lastScrollTime = currentTime; navigateToSection(newIndex); } }
</script>

<svelte:head>
  <title>{siteConfig.title}</title>
  <meta name="description" content={siteConfig.description} />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous">
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
</svelte:head>

<div>
  <LoadingScreen /> 

  <div class="particle-effect-layer" class:initial-state={$isInitialReveal} style="pointer-events: {particleLayerPointerEvents};">
    <HeroSection
      bind:this={heroSectionInstance}
      activeSectionIndex={$currentSectionIndex}
      isTransitioning={$isTransitioning}
      {transitionDuration}
      isInitialLoad={$isInitialReveal}
      on:ready={onParticleEffectReady}
    />
  </div>

  <main class="portfolio-container" style="pointer-events: {mainContainerPointerEvents};">
    <section id="hero" class="full-screen-section hero-section-container"></section>

    {#each allSectionsData.slice(1) as section, i (section.id)}
      <section 
        id={section.id} 
        class="full-screen-section"
      >
        {#if section.id === 'about'}
          <AboutSection
            bind:this={sectionInstancesArray[i + 1]}
            data={section.data as typeof siteConfig.aboutSection}
            {contactSectionIndex}
            {navigateToSection}
          />
        {:else if section.id === `project-${projects[0].id}`}
          <ProjectOneSection
            bind:this={sectionInstancesArray[i + 1]}
            project={section.data as Project}
          />
        {:else if section.id === `project-${projects[1].id}`}
          <ProjectTwoSection
            bind:this={sectionInstancesArray[i + 1]}
            project={section.data as Project}
          />
        {:else if section.id === 'contact'}
          <ContactSection
            bind:this={sectionInstancesArray[i + 1]}
            data={section.data as typeof siteConfig.contactSection}
          />
        {/if}
      </section>
    {/each}
  </main>

  <style>
    :global(body) { background-color: rgb(9 9 11); color: rgb(245 245 247); }
    .particle-effect-layer { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; background-color: rgb(9 9 11); transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1); }
    .particle-effect-layer.initial-state { background-color: rgb(5 8 5); }
    .portfolio-container { position: relative; width: 100%; height: 100vh; overflow: hidden; z-index: 1; }
    
    .full-screen-section {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      background-color: transparent; 
    }

    .hero-section-container {
      pointer-events: none;
    }
    
    * { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
  </style>
</div>
--- END OF FILE src\routes\+page.svelte ---

--- START OF FILE src\routes\projects\[slug]\+layout.svelte ---
<!-- src/routes/projects/[slug]/+layout.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { goto } from '$app/navigation';
  import { ArrowLeft } from 'lucide-svelte'; // A nice icon library for the back button

  let showButton = false;

  onMount(() => {
    // A slight delay ensures the button fades in after the page transition starts
    const timer = setTimeout(() => {
      showButton = true;
    }, 300);

    return () => clearTimeout(timer);
  });
</script>

<div class="project-subpage-layout">
  <button 
    class="back-button"
    class:visible={showButton}
    on:click={() => goto('/')}
    aria-label="Back to home"
  >
    <ArrowLeft size={24} />
  </button>

  <!-- The content of +page.svelte will be rendered here -->
  <slot />
</div>

<style>
  .project-subpage-layout {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .back-button {
    position: fixed;
    top: 2rem;
    left: 2rem;
    z-index: 1000; /* Ensure it's on top of all page content */
    
    background-color: rgba(30, 30, 32, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: white;
    backdrop-filter: blur(8px);
    
    width: 3rem;
    height: 3rem;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    
    cursor: pointer;
    transition: all 0.3s ease-in-out;
    
    opacity: 0;
    transform: scale(0.8);
    pointer-events: none;
  }

  .back-button.visible {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
  }

  .back-button:hover {
    background-color: rgba(50, 50, 52, 0.9);
    transform: scale(1.05);
  }

  /* Add lucide-svelte to your dev dependencies if you don't have it: npm install -D lucide-svelte */
</style>
--- END OF FILE src\routes\projects\[slug]\+layout.svelte ---

--- START OF FILE src\routes\projects\[slug]\+page.svelte ---
<!-- src/routes/projects/[slug]/+page.svelte -->
<script lang="ts">
  import { onMount, tick } from 'svelte';
  import { get, writable } from 'svelte/store';
  import { page } from '$app/stores';
  import { gsap } from 'gsap';
  import { siteConfig } from '$lib/data/siteConfig';
  // FIX: Import the new generic preloadAssets and task management functions
  import { preloadingStore, startLoadingTask, preloadAssets } from '$lib/stores/preloadingStore';

  export let data;
  const { project } = data;

  // A unique task ID for this project's assets
  const PROJECT_ASSETS_TASK_ID = `project-assets-${project.slug}`;

  // A writable store to track when content for this specific page is ready.
  const isContentLoaded = writable(false);

  const allSubSections = [
    { 
      id: 'overview', 
      title: project.headline,
      content: project.summary,
      background: project.background
    },
    ...project.subPageSections
  ];

  let sectionElements: HTMLElement[] = [];
  let sectionContentTimelines: (gsap.core.Timeline | null)[] = [];
  let sectionBackgroundZooms: (gsap.core.Tween | null)[] = [];

  let currentSectionIndex = 0;
  let isAnimating = false;
  let lastScrollTime = 0;
  const scrollDebounce = 200;
  const transitionDuration = 1.1;

  onMount(() => {
    // FIX: Use the new centralized preloading system.
    const runPreload = async () => {
      // Register the task with the global preloading store.
      startLoadingTask(PROJECT_ASSETS_TASK_ID, 2);

      const assetUrls = allSubSections
        .filter(s => s.background.type === 'image')
        .map(s => s.background.value);
      
      try {
        await preloadAssets(assetUrls);
        preloadingStore.updateTaskStatus(PROJECT_ASSETS_TASK_ID, 'loaded');
        console.log(`All assets for project '${project.slug}' preloaded successfully.`);
      } catch (error) {
        console.error(error);
        preloadingStore.updateTaskStatus(PROJECT_ASSETS_TASK_ID, 'error', (error as Error).message);
      } finally {
        // Once preloading is complete (success or fail), mark content as ready to be shown.
        isContentLoaded.set(true);
      }
    };
    
    runPreload();

    return () => {
      window.removeEventListener('wheel', handleWheel);
      window.removeEventListener('keydown', handleKeyDown);
      sectionContentTimelines.forEach(timeline => { timeline?.kill(); });
      sectionBackgroundZooms.forEach(tween => { tween?.kill(); });
    };
  });

  // This reactive block ensures animation setup only runs *after* assets are loaded.
  $: if ($isContentLoaded) {
    setupAnimations();
  }

  async function setupAnimations() {
      await tick();

      sectionElements = allSubSections.map(section => document.getElementById(section.id) as HTMLElement);
      
      const urlHash = get(page).url.hash;
      const cleanHash = urlHash.startsWith('#') ? urlHash.substring(1) : null;
      
      let initialIndex = 0;
      if (cleanHash) {
        const foundIndex = allSubSections.findIndex(s => s.id === cleanHash);
        if (foundIndex !== -1) {
          initialIndex = foundIndex;
        }
      }
      currentSectionIndex = initialIndex;

      sectionElements.forEach((sectionEl, index) => {
        const contentTl = gsap.timeline({ paused: true });
        const contentOverlay = sectionEl.querySelector('.subpage-content-overlay');
        const h2El = sectionEl.querySelector('h2');
        const pEl = sectionEl.querySelector('p');

        if (contentOverlay) {
          contentTl.fromTo(contentOverlay, { autoAlpha: 0, scale: 0.95 }, { autoAlpha: 1, scale: 1, duration: 0.7, ease: 'power2.out' }, "start");
        }
        if (h2El) {
          contentTl.fromTo(h2El, { autoAlpha: 0, y: 30 }, { autoAlpha: 1, y: 0, duration: 0.8, ease: 'power2.out' }, "start+=0.2");
        }
        if (pEl) {
          contentTl.fromTo(pEl, { autoAlpha: 0, y: 20 }, { autoAlpha: 1, y: 0, duration: 0.7, ease: 'power2.out' }, "start+=0.35");
        }
        sectionContentTimelines[index] = contentTl;
        
        const bgTarget = sectionEl.querySelector('.subpage-background-image') as HTMLElement;
        if (bgTarget) {
          sectionBackgroundZooms[index] = gsap.to(bgTarget, { scale: 1.05, duration: 3, ease: 'power1.out', paused: true });
        }
      });

      sectionElements.forEach((el, index) => {
        if (index === initialIndex) {
          gsap.set(el, { yPercent: 0, autoAlpha: 1 });
          sectionContentTimelines[index]?.restart();
          sectionBackgroundZooms[index]?.restart();
        } else {
          gsap.set(el, { yPercent: 100, autoAlpha: 0 });
        }
      });

      window.addEventListener('wheel', handleWheel, { passive: false });
      window.addEventListener('keydown', handleKeyDown);
  }

  function navigateToSection(newIndex: number) {
    const oldIndex = currentSectionIndex;
    if (isAnimating || newIndex === oldIndex || newIndex < 0 || newIndex >= sectionElements.length) return;
    
    isAnimating = true;

    const currentSectionEl = sectionElements[oldIndex];
    const targetSectionEl = sectionElements[newIndex];
    const direction = newIndex > oldIndex ? 1 : -1;

    sectionContentTimelines[oldIndex]?.progress(0).pause();
    sectionBackgroundZooms[oldIndex]?.progress(0).pause();

    gsap.set(targetSectionEl, { yPercent: direction * 100, autoAlpha: 1 });

    const masterTl = gsap.timeline({
      onComplete: () => {
        isAnimating = false;
        currentSectionIndex = newIndex;
      }
    });

    masterTl.to(currentSectionEl, { yPercent: -direction * 100, autoAlpha: 0, duration: transitionDuration, ease: 'expo.out' }, "slide");
    masterTl.to(targetSectionEl, { yPercent: 0, duration: transitionDuration, ease: 'expo.out' }, "slide");
    
    masterTl.call(() => { sectionContentTimelines[newIndex]?.restart(); }, [], `slide+=${transitionDuration * 0.3}`);
    masterTl.call(() => { sectionBackgroundZooms[newIndex]?.restart(); }, [], `slide+=${transitionDuration * 0.1}`);
  }

  function handleWheel(event: WheelEvent) {
    event.preventDefault();
    const currentTime = Date.now();
    if (currentTime - lastScrollTime < scrollDebounce || isAnimating) return;
    lastScrollTime = currentTime;
    navigateToSection(currentSectionIndex + (event.deltaY > 0 ? 1 : -1));
  }

  function handleKeyDown(event: KeyboardEvent) {
    if (isAnimating) return;
    let newIndex = currentSectionIndex;
    if (event.key === 'ArrowDown' || event.key === ' ') newIndex++;
    if (event.key === 'ArrowUp') newIndex--;
    navigateToSection(newIndex);
  }

</script>

<svelte:head>
  <title>{project.headline} | {siteConfig.author}</title>
  <meta name="description" content={project.summary} />
</svelte:head>

<div class="subpage-container" class:loaded={$isContentLoaded}>
  {#each allSubSections as section, i (section.id)}
    <section id={section.id} class="subpage-fullscreen-section">
      <div 
        class="subpage-background-image"
        style="background-image: url({section.background.value});"
      ></div>
      
      <div class="subpage-content-overlay">
        <h2>{section.title}</h2>
        <p>{section.content}</p>
      </div>
    </section>
  {/each}
</div>

<style>
  .subpage-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #000;
    overflow: hidden;
    opacity: 0;
    transition: opacity 0.6s ease-in-out;
  }
  
  .subpage-container.loaded {
    opacity: 1;
  }

  .subpage-fullscreen-section {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    padding: 2rem;
    box-sizing: border-box;
  }

  .subpage-background-image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 0;
    transform: scale(1);
  }

  .subpage-content-overlay {
    position: relative;
    z-index: 1;
    max-width: 800px;
    text-align: center;
    padding: 2rem;
    background-color: rgba(9, 9, 11, 0.75);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    opacity: 0;
  }

  .subpage-content-overlay h2 {
    font-size: clamp(2.2rem, 5vw, 3.5rem);
    font-weight: 700;
    font-family: 'Playfair Display', serif;
    margin-bottom: 1.5rem;
    text-shadow: 0 2px 20px rgba(0,0,0,0.5);
    opacity: 0;
  }

  .subpage-content-overlay p {
    font-size: clamp(1rem, 2.5vw, 1.15rem);
    line-height: 1.8;
    max-width: 700px;
    margin: 0 auto;
    color: #e2e8f0;
    opacity: 0;
  }
</style>
--- END OF FILE src\routes\projects\[slug]\+page.svelte ---

--- START OF FILE src\routes\projects\[slug]\+page.ts ---
// src/routes/projects/[slug]/+page.ts

import { error } from '@sveltejs/kit';
import { projects } from '$lib/data/projectsData';
import type { PageLoad } from './$types';

// FIX: Removed `url` from the function parameters. We only need `params`.
export const load: PageLoad = ({ params }) => {
  const project = projects.find(p => p.slug === params.slug);

  if (!project) {
    throw error(404, 'Project not found');
  }

  // FIX: Only return the project data. The hash will be read on the client.
  return {
    project
  };
};
--- END OF FILE src\routes\projects\[slug]\+page.ts ---

