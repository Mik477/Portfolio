--- START OF FILE src\app.css ---
/* src/app.css */
:root {
    --keyboard-background-2: #09090b;
    --keyboard-background-3: #232b34;
    --keyboard-contrast: #fff;
    --keyboard-key-base-size: 4rem;
}

@keyframes fade-in-bottom {
    0% {
        transform: translateY(50px) rotateY(0.05turn) rotateX(-0.1turn);
        opacity: 0;
        filter: blur(16px);
    }
    to {
        transform: translateY(0) rotateY(0.05turn) rotateX(-0.1turn);
        opacity: 1;
        filter: blur(0);
    }
}

@media (max-width: 768px) {
    :root { --keyboard-key-base-size: 3.5rem; }
}
@media (max-width: 640px) {
    :root { --keyboard-key-base-size: 3rem; }
}
--- END OF FILE src\app.css ---

--- START OF FILE src\app.d.ts ---
// src/app.d.ts
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};

--- END OF FILE src\app.d.ts ---

--- START OF FILE src\app.html ---
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
		<style>
			/* Global Resets and Viewport Styling */
			html, body {
				margin: 0;
				padding: 0;
				height: 100%;
				width: 100%;
				overflow: hidden; /* Prevent scrollbars on html/body, main container should handle its own scroll/overflow */
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
			}

			/* Ensure SvelteKit's main div also takes full height if needed, though 'display: contents' usually negates its layout impact */
			body > div[style="display: contents"] {
				height: 100%; 
			}
		</style>
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
--- END OF FILE src\app.html ---

--- START OF FILE src\lib\index.ts ---
// place files you want to import through the `$lib` alias in this folder.

--- END OF FILE src\lib\index.ts ---

--- START OF FILE src\lib\components\AboutImageEffect.svelte ---
<!-- src/lib/components/AboutImageEffect.svelte -->
<script context="module" lang="ts">
  // FIX: Add the new optional methods to the exported type.
  // This allows other components to know about and call them safely.
  export type AboutImageEffectInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    initializeEffect?: () => Promise<void>;
    onTransitionComplete?: () => void;
  };
</script>

<script lang="ts">
  import { onMount, onDestroy, tick } from 'svelte';
  import * as THREE from 'three';
  import { gsap } from 'gsap';
  import { BloomEffect } from '$lib/three/BloomEffect';

  export let imageUrl: string;
  export let fadeInDelay: number = 250;

  let mainContainer: HTMLDivElement;
  let imageElement: HTMLImageElement;
  let particleOverlayElement: HTMLDivElement;

  let effectInstance: DigitalDecayEffect | null = null;
  let isInitialized = false;
  let fadeInTimeoutId: number | undefined;

  // --- Component API ---

  export async function initializeEffect() {
    if (isInitialized) return;
    await tick();
    if (!particleOverlayElement || !imageElement) return;
    effectInstance = new DigitalDecayEffect(particleOverlayElement, imageElement);
    effectInstance.init();
    isInitialized = true;
  }

  export async function onEnterSection() {
    if (!isInitialized) {
      await initializeEffect();
    }
    if (fadeInTimeoutId) clearTimeout(fadeInTimeoutId);

    fadeInTimeoutId = window.setTimeout(() => {
      gsap.to(mainContainer, { autoAlpha: 1, duration: 1.2, ease: 'power2.inOut' });
    }, fadeInDelay);
  }
  
  export function onTransitionComplete() {
    if (effectInstance) {
      effectInstance.onWindowResize();
      effectInstance.start();
    }
  }

  export function onLeaveSection() {
    if (fadeInTimeoutId) clearTimeout(fadeInTimeoutId);
    
    if (effectInstance) {
      effectInstance.beginLeaveAnimation();
      gsap.killTweensOf(mainContainer);
      gsap.set(mainContainer, { autoAlpha: 0 });
    }
  }
  
  // --- Lifecycle ---

  onMount(() => {
    // Initialization is fully deferred.
  });

  onDestroy(() => {
    if (fadeInTimeoutId) clearTimeout(fadeInTimeoutId);
    if (effectInstance) {
      effectInstance.dispose();
      effectInstance = null;
    }
  });

  // --- DigitalDecayEffect Class ---

  interface GridCell { state: number; timer: number; opacity: number; }
  interface Particle { index: number; active: boolean; originalPos: THREE.Vector2; amplitude: number; timeOffset: number; speed: number; lifetime: number; age: number; size: number; color: THREE.Color; symbolIndex: number; gridCellIndex: number; lastSymbolChange: number; symbolChangeInterval: number; }

  class DigitalDecayEffect {
    private overlayContainer: HTMLElement;
    private image: HTMLImageElement;
    private clock: THREE.Clock | null = null;
    private animationFrameId: number | null = null;
    
    private width = 0;
    private height = 0;
    private scene!: THREE.Scene;
    private camera!: THREE.OrthographicCamera;
    private renderer!: THREE.WebGLRenderer;
    private bloomEffect!: BloomEffect;

    private readonly CELL_SIZE = 9;
    private readonly BASE_CHANCE = 0.003;
    private readonly PROBABILITY_DECAY_FACTOR = 9;
    private readonly SPAWN_AREA_WIDTH = 0.5;
    private readonly REGENERATION_TIME = 1.5;
    private readonly ONSET_DURATION = 2.0;
    private readonly MAX_ACTIVE_PARTICLES = 2000;
    private readonly PARTICLE_LIFETIME = { min: 4, max: 8 };
    private readonly PARTICLE_SPEED = 0.25;
    private readonly PARTICLE_SPEED_VARIATION = 0.5;
    private readonly AMPLITUDE = { min: 90, max: 210 };
    private readonly SYMBOL_CHANGE_INTERVAL = 1.5;
    private readonly SYMBOL_CHANGE_VARIATION = 0.8;
    private readonly PARTICLE_FADE_IN_DURATION = 0.4;
    private readonly PARTICLE_FADEOUT_DURATION = 0.1;
    private readonly PARTICLE_BASE_OPACITY = 0.9;
    private readonly BLACKOUT_FADE_DURATION = 0.35;
    private readonly SYMBOLS = [ '日', '〇', 'ハ', 'ミ', 'ヒ', 'ウ', 'シ', 'ナ', 'モ', 'サ', 'ワ', 'ツ', 'オ', 'リ', 'ア', 'ホ', 'テ', 'マ', 'ケ', 'メ', 'エ', 'カ', 'キ', 'ム', 'ユ', 'ラ', 'セ', 'ネ', 'ヲ', 'イ', 'ク', 'コ', 'ソ', 'タ', 'チ', 'ト', 'ノ', 'フ', 'ヘ', 'ヤ', 'ヨ', 'ル', 'レ', 'ロ', '∆', 'δ', 'ε', 'ζ', 'η', 'θ', '∃', '∄', '∅', 'Д' ];
    private readonly SYMBOL_COLORS = [ new THREE.Color(0.0, 0.95, 0.05), new THREE.Color(0.0, 1.0, 0.0), new THREE.Color(0.3, 1.0, 0.3) ];
    private readonly BLACKOUT_COLOR = new THREE.Color('#09090b');
    
    private STATE = { IDLE: 0, ACTIVE: 1, REGENERATING: 2 };
    private isFadingOut = false;
    private fadeOutTimer = 0;
    private onsetTimer = 0;
    private readonly SHUTDOWN_CLEANUP_DELAY = 1.0;

    private grid: { cols: number; rows: number; cells: GridCell[] } = { cols: 0, rows: 0, cells: [] };
    private particles: { pool: Particle[]; active: Map<number, Particle> } = { pool: [], active: new Map() };
    private imageRect: DOMRect | null = null;
    private particleSystem!: THREE.Points<THREE.BufferGeometry, THREE.ShaderMaterial>;
    private blackoutMesh!: THREE.InstancedMesh;
    private symbolsTexture!: THREE.CanvasTexture;
    private boundOnWindowResize = this.onWindowResize.bind(this);

    constructor(overlayContainer: HTMLElement, image: HTMLImageElement) {
        this.overlayContainer = overlayContainer;
        this.image = image;
    }

    public init(): void {
      if (this.image.complete && this.image.naturalHeight !== 0) {
          this.setupSceneOnce();
      } else {
          this.image.onload = () => this.setupSceneOnce();
      }
    }

    private setupSceneOnce(): void {
        this.setupScene();
        this.bloomEffect = new BloomEffect(this.renderer, this.scene, this.camera, this.width, this.height);
        this.createSymbolTexture();
        this.createBlackoutMesh();
        this.createParticleSystem();
        window.addEventListener('resize', this.boundOnWindowResize);
    }
    
    private animate(): void {
        this.animationFrameId = requestAnimationFrame(() => this.animate());
        if (!this.clock || !this.imageRect) return;
        const deltaTime = this.clock.getDelta();
        if (this.isFadingOut) {
            this.fadeOutTimer += deltaTime;
            this.updateParticles(deltaTime);
            const fadeProgress = Math.max(0, 1.0 - (this.fadeOutTimer / this.PARTICLE_FADEOUT_DURATION));
            this.particleSystem.material.uniforms.globalOpacity.value = fadeProgress;
            if (this.fadeOutTimer >= this.SHUTDOWN_CLEANUP_DELAY) {
                this.stop();
                this.fullReset();
            }
        } else {
            this.updateGrid(deltaTime);
            this.updateParticles(deltaTime);
            this.updateBlackout();
        }
        this.bloomEffect.render(deltaTime);
    }

    public onWindowResize(): void {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.camera.left = -this.width / 2; this.camera.right = this.width / 2;
        this.camera.top = this.height / 2; this.camera.bottom = -this.height / 2;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.width, this.height);
        if (this.bloomEffect) {
            this.bloomEffect.setSize(this.width, this.height);
        }
        this.setupGrid();
    }
    
    public dispose(): void {
      this.stop();
      window.removeEventListener('resize', this.boundOnWindowResize);
      if (this.bloomEffect) this.bloomEffect.dispose();
      // ...
    }

    public start(): void {
        if (this.animationFrameId === null) {
            this.fullReset();
            this.clock = new THREE.Clock();
            this.animate();
        }
    }
    
    public stop(): void { if (this.animationFrameId !== null) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; this.clock = null; } }
    public beginLeaveAnimation(): void { if (!this.isFadingOut) { this.isFadingOut = true; this.fadeOutTimer = 0; this.resetBlackoutGrid(); } }
    private createParticleSystem(): void { const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.Float32BufferAttribute(new Float32Array(this.MAX_ACTIVE_PARTICLES * 3), 3)); geometry.setAttribute('customColor', new THREE.Float32BufferAttribute(new Float32Array(this.MAX_ACTIVE_PARTICLES * 3), 3)); geometry.setAttribute('size', new THREE.Float32BufferAttribute(new Float32Array(this.MAX_ACTIVE_PARTICLES), 1)); geometry.setAttribute('symbolIndex', new THREE.Float32BufferAttribute(new Float32Array(this.MAX_ACTIVE_PARTICLES), 1)); geometry.setAttribute('particleOpacity', new THREE.Float32BufferAttribute(new Float32Array(this.MAX_ACTIVE_PARTICLES), 1)); const material = new THREE.ShaderMaterial({ uniforms: { symbolsTexture: { value: this.symbolsTexture }, globalOpacity: { value: 1.0 }, }, vertexShader: ` attribute float size; attribute vec3 customColor; attribute float symbolIndex; attribute float particleOpacity; varying vec3 vColor; varying float vSymbolIndex; varying float vOpacity; void main() { vColor = customColor; vSymbolIndex = symbolIndex; vOpacity = particleOpacity; vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); gl_PointSize = size; gl_Position = projectionMatrix * mvPosition; } `, fragmentShader: ` uniform sampler2D symbolsTexture; uniform float globalOpacity; varying vec3 vColor; varying float vSymbolIndex; varying float vOpacity; void main() { float symbolsPerRow = 8.0; float totalRows = ${Math.ceil(this.SYMBOLS.length / 8)}.0; vec2 symbolCoord = gl_PointCoord; symbolCoord.x = (symbolCoord.x + mod(vSymbolIndex, symbolsPerRow)) / symbolsPerRow; symbolCoord.y = (symbolCoord.y + floor(vSymbolIndex / symbolsPerRow)) / totalRows; vec4 tex = texture2D(symbolsTexture, symbolCoord); if (tex.a < 0.3) discard; gl_FragColor = vec4(vColor, tex.a * vOpacity * ${this.PARTICLE_BASE_OPACITY} * globalOpacity); } `, blending: THREE.AdditiveBlending, depthTest: false, transparent: true }); this.particleSystem = new THREE.Points(geometry, material); this.scene.add(this.particleSystem); const symbolIndices = (geometry.attributes.symbolIndex as THREE.BufferAttribute).array as Float32Array; for (let i = 0; i < this.MAX_ACTIVE_PARTICLES; i++) { symbolIndices[i] = Math.floor(Math.random() * this.SYMBOLS.length); } (geometry.attributes.symbolIndex as THREE.BufferAttribute).needsUpdate = true; for (let i = 0; i < this.MAX_ACTIVE_PARTICLES; i++) { this.particles.pool.push({ index: i, active: false, originalPos: new THREE.Vector2(), amplitude: 0, timeOffset: 0, speed: 0, lifetime: 0, age: 0, size: 0, color: new THREE.Color(), symbolIndex: 0, gridCellIndex: -1, lastSymbolChange: 0, symbolChangeInterval: 0 }); } }
    private fullReset(): void { this.isFadingOut = false; this.fadeOutTimer = 0; this.onsetTimer = 0; if(this.particleSystem) { this.particleSystem.material.uniforms.globalOpacity.value = 1.0; } this.resetBlackoutGrid(); this.resetAllParticles(); }
    private resetBlackoutGrid(): void { if (!this.blackoutMesh) return; for (const cell of this.grid.cells) { cell.state = this.STATE.IDLE; cell.timer = 0; cell.opacity = 0; } this.blackoutMesh.count = 0; this.blackoutMesh.instanceMatrix.needsUpdate = true; (this.blackoutMesh.geometry.attributes.instanceOpacity as THREE.InstancedBufferAttribute).needsUpdate = true; }
    private resetAllParticles(): void { if (!this.particleSystem) return; const positions = (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).array as Float32Array; this.particles.active.forEach(p => { p.active = false; positions[p.index * 3 + 1] = -99999; this.particles.pool.push(p); }); this.particles.active.clear(); (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true; }
    private setupScene(): void { this.width = window.innerWidth; this.height = window.innerHeight; this.scene = new THREE.Scene(); this.camera = new THREE.OrthographicCamera(-this.width / 2, this.width / 2, this.height / 2, -this.height / 2, 1, 1000); this.camera.position.z = 100; this.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true }); this.renderer.setPixelRatio(window.devicePixelRatio); this.renderer.setSize(this.width, this.height); this.overlayContainer.appendChild(this.renderer.domElement); }
    private getSymbolColor(): THREE.Color { return this.SYMBOL_COLORS[Math.floor(Math.random() * this.SYMBOL_COLORS.length)]; }
    private createSymbolTexture(): void { const symbolsPerRow = 8, symbolSize = 64; const rows = Math.ceil(this.SYMBOLS.length / symbolsPerRow); const canvas = document.createElement('canvas'); canvas.width = symbolsPerRow * symbolSize; canvas.height = rows * symbolSize; const ctx = canvas.getContext('2d')!; ctx.font = `bold ${symbolSize * 0.8}px monospace`; ctx.fillStyle = '#FFFFFF'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; for (let i = 0; i < this.SYMBOLS.length; i++) { const x = (i % symbolsPerRow) * symbolSize + symbolSize / 2; const y = Math.floor(i / symbolsPerRow) * symbolSize + symbolSize / 2; ctx.fillText(this.SYMBOLS[i], x, y); } this.symbolsTexture = new THREE.CanvasTexture(canvas); }
    private createBlackoutMesh(): void { const quadGeom = new THREE.PlaneGeometry(this.CELL_SIZE, this.CELL_SIZE); quadGeom.setAttribute('instanceOpacity', new THREE.InstancedBufferAttribute(new Float32Array(200 * 200), 1)); const material = new THREE.ShaderMaterial({ uniforms: { color: { value: this.BLACKOUT_COLOR } }, vertexShader: ` attribute float instanceOpacity; varying float vOpacity; void main() { vOpacity = instanceOpacity; gl_Position = projectionMatrix * instanceMatrix * modelViewMatrix * vec4(position, 1.0); } `, fragmentShader: ` uniform vec3 color; varying float vOpacity; void main() { gl_FragColor = vec4(color, vOpacity); } `, transparent: true, }); this.blackoutMesh = new THREE.InstancedMesh(quadGeom, material, 150 * 200); this.scene.add(this.blackoutMesh); }
    private setupGrid(): void { this.imageRect = this.image.getBoundingClientRect(); if (!this.imageRect || !this.imageRect.width) return; this.grid.cols = Math.floor(this.imageRect.width / this.CELL_SIZE); this.grid.rows = Math.floor(this.imageRect.height / this.CELL_SIZE); this.grid.cells = []; for (let i = 0; i < this.grid.cols * this.grid.rows; i++) { this.grid.cells.push({ state: this.STATE.IDLE, timer: 0, opacity: 0 }); } }
    private updateGrid(deltaTime: number): void { if (this.particles.active.size >= this.MAX_ACTIVE_PARTICLES) return; this.onsetTimer = Math.min(this.ONSET_DURATION, this.onsetTimer + deltaTime); const onsetMultiplier = this.ONSET_DURATION > 0 ? this.onsetTimer / this.ONSET_DURATION : 1; const spawnCols = Math.floor(this.grid.cols * this.SPAWN_AREA_WIDTH); for (let i = 0; i < this.grid.cells.length; i++) { const cell = this.grid.cells[i]; const fadeSpeed = deltaTime / this.BLACKOUT_FADE_DURATION; if (cell.state === this.STATE.ACTIVE) { cell.opacity = Math.min(1.0, cell.opacity + fadeSpeed); } else { cell.opacity = Math.max(0.0, cell.opacity - fadeSpeed); } if (cell.state === this.STATE.IDLE) { const col = i % this.grid.cols; if (col < spawnCols) { const normalizedX = col / spawnCols; const probability = this.BASE_CHANCE * onsetMultiplier * Math.exp(-this.PROBABILITY_DECAY_FACTOR * normalizedX) * deltaTime * 60; if (Math.random() < probability) { cell.state = this.STATE.ACTIVE; this.spawnParticleForCell(i); } } } else if (cell.state === this.STATE.REGENERATING) { cell.timer += deltaTime; if (cell.timer >= this.REGENERATION_TIME && cell.opacity <= 0) { cell.state = this.STATE.IDLE; cell.timer = 0; } } } }
    private spawnParticleForCell(cellIndex: number): void { if (this.particles.pool.length === 0 || !this.imageRect) return; const particle = this.particles.pool.pop()!; particle.active = true; particle.gridCellIndex = cellIndex; const col = cellIndex % this.grid.cols; const row = Math.floor(cellIndex / this.grid.cols); const xOnImage = col * this.CELL_SIZE + this.CELL_SIZE / 2; const yOnImage = row * this.CELL_SIZE + this.CELL_SIZE / 2; const x = this.imageRect.left + xOnImage - this.width / 2; const y = -(this.imageRect.top + yOnImage) + this.height / 2; particle.originalPos.set(x, y); const speedVariation = (Math.random() * 2 - 1) * this.PARTICLE_SPEED_VARIATION; particle.speed = this.PARTICLE_SPEED * (1 + speedVariation); particle.amplitude = this.AMPLITUDE.min + Math.random() * (this.AMPLITUDE.max - this.AMPLITUDE.min); particle.timeOffset = Math.random() * Math.PI * 2; particle.lifetime = this.PARTICLE_LIFETIME.min + Math.random() * (this.PARTICLE_LIFETIME.max - this.PARTICLE_LIFETIME.min); particle.age = 0; particle.size = this.CELL_SIZE * (1 + 1.1 * Math.random()); particle.symbolIndex = Math.floor(Math.random() * this.SYMBOLS.length); particle.color.copy(this.getSymbolColor()); particle.lastSymbolChange = 0; const variation = 1 + (Math.random() * 2 - 1) * this.SYMBOL_CHANGE_VARIATION; particle.symbolChangeInterval = this.SYMBOL_CHANGE_INTERVAL * variation; this.particles.active.set(particle.index, particle); }
    private updateParticles(deltaTime: number): void { const positions = (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).array as Float32Array; const opacities = (this.particleSystem.geometry.attributes.particleOpacity as THREE.BufferAttribute).array as Float32Array; const colors = (this.particleSystem.geometry.attributes.customColor as THREE.BufferAttribute).array as Float32Array; const sizes = (this.particleSystem.geometry.attributes.size as THREE.BufferAttribute).array as Float32Array; const symbolIndices = (this.particleSystem.geometry.attributes.symbolIndex as THREE.BufferAttribute).array as Float32Array; let needsUpdate = false; this.particles.active.forEach(p => { p.age += deltaTime; if (p.age >= p.lifetime && !this.isFadingOut) { this.grid.cells[p.gridCellIndex].state = this.STATE.REGENERATING; p.active = false; this.particles.active.delete(p.index); this.particles.pool.push(p); positions[p.index * 3 + 1] = -99999; opacities[p.index] = 0; needsUpdate = true; return; } if (p.age < this.PARTICLE_FADE_IN_DURATION) { opacities[p.index] = p.age / this.PARTICLE_FADE_IN_DURATION; } else if (p.age > p.lifetime - this.PARTICLE_FADEOUT_DURATION && !this.isFadingOut) { opacities[p.index] = (p.lifetime - p.age) / this.PARTICLE_FADEOUT_DURATION; } else { opacities[p.index] = 1.0; } p.lastSymbolChange += deltaTime; if(p.lastSymbolChange > p.symbolChangeInterval) { symbolIndices[p.index] = Math.floor(Math.random() * this.SYMBOLS.length); p.lastSymbolChange = 0; } const offsetX = -p.age * p.speed * p.amplitude; const offsetY = Math.sin(p.age * 1.5 + p.timeOffset) * 10; positions[p.index * 3] = p.originalPos.x + offsetX; positions[p.index * 3 + 1] = p.originalPos.y + offsetY; positions[p.index * 3 + 2] = 1; p.color.toArray(colors, p.index * 3); sizes[p.index] = p.size; needsUpdate = true; }); if (needsUpdate) { (this.particleSystem.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true; (this.particleSystem.geometry.attributes.customColor as THREE.BufferAttribute).needsUpdate = true; (this.particleSystem.geometry.attributes.size as THREE.BufferAttribute).needsUpdate = true; (this.particleSystem.geometry.attributes.symbolIndex as THREE.BufferAttribute).needsUpdate = true; (this.particleSystem.geometry.attributes.particleOpacity as THREE.BufferAttribute).needsUpdate = true; } }
    private updateBlackout(): void { if (!this.imageRect) return; const dummy = new THREE.Object3D(); const opacities = (this.blackoutMesh.geometry.attributes.instanceOpacity as THREE.InstancedBufferAttribute).array as Float32Array; let instanceIdx = 0; for (let i = 0; i < this.grid.cells.length; i++) { if (this.grid.cells[i].opacity > 0) { const col = i % this.grid.cols; const row = Math.floor(i / this.grid.cols); const xOnImage = col * this.CELL_SIZE + this.CELL_SIZE / 2; const yOnImage = row * this.CELL_SIZE + this.CELL_SIZE / 2; const x = this.imageRect.left + xOnImage - this.width / 2; const y = -(this.imageRect.top + yOnImage) + this.height / 2; dummy.position.set(x, y, 0); dummy.updateMatrix(); this.blackoutMesh.setMatrixAt(instanceIdx, dummy.matrix); opacities[instanceIdx] = this.grid.cells[i].opacity; instanceIdx++; } } this.blackoutMesh.count = instanceIdx; this.blackoutMesh.instanceMatrix.needsUpdate = true; (this.blackoutMesh.geometry.attributes.instanceOpacity as THREE.InstancedBufferAttribute).needsUpdate = true; }
  }
</script>

<div class="main-container gpu-prewarm-target" bind:this={mainContainer}>
  <div class="image-pane">
    <img src={imageUrl} alt="Profile" bind:this={imageElement}/>
  </div>
</div>

<div class="particle-overlay" bind:this={particleOverlayElement}></div>

<style>
  .main-container { position: relative; z-index: 1; width: 100%; height: 100%; display: flex; justify-content: flex-end; align-items: center; visibility: hidden; opacity: 0; }
  .image-pane { position: relative; height: 100%; flex-shrink: 0; display: flex; justify-content: flex-end; align-items: center; }
  .image-pane img { height: 100vh; width: auto; display: block; object-fit: cover; }
  .particle-overlay { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 2; pointer-events: none; }
</style>
--- END OF FILE src\lib\components\AboutImageEffect.svelte ---

--- START OF FILE src\lib\components\HeroParticleEffect.svelte ---
<!-- src/lib/components/HeroParticleEffect.svelte -->
<script lang="ts">
  import { onMount, onDestroy, tick } from 'svelte';
  import { createEventDispatcher } from 'svelte';
  import *  as THREE from 'three';
  import { FontLoader, type Font } from 'three/examples/jsm/loaders/FontLoader.js';
  import { Environment as ParticleEnvironment } from '$lib/three/heroParticleLogic';
  // FIX: Import the new generic preloadAssets function
  import { preloadingStore, startLoadingTask, preloadAssets } from '$lib/stores/preloadingStore';

  export let activeSectionIndex: number;
  export let isTransitioning: boolean = false;
  export let transitionDuration: number = 1.1;
  export let isInitialLoad: boolean = false;

  const dispatch = createEventDispatcher();

  const HERO_SECTION_LOGICAL_INDEX = 0;
  const HERO_ASSETS_TASK_ID = 'heroEffectAssets';
  const HERO_INIT_TASK_ID = 'heroEffectInitialization';

  let threeContainerElement: HTMLDivElement | undefined;
  let particleSystemInstance: ParticleEnvironment | null = null;
  let loadedFontAsset: Font | null = null;
  let loadedParticleTextureMap: THREE.Texture | null = null;

  let isThreeJsLoopRunning = false;
  let areInteractionsBound = false;
  let animationLoopPauseTimeoutId: number | undefined;
  
  let initialOpacity = isInitialLoad ? '0' : '1';

  const FONT_ASSET_PATH = '/fonts/Inter_18pt_ExtraLight.json';
  const PARTICLE_TEXTURE_ASSET_PATH = 'https://res.cloudinary.com/dfvtkoboz/image/upload/v1605013866/particle_a64uzf.png';

  async function _preloadAssets() {
    const currentStatus = preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID);
    if (currentStatus === 'loaded' && loadedFontAsset && loadedParticleTextureMap) return;
    if (currentStatus === 'loading') return;

    startLoadingTask(HERO_ASSETS_TASK_ID);

    // FIX: Use the new generic preloader to manage asset status centrally.
    try {
      await preloadAssets([FONT_ASSET_PATH, PARTICLE_TEXTURE_ASSET_PATH]);
    } catch (error) {
      console.error("HPE: Asset preloading with preloadAssets failed:", error);
      preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'error', (error as Error).message);
      return;
    }

    // Still use a local LoadingManager to know when assets are ready for *this component*.
    const manager = new THREE.LoadingManager();
    manager.onLoad = () => preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'loaded');
    manager.onError = (url) => {
      console.error(`HPE: Error loading asset for Three.js: ${url}`);
      preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'error', `Failed to load ${url}`);
    };
    const fontLoader = new FontLoader(manager);
    const textureLoader = new THREE.TextureLoader(manager);

    try {
      // Use the loaders, which will now pull from the browser cache thanks to preloadAssets.
      const [font, texture] = await Promise.all([
        fontLoader.loadAsync(FONT_ASSET_PATH),
        textureLoader.loadAsync(PARTICLE_TEXTURE_ASSET_PATH)
      ]);
      loadedFontAsset = font;
      loadedParticleTextureMap = texture;
    } catch (error) {
      console.error("HPE: Asset loading promise for Three.js failed:", error);
      if (preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID) !== 'error') {
        preloadingStore.updateTaskStatus(HERO_ASSETS_TASK_ID, 'error', 'Asset loading failed.');
      }
    }
  }

  async function _ensureInstanceAndStartLoop() {
    if (preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID) !== 'loaded' || !loadedFontAsset || !loadedParticleTextureMap) {
      console.warn("HPE: Assets not ready for _ensureInstanceAndStartLoop.");
      await _preloadAssets(); 
      if (preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID) !== 'loaded') return; 
    }
    if (!threeContainerElement) {
      console.warn("HPE: DOM container not ready for _ensureInstanceAndStartLoop.");
      return;
    }

    if (!particleSystemInstance) {
      preloadingStore.updateTaskStatus(HERO_INIT_TASK_ID, 'loading');
      try {
        particleSystemInstance = new ParticleEnvironment(loadedFontAsset!, loadedParticleTextureMap!, threeContainerElement);
        preloadingStore.updateTaskStatus(HERO_INIT_TASK_ID, 'loaded');
        console.log("HPE: Created new Three.js instance.");
      } catch (error) {
        console.error("HPE: Error during ParticleEnvironment instantiation:", error);
        preloadingStore.updateTaskStatus(HERO_INIT_TASK_ID, 'error', 'Instantiation failed.');
        particleSystemInstance = null;
        return;
      }
    }

    if (particleSystemInstance && !particleSystemInstance.isLooping()) {
      particleSystemInstance.startAnimationLoop();
      isThreeJsLoopRunning = true;
      console.log("HPE: Three.js animation loop STARTED.");
    }
  }

  function _pauseThreeJsLoop() {
    if (particleSystemInstance && particleSystemInstance.isLooping()) {
      particleSystemInstance.stopAnimationLoop();
      isThreeJsLoopRunning = false;
      console.log("HPE: Three.js animation loop PAUSED.");
    }
  }

  function _bindInteractionEvents() {
    if (particleSystemInstance?.createParticles && !areInteractionsBound) {
      particleSystemInstance.createParticles.bindInteractionEvents();
      particleSystemInstance.createParticles.resetParticleState(); 
      areInteractionsBound = true;
      console.log("HPE: Interaction events BOUND and particle state RESET.");
    }
  }

  function _unbindInteractionEvents() {
    if (particleSystemInstance?.createParticles && areInteractionsBound) {
      particleSystemInstance.createParticles.unbindInteractionEvents();
      particleSystemInstance.createParticles.neutralizeLastMousePosition(); 
      areInteractionsBound = false;
      console.log("HPE: Interaction events UNBOUND and mouse position neutralized.");
    }
  }
  function _fadeInVisuals() {
    if (threeContainerElement) {
      if (isInitialLoad) {
        threeContainerElement.style.opacity = '0';
        requestAnimationFrame(() => {
          if (threeContainerElement) {
            threeContainerElement.style.opacity = '1';
          }
        });
      } else {
        threeContainerElement.style.opacity = '1';
      }
    }
  }

  function _fadeOutVisuals() {
    if (threeContainerElement) threeContainerElement.style.opacity = '0';
  }

  // --- EXPORTED METHODS FOR +page.svelte ---
  export async function onTransitionToHeroStart() {
    console.log("HPE Method: onTransitionToHeroStart triggered.");
    clearTimeout(animationLoopPauseTimeoutId);
    await _ensureInstanceAndStartLoop();
    _fadeInVisuals();
    _unbindInteractionEvents();
  }

  export function onTransitionToHeroComplete() {
    console.log("HPE Method: onTransitionToHeroComplete triggered.");
    _bindInteractionEvents();
  }

  export function onTransitionFromHeroStart() {
    console.log("HPE Method: onTransitionFromHeroStart triggered.");
    _unbindInteractionEvents();
    _fadeOutVisuals();
    clearTimeout(animationLoopPauseTimeoutId);
    animationLoopPauseTimeoutId = window.setTimeout(() => {
      if (particleSystemInstance?.createParticles) {
        particleSystemInstance.createParticles.resetParticleState();
        console.log("HPE: Particle state RESET after fade out.");
      }
      _pauseThreeJsLoop();
    }, transitionDuration * 1000);
  }

  async function _handleSettledState() {
    if (activeSectionIndex === HERO_SECTION_LOGICAL_INDEX) {
      console.log("HPE: Settled on Hero.");
      clearTimeout(animationLoopPauseTimeoutId);
      await _ensureInstanceAndStartLoop();
      _fadeInVisuals();
      _bindInteractionEvents();
    } else {
      console.log("HPE: Settled off Hero.");
      _unbindInteractionEvents();
      _fadeOutVisuals();

      if (isThreeJsLoopRunning && particleSystemInstance?.isLooping() && animationLoopPauseTimeoutId === undefined) {
        console.log("HPE (SettledOff): Scheduling deferred pause and reset.");
        animationLoopPauseTimeoutId = window.setTimeout(() => {
          if (particleSystemInstance?.createParticles) {
            particleSystemInstance.createParticles.resetParticleState();
            console.log("HPE (SettledOff): Particle state RESET.");
          }
          _pauseThreeJsLoop();
          animationLoopPauseTimeoutId = undefined;
        }, transitionDuration * 1000);
      } else if (!isThreeJsLoopRunning && particleSystemInstance?.createParticles) {
        console.log("HPE (SettledOff): Loop already paused. Ensuring particle state is reset.");
        particleSystemInstance.createParticles.resetParticleState();
      }
    }
  }

  let isMountedAndInitialized = false;
  onMount(async () => {
    await tick(); 
    if (!preloadingStore.getTaskStatus(HERO_ASSETS_TASK_ID)) {
      preloadingStore.registerTask(HERO_ASSETS_TASK_ID, 'pending');
    }
    if (!preloadingStore.getTaskStatus(HERO_INIT_TASK_ID)) {
      preloadingStore.registerTask(HERO_INIT_TASK_ID, 'pending');
    }
    await _preloadAssets();
    isMountedAndInitialized = true;

    dispatch('ready');
    
    if (!isTransitioning && !isInitialLoad) {
      _handleSettledState();
    }
  });

  onDestroy(() => {
    clearTimeout(animationLoopPauseTimeoutId);
    _unbindInteractionEvents();
    if (particleSystemInstance?.createParticles) {
        particleSystemInstance.createParticles.resetParticleState();
    }
    _pauseThreeJsLoop();
    if (particleSystemInstance) {
      particleSystemInstance.dispose();
      particleSystemInstance = null;
      console.log("HPE: Three.js instance disposed.");
    }
  });

  $: if (isMountedAndInitialized && typeof activeSectionIndex === 'number') {
    if (!isTransitioning) {
        _handleSettledState();
    }
  }

</script>

<div
  class="hero-particle-container"
  bind:this={threeContainerElement}
  id="magic"
  style="opacity: {initialOpacity}; transition: opacity {transitionDuration}s ease-in-out;"
>
</div>

<style>
  .hero-particle-container {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    background-color: rgb(9 9 11);
    overflow: hidden;
    pointer-events: auto;
  }
</style>
--- END OF FILE src\lib\components\HeroParticleEffect.svelte ---

--- START OF FILE src\lib\components\KeyboardButtons.svelte ---
<!-- src/lib/components/KeyboardButtons.svelte -->

<script context="module" lang="ts">
  export type KeyboardButtonsInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
  };
</script>

<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import { gsap } from 'gsap';
  import type { SocialLink } from '$lib/data/siteConfig';

  const dispatch = createEventDispatcher();

  export let title: string;
  export let introduction: string;
  export let socialLinks: SocialLink[] = [];
  export let contactSectionIndex: number;
  export let navigateToSection: (index: number) => void;

  let wrapperElement: HTMLDivElement;
  let h2El: HTMLHeadingElement;
  let pEl: HTMLParagraphElement;
  // FIX: This will target the .key-position containers, which are our pre-warm targets.
  let keyPositionElements: Element[] = [];

  onMount(() => {
    if (wrapperElement) {
        keyPositionElements = gsap.utils.toArray(wrapperElement.querySelectorAll('.key-position'));
    }
  });

  export function onEnterSection() {
    if (!h2El || !pEl || keyPositionElements.length === 0) return;

    gsap.set(h2El, { autoAlpha: 0, y: 40 });
    gsap.set(pEl, { autoAlpha: 0, y: 30 });
    // Set the containers to be invisible. The pre-warmer will have already done this,
    // but this ensures it's set correctly every time.
    gsap.set(keyPositionElements, { autoAlpha: 0 });

    gsap.timeline({
      delay: 0.2,
      onComplete: () => {
        dispatch('animationComplete');
      }
    })
      .to(h2El, { autoAlpha: 1, y: 0, duration: 0.8, ease: 'power2.out' }, 0)
      .to(pEl, { autoAlpha: 1, y: 0, duration: 0.7, ease: 'power2.out' }, 0.15)
      // FIX: Animate the .key-position containers. This will make them and their children visible.
      .to(keyPositionElements, {
          autoAlpha: 1,
          duration: 0.5,
          ease: 'power1.inOut',
          stagger: 0.1,
        }, 
        0.3
      );
  }

  export function onLeaveSection() {
    // FIX: Ensure parent containers are included in the cleanup.
    const allElements = [h2El, pEl, ...keyPositionElements];
    if (allElements.some(el => !el)) return;
    
    gsap.killTweensOf(allElements);
    gsap.set(allElements, { autoAlpha: 0 });
  }

  const getLink = (name: string): string => {
    const link = socialLinks.find(l => l.name.toLowerCase() === name.toLowerCase());
    return link ? link.url : '#';
  };

  const handleContactClick = () => {
    if (typeof navigateToSection === 'function' && contactSectionIndex !== -1) {
      navigateToSection(contactSectionIndex);
    }
  };
</script>

<div class="about-text-block" bind:this={wrapperElement}>
  <h2 bind:this={h2El}>{title}</h2>
  <p bind:this={pEl}>{introduction}</p>

  <div class="keyboard-buttons-wrapper">
    {#if socialLinks.find(l => l.name.toLowerCase() === 'github')}
    <div class="key-position gpu-prewarm-target">
      <a aria-label="Github" class="key" target="_blank" rel="noopener noreferrer" href={getLink('GitHub')}>
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" color="currentColor"><path d="M10 20.568c-3.429 1.157-6.286 0-8-3.568"></path><path d="M10 22v-3.242c0-.598.184-1.118.48-1.588c.204-.322.064-.78-.303-.88C7.134 15.452 5 14.107 5 9.645c0-1.16.38-2.25 1.048-3.2c.166-.236.25-.354.27-.46c.02-.108-.015-.247-.085-.527c-.283-1.136-.264-2.343.16-3.43c0 0 .877-.287 2.874.96c.456.285.684.428.885.46s.469-.035 1.005-.169A9.5 9.5 0 0 1 13.5 3a9.6 9.6 0 0 1 2.343.28c.536.134.805.2 1.006.169c.2-.032.428-.175.884-.46c1.997-1.247 2.874-.96 2.874-.96c.424 1.087.443 2.294.16 3.43c-.07.28-.104.42-.084.526s.103.225.269.461c.668.95 1.048 2.04 1.048 3.2c0 4.462-2.364 5.807-5.177 6.643c-.367.101-.507.559-.303.88c.296.47.48.99.48 1.589V22"></path></g></svg>
      </a>
    </div>
    {/if}
    {#if socialLinks.find(l => l.name.toLowerCase() === 'linkedin')}
    <div class="key-position gpu-prewarm-target">
      <a aria-label="LinkedIn" class="key" target="_blank" rel="noopener noreferrer" href={getLink('LinkedIn')}>
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4.5 9.5H4c-.943 0-1.414 0-1.707.293S2 10.557 2 11.5V20c0 .943 0 1.414.293 1.707S3.057 22 4 22h.5c.943 0 1.414 0 1.707-.293S6.5 20.943 6.5 20v-8.5c0-.943 0-1.414-.293-1.707S5.443 9.5 4.5 9.5m2-5.25a2.25 2.25 0 1 1-4.5 0a2.25 2.25 0 0 1 4.5 0m5.826 5.25H11.5c-.943 0-1.414 0-1.707.293S9.5 10.557 9.5 11.5V20c0 .943 0 1.414.293 1.707S10.557 22 11.5 22h.5c.943 0 1.414 0 1.707-.293S14 20.943 14 20v-3.5c0-1.657.528-3 2.088-3c.78 0 1.412.672 1.412 1.5v4.5c0 .943 0 1.414.293 1.707s.764.293 1.707.293h.499c.942 0 1.414 0 1.707-.293c.292-.293.293-.764.293-1.706L22 14c0-2.486-2.364-4.5-4.703-4.5c-1.332 0-2.52.652-3.297 1.673c0-.63 0-.945-.137-1.179a1 1 0 0 0-.358-.358c-.234-.137-.549-.137-1.179-.137" color="currentColor"></path></svg>
      </a>
    </div>
    {/if}
    {#if socialLinks.find(l => l.name.toLowerCase() === 'email')}
    <div class="key-position gpu-prewarm-target">
      <a aria-label="Email" class="key" target="_blank" rel="noopener noreferrer" href={getLink('Email')}>
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" color="currentColor"><path d="m2 6l6.913 3.917c2.549 1.444 3.625 1.444 6.174 0L22 6"></path><path d="M2.016 13.476c.065 3.065.098 4.598 1.229 5.733c1.131 1.136 2.705 1.175 5.854 1.254c1.94.05 3.862.05 5.802 0c3.149-.079 4.723-.118 5.854-1.254c1.131-1.135 1.164-2.668 1.23-5.733c.02-.986.02-1.966 0-2.952c-.066-3.065-.099-4.598-1.23-5.733c-1.131-1.136-2.705-1.175-5.854-1.254a115 115 0 0 0-5.802 0c-3.149.079-4.723.118-5.854 1.254c-1.131 1.135-1.164 2.668-1.23 5.733a69 69 0 0 0 0 2.952"></path></g></svg>
      </a>
    </div>
    {/if}
    <div class="key-position gpu-prewarm-target">
      <button type="button" id="about-contact-me-btn" class="key call-to-action peer" on:click={handleContactClick}>
        <span class="call-to-action-content">Contact Me</span>
      </button>
    </div>
  </div>
</div>

<style>
  .about-text-block { max-width: 580px; }
  .about-text-block > p { 
    font-size: clamp(1rem, 2.2vw, 1.15rem); 
    line-height: 1.8; 
    margin-bottom: 2.5rem; 
    color: rgb(212 212 216); 
    opacity: 0;
    visibility: hidden;
  }
  .about-text-block h2 {
    font-size: clamp(2.2rem, 4.5vw, 3rem);
    margin-bottom: 1.5rem;
    font-weight: 300;
    letter-spacing: -0.02em;
    color: rgb(245 245 247);
    opacity: 0;
    visibility: hidden;
  }
  .keyboard-buttons-wrapper svg { width: 1.75rem; height: 1.75rem; color: var(--keyboard-contrast); }
  .keyboard-buttons-wrapper { display: flex; align-items: flex-start; text-align: center; gap: calc(var(--keyboard-key-base-size) * 0.01); }
  .key-position { perspective: 800px; transform: rotateY(0.05turn) rotateX(-0.1turn); }
  .key.call-to-action { width: 140px; font-size: 13px; font-weight: 500; text-transform: uppercase; letter-spacing: 0.05rem; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
  .call-to-action-content { position: relative; }
  .call-to-action-content:after { position: absolute; content: ""; width: 0; left: 0; bottom: -4px; background: var(--keyboard-contrast); height: 1.5px; transition: 0.3s ease-out; }
  .key.call-to-action:hover .call-to-action-content:after { width: 100%;}
  /* FIX: Remove opacity and visibility from the .key itself. Its visibility is now
     entirely controlled by its parent, .key-position. */
  .key { 
    position: relative; 
    width: var(--keyboard-key-base-size); 
    height: var(--keyboard-key-base-size); 
    font-size: calc(var(--keyboard-key-base-size) / 2.2); 
    border: 0.1rem solid var(--keyboard-background-3); 
    border-radius: calc(var(--keyboard-key-base-size) * 0.2); 
    background: var(--keyboard-background-2); 
    color: var(--keyboard-contrast); 
    box-shadow: 0.15rem 0.15rem 0 0 var(--keyboard-background-3), 0.3rem 0.3rem 0 0 var(--keyboard-background-3), 0.45rem 0.45rem 0 0 var(--keyboard-background-3), 0.6rem 0.6rem 0 0 var(--keyboard-background-3); 
    transition: transform 0.2s ease, box-shadow 0.2s ease; 
    display: flex; 
    align-items: center; 
    justify-content: center; 
    text-decoration: none; 
    transform-style: preserve-3d;
  }
  .key span { color: inherit; margin: 0; padding: 0; }
  .key:hover { cursor: pointer; transform: translate(0.3rem, 0.3rem); }
  .key:active { cursor: grabbing; transform: translate(0.8rem, 0.8rem); box-shadow: 0.1rem 0.1rem 0 0 var(--keyboard-background-3), 0.1rem 0.1rem 0 0 var(--keyboard-background-3), 0.2rem 0.2rem 0 0 var(--keyboard-background-3), 0.2rem 0.2rem 0 0 var(--keyboard-background-3); filter: blur(0.02rem); }
  @media (max-width: 640px) { .keyboard-buttons-wrapper { flex-direction: column; align-items: center; gap: 1rem; } }
</style>
--- END OF FILE src\lib\components\KeyboardButtons.svelte ---

--- START OF FILE src\lib\components\LoadingScreen.svelte ---
<!-- src/lib/components/LoadingScreen.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import { overallLoadingState, initialSiteLoadComplete, minimumLoadingDuration } from '$lib/stores/preloadingStore';
  import { get } from 'svelte/store';

  let showScreen = !get(initialSiteLoadComplete);
  let isFadingOut = false;
  let textElement: HTMLDivElement;
  let tickerInstance: Ticker | null = null;
  
  const fadeOutDuration = 800; // ms
  const fadeOutDelay = 200; // ms
  
  let loadingStartTime = Date.now();
  let minimumDurationTimer: number | undefined;
  
  // Ticker class for continuous matrix-like animation
  class Ticker {
    private done = false;
    private cycleCount = 8;
    private cycleCurrent = 0;
    private chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*()-_=+{}|[]\\;\':"<>?,./`~'.split('');
    private charsCount = this.chars.length;
    private letters: HTMLSpanElement[] = [];
    private letterCount = 0;
    private letterCurrent = 0;
    private animationFrameId: number | null = null;
    private originalText: string;
    private continuousMode = false;

    constructor(element: HTMLDivElement, text: string) {
      this.originalText = text;
      this.setupLetters(element);
    }

    private setupLetters(element: HTMLDivElement) {
      element.innerHTML = '';
      this.letters = [];
      for (let i = 0; i < this.originalText.length; i++) {
        const span = document.createElement('span');
        span.setAttribute('data-orig', this.originalText[i]);
        span.textContent = '-';
        span.style.display = 'inline-block';
        element.appendChild(span);
        this.letters.push(span);
      }
      this.letterCount = this.letters.length;
    }

    private getChar(): string {
      return this.chars[Math.floor(Math.random() * this.charsCount)];
    }

    public start(): void {
      this.loop();
    }
    
    private loop = (): void => {
      if (this.continuousMode) {
        // In continuous mode, randomly glitch some letters periodically
        this.letters.forEach((letter) => {
          const orig = letter.getAttribute('data-orig');
          if (orig !== ' ' && Math.random() < 0.1) { // 10% chance per frame
            letter.textContent = this.getChar();
            letter.style.opacity = String(0.5 + Math.random() * 0.5);
            
            setTimeout(() => {
              letter.textContent = orig || '';
              letter.style.opacity = '1';
            }, 100 + Math.random() * 200);
          }
        });
      } else {
        // Original progressive reveal animation
        this.letters.forEach((letter, index) => {
          if (index >= this.letterCurrent) {
            const orig = letter.getAttribute('data-orig');
            if (orig !== ' ') {
              letter.textContent = this.getChar();
              letter.style.opacity = String(Math.random());
            }
          }
        });

        if (this.cycleCurrent < this.cycleCount) {
          this.cycleCurrent++;
        } else if (this.letterCurrent < this.letterCount) {
          const currLetter = this.letters[this.letterCurrent];
          this.cycleCurrent = 0;
          currLetter.textContent = currLetter.getAttribute('data-orig') || '';
          currLetter.style.opacity = '1';
          currLetter.style.transform = 'translateX(0) scale(1)';
          currLetter.classList.add('done');
          this.letterCurrent++;
        } else {
          this.done = true;
          // Switch to continuous mode after initial reveal
          this.continuousMode = true;
          this.done = false;
        }
      }

      if (!this.done) {
        this.animationFrameId = requestAnimationFrame(this.loop);
      }
    };

    public destroy(): void {
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      this.done = true;
    }
  }

  function handleLoadingComplete() {
    if (isFadingOut) return;
    
    const elapsedTime = Date.now() - loadingStartTime;
    const remainingMinimumTime = Math.max(0, minimumLoadingDuration - elapsedTime);
    
    minimumDurationTimer = setTimeout(() => {
      if (tickerInstance) {
        tickerInstance.destroy();
      }
      isFadingOut = true;
      
      setTimeout(() => {
        showScreen = false;
      }, fadeOutDuration + fadeOutDelay);
    }, remainingMinimumTime);
  }

  const unsubInitialLoad = initialSiteLoadComplete.subscribe(completed => {
    if (completed && showScreen && !isFadingOut) {
      handleLoadingComplete();
    }
  });

  const unsubOverallState = overallLoadingState.subscribe(status => {
    if (get(initialSiteLoadComplete)) return;
    
    if (status === 'error' && textElement) {
      clearTimeout(minimumDurationTimer);
      if (tickerInstance) tickerInstance.destroy();
      tickerInstance = new Ticker(textElement, "ERROR LOADING");
      tickerInstance.start();
    }
  });

  onMount(() => {
    loadingStartTime = Date.now();
    if (!get(initialSiteLoadComplete) && textElement) {
      tickerInstance = new Ticker(textElement, "LOADING...");
      tickerInstance.start();
    }
  });

  onDestroy(() => {
    if (tickerInstance) tickerInstance.destroy();
    clearTimeout(minimumDurationTimer);
    unsubOverallState();
    unsubInitialLoad();
  });
</script>

{#if showScreen}
  <div class="loading-overlay" class:fade-out={isFadingOut} style="--fade-duration: {fadeOutDuration}ms;">
    <div class="loading-content">
      <div class="word" bind:this={textElement}></div>
      <div class="scanline-overlay"></div>
    </div>
  </div>
{/if}

<style>
  .loading-overlay {
    position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
    background: radial-gradient(ellipse at center, #0a1a0a 0%, #000500 100%);
    display: flex; justify-content: center; align-items: center; z-index: 10000;
    opacity: 1; transition: opacity var(--fade-duration) cubic-bezier(0.4, 0, 0.2, 1);
  }
  .loading-overlay.fade-out { opacity: 0; pointer-events: none; }
  .loading-content { position: relative; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; }
  .word {
    color: #fff; font-family: 'Source Code Pro', 'Courier New', monospace; font-weight: 400; font-size: clamp(1.5rem, 4vw, 2.5rem); text-transform: uppercase; letter-spacing: 0.15em;
    text-shadow: 0 0 10px rgba(50, 255, 50, 0.5), 0 0 20px rgba(100, 255, 100, 0.5), 0 0 30px rgba(50, 255, 50, 0.3), 0 0 40px rgba(100, 255, 100, 0.2);
    position: relative; z-index: 2; animation: flicker 4s linear infinite;
  }
  .word :global(span) { display: inline-block; transform: translateX(100%) scale(0.9); transition: transform 500ms cubic-bezier(0.4, 0, 0.2, 1); will-change: transform, opacity; }
  .word :global(.done) { color: #6f6; transform: translateX(0) scale(1) !important; }
  .scanline-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: repeating-linear-gradient( 0deg, transparent, transparent 2px, rgba(50, 255, 50, 0.03) 2px, rgba(50, 255, 50, 0.03) 4px ); background-size: 100% 4px; animation: scanline 8s linear infinite; pointer-events: none; z-index: 1; }
  .scanline-overlay::before { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: linear-gradient( 180deg, transparent 0%, rgba(50, 255, 50, 0.02) 50%, transparent 100% ); animation: scanline-move 3s linear infinite; }
  @keyframes scanline { 0% { background-position: 0 0; } 100% { background-position: 0 10px; } }
  @keyframes scanline-move { 0% { transform: translateY(-100%); } 100% { transform: translateY(100%); } }
  @keyframes flicker { 0%, 100% { opacity: 1; } 92% { opacity: 0.95; } 94% { opacity: 1; } 96% { opacity: 0.97; } }
  @media (max-width: 640px) { .word { font-size: 1.25rem; letter-spacing: 0.1em; } }
  @media (prefers-reduced-motion: reduce) { .word :global(span) { transition: none; } .scanline-overlay, .scanline-overlay::before { animation: none; } }
</style>
--- END OF FILE src\lib\components\LoadingScreen.svelte ---

--- START OF FILE src\lib\components\ParallaxCard.svelte ---
<!-- src/lib/components/ParallaxCard.svelte -->
<script lang="ts">
  import { onMount, onDestroy } from 'svelte';
  import type { ProjectCard } from '$lib/data/projectsData';

  export let cardData: ProjectCard;
  export let width: string = '240px';
  export let height: string = '320px';

  let cardWrapElement: HTMLDivElement;
  let elementWidth: number = 0;
  let elementHeight: number = 0;
  let mouseX: number = 0;
  let mouseY: number = 0;
  let mouseLeaveDelay: number | null = null;

  onMount(() => {
    if (cardWrapElement) {
      elementWidth = cardWrapElement.offsetWidth;
      elementHeight = cardWrapElement.offsetHeight;
    }
  });

  onDestroy(() => {
    if (mouseLeaveDelay) clearTimeout(mouseLeaveDelay);
  });

  $: mousePX = mouseX / elementWidth;
  $: mousePY = mouseY / elementHeight;
  $: rX = !isNaN(mousePX) ? mousePX * 30 : 0;
  $: rY = !isNaN(mousePY) ? mousePY * -30 : 0;
  $: tX = !isNaN(mousePX) ? mousePX * -40 : 0;
  $: tY = !isNaN(mousePY) ? mousePY * -40 : 0;
  $: cardStyle = `transform: rotateY(${rX}deg) rotateX(${rY}deg);`;
  $: cardBgTransform = `transform: translateX(${tX}px) translateY(${tY}px);`;
  $: cardBgImage = `background-image: url(${cardData.image});`;

  function handleMouseMove(e: MouseEvent) {
    if (!cardWrapElement) return;
    const rect = cardWrapElement.getBoundingClientRect();
    mouseX = e.clientX - rect.left - elementWidth / 2;
    mouseY = e.clientY - rect.top - elementHeight / 2;
  }

  function handleMouseEnter() {
    if (mouseLeaveDelay) clearTimeout(mouseLeaveDelay);
  }

  function handleMouseLeave() {
    mouseLeaveDelay = window.setTimeout(() => {
      mouseX = 0;
      mouseY = 0;
    }, 1000);
  }
</script>

<!-- Add the 'gpu-prewarm-target' class here -->
<div
  class="card-wrap gpu-prewarm-target"
  style:width
  style:height
  on:mousemove={handleMouseMove}
  on:mouseenter={handleMouseEnter}
  on:mouseleave={handleMouseLeave}
  bind:this={cardWrapElement}
  role="group"
  aria-label="Interactive project card for {cardData.title}"
>
  <div class="card" style={cardStyle}>
    <div class="card-bg" style="{cardBgTransform} {cardBgImage}" id="card-bg-{cardData.id}"></div>
    <div class="card-info">
      <h1 class="card-title">{cardData.title}</h1>
      {#if cardData.description}
        <p class="card-description">{cardData.description}</p>
      {/if}
    </div>
  </div>
</div>

<style>
  .card-wrap {
    margin: 10px;
    transform: perspective(800px);
    transform-style: preserve-3d;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    opacity: 1;
    visibility: visible;
    will-change: transform;
  }
  .card-wrap:hover .card-info {
    transform: translateY(0);
  }
  .card-wrap:hover .card-description {
    opacity: 1;
  }
  .card-wrap:hover .card-info,
  .card-wrap:hover .card-info p {
    transition: 0.6s cubic-bezier(0.23, 1, 0.32, 1);
  }
  .card-wrap:hover .card-info:after {
    transition: 5s cubic-bezier(0.23, 1, 0.32, 1);
    opacity: 1;
    transform: translateY(0);
  }
  .card-wrap:hover .card-bg {
    transition: 0.6s cubic-bezier(0.23, 1, 0.32, 1), opacity 5s cubic-bezier(0.23, 1, 0.32, 1);
    opacity: 0.8;
  }
  .card-wrap:hover .card {
    transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1), box-shadow 2s cubic-bezier(0.23, 1, 0.32, 1);
    box-shadow: rgba(255, 255, 255, 0.2) 0 0 40px 5px, white 0 0 0 1px, rgba(0, 0, 0, 0.66) 0 30px 60px 0, inset #333 0 0 0 5px, inset white 0 0 0 6px;
  }

  .card {
    position: relative;
    width: 100%;
    height: 100%;
    background-color: #333;
    overflow: hidden;
    border-radius: 10px;
    box-shadow: inset #333 0 0 0 5px, inset rgba(255, 255, 255, 0.5) 0 0 0 6px;
    transition: transform 1s cubic-bezier(0.445, 0.05, 0.55, 0.95), box-shadow 1s cubic-bezier(0.445, 0.05, 0.55, 0.95);
  }

  .card-bg {
    opacity: 0.5;
    position: absolute;
    top: -20px;
    left: -20px;
    width: calc(100% + 40px);
    height: calc(100% + 40px);
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
    transition: 1s cubic-bezier(0.445, 0.05, 0.55, 0.95), opacity 5s 1s cubic-bezier(0.445, 0.05, 0.55, 0.95);
    pointer-events: none;
  }

  .card-info {
    padding: 20px;
    position: absolute;
    bottom: 0;
    color: #fff;
    transform: translateY(40%);
    transition: transform 0.6s cubic-bezier(0.23, 1, 0.32, 1);
  }
  
  .card-description {
    opacity: 0;
    transition: opacity 0.6s cubic-bezier(0.23, 1, 0.32, 1);
    text-shadow: black 0 2px 3px;
    font-size: 0.9rem;
    line-height: 1.5;
    will-change: opacity, transform;
  }
  
  .card-info * {
    position: relative;
    z-index: 1;
  }
  .card-info:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    z-index: 0;
    width: 100%;
    height: 100%;
    background-image: linear-gradient(to bottom, transparent 0%, rgba(0, 0, 0, 0.6) 100%);
    background-blend-mode: overlay;
    opacity: 0;
    transform: translateY(100%);
    transition: 5s 1s cubic-bezier(0.445, 0.05, 0.55, 0.95);
  }
  
  .card-info .card-title {
    font-size: clamp(1.4rem, 10vw, 2rem);
    font-family: 'Playfair Display', serif;
    font-weight: 700;
    text-shadow: rgba(0, 0, 0, 0.5) 0 10px 10px;
    margin-bottom: 0.5rem;
    opacity: 1; 
  }
</style>
--- END OF FILE src\lib\components\ParallaxCard.svelte ---

--- START OF FILE src\lib\components\sections\AboutSection.svelte ---
<!-- src/lib/components/sections/AboutSection.svelte -->
<script context="module" lang="ts">
  export type AboutSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    initializeEffect?: () => Promise<void>;
    // Add the new optional method to its type definition
    onTransitionComplete?: () => void;
  };
</script>

<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import { siteConfig } from '$lib/data/siteConfig';

  import KeyboardButtons from '$lib/components/KeyboardButtons.svelte';
  import AboutImageEffect from '$lib/components/AboutImageEffect.svelte';
  import type { KeyboardButtonsInstance } from '$lib/components/KeyboardButtons.svelte';
  import type { AboutImageEffectInstance } from '$lib/components/AboutImageEffect.svelte';

  const dispatch = createEventDispatcher();

  type AboutSectionData = typeof siteConfig.aboutSection;
  export let data: AboutSectionData;
  export let contactSectionIndex: number;
  export let navigateToSection: (index: number) => void;

  let keyboardButtonsInstance: KeyboardButtonsInstance | null = null;
  let aboutImageEffectInstance: AboutImageEffectInstance | null = null;

  // This is called by the preload manager while the section is off-screen.
  export async function initializeEffect() {
    if (aboutImageEffectInstance?.initializeEffect) {
      await aboutImageEffectInstance.initializeEffect();
    }
  }

  // This is called at the START of the page transition.
  // It should only contain lightweight animations.
  export function onEnterSection(): void {
    if (keyboardButtonsInstance) {
      keyboardButtonsInstance.onEnterSection();
    }
    if (aboutImageEffectInstance) {
      // The image effect's onEnterSection just starts a simple fade-in.
      aboutImageEffectInstance.onEnterSection();
    }
  }
  
  // FIX: This is called at the END of the page transition.
  // It's for heavy, layout-dependent animations.
  export function onTransitionComplete() {
    if (aboutImageEffectInstance?.onTransitionComplete) {
      // This starts the particle rendering, which depends on the final layout.
      aboutImageEffectInstance.onTransitionComplete();
    }
  }

  // This is called when navigating away from the section.
  export function onLeaveSection(): void {
    if (keyboardButtonsInstance) {
      keyboardButtonsInstance.onLeaveSection();
    }
    if (aboutImageEffectInstance) {
      aboutImageEffectInstance.onLeaveSection();
    }
  }

  function handleAnimationComplete() {
    dispatch('animationComplete');
  }
</script>

<div class="about-section-wrapper">
  <div class="about-content-wrapper">
    <KeyboardButtons 
      bind:this={keyboardButtonsInstance}
      title={data.title}
      introduction={data.introduction}
      socialLinks={data.socialLinks}
      {contactSectionIndex}
      {navigateToSection}
      on:animationComplete={handleAnimationComplete}
    />
  </div>

  <AboutImageEffect
    bind:this={aboutImageEffectInstance}
    imageUrl={data.imageUrl}
  />
</div>

<style>
  .about-section-wrapper {
    width: 100%;
    height: 100%;
    padding: 0;
    text-align: left;
    background-color: transparent;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: row;
    justify-content: space-between;
  }

  .about-content-wrapper {
    position: relative;
    z-index: 3;
    flex-grow: 1;
    height: 100%;
    display: flex;
    justify-content: flex-start;
    align-items: center;
    padding: 3rem max(calc(env(safe-area-inset-left, 0px) + 6vw), 3rem);
    padding-right: 2rem;
    box-sizing: border-box;
  }
  
  @media (max-width: 768px) {
    .about-section-wrapper { 
      flex-direction: column;
      justify-content: center;
      padding: 2rem; 
      align-items: center;
    }

    .about-content-wrapper { 
      justify-content: center; 
      text-align: center; 
      padding: 1rem;
      width: 100%;
      flex-grow: 0;
      z-index: 2;
    }
    
    .about-section-wrapper :global(.main-container) {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0.15 !important;
      z-index: 1;
    }

    .about-section-wrapper :global(.image-pane) {
      justify-content: center;
    }

    .about-section-wrapper :global(.image-pane img) {
      width: 100vw;
      height: 100vh;
      object-fit: cover;
    }
  }
</style>
--- END OF FILE src\lib\components\sections\AboutSection.svelte ---

--- START OF FILE src\lib\components\sections\ContactSection.svelte ---
<!-- src/lib/components/sections/ContactSection.svelte -->
<script context="module" lang="ts">
  export type ContactSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
  };
</script>

<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import { gsap } from 'gsap';
  import { siteConfig } from '$lib/data/siteConfig';

  // Create an event dispatcher.
  const dispatch = createEventDispatcher();

  type ContactSectionData = typeof siteConfig.contactSection;
  export let data: ContactSectionData;

  let sectionWrapper: HTMLElement;
  let animatableElements: Element[] = [];

  onMount(() => {
    if (sectionWrapper) {
        animatableElements = gsap.utils.toArray(sectionWrapper.querySelectorAll('h2, p, a'));
    }
  });

  export function onEnterSection(): void {
    if (animatableElements.length === 0) return;

    gsap.set(animatableElements, { autoAlpha: 0, y: 30 });

    // Create the staggered entrance timeline.
    gsap.to(animatableElements, {
      autoAlpha: 1,
      y: 0,
      duration: 0.8,
      stagger: 0.15,
      ease: 'power2.out',
      // Add an onComplete callback to the tween itself.
      onComplete: () => {
        dispatch('animationComplete');
      }
    });
  }

  export function onLeaveSection(): void {
    if (animatableElements.length === 0) return;
    
    gsap.killTweensOf(animatableElements);
    gsap.set(animatableElements, { autoAlpha: 0 });
  }
</script>

<div class="contact-content-wrapper" bind:this={sectionWrapper}>
  <div class="content-center">
    <h2>{data.title}</h2>
    <p>{data.outroMessage}</p>
    <p>Email: <a href="mailto:{data.email}">{data.email}</a></p>
    {#if data.additionalLinks}
      <div class="additional-links">
        {#each data.additionalLinks as link}
          <a href={link.url} target="_blank" rel="noopener noreferrer">{link.name}</a>
        {/each}
      </div>
    {/if}
  </div>
</div>

<style>
  .contact-content-wrapper {
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    background-color: rgb(24 24 27);
    color: rgb(245 245 247);
  }

  .content-center {
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem;
  }

  h2, p, a {
    opacity: 0;
    visibility: hidden;
  }

  h2 {
    font-size: 2.5rem;
    margin-bottom: 2rem;
    font-weight: 300;
    letter-spacing: -0.02em;
  }

  p {
    font-size: 1.15rem;
    line-height: 1.8;
    margin-bottom: 1.5rem;
    color: rgb(212 212 216);
  }

  a {
    color: rgb(99 102 241);
    text-decoration: none;
    font-weight: 500;
    transition: color 0.3s ease;
  }

  a:hover {
    color: rgb(129 140 248);
    text-decoration: underline;
  }

  .additional-links {
    margin-top: 2rem;
    display: flex;
    gap: 2rem;
    justify-content: center;
  }
</style>
--- END OF FILE src\lib\components\sections\ContactSection.svelte ---

--- START OF FILE src\lib\components\sections\HeroSection.svelte ---
<!-- src/lib/components/sections/HeroSection.svelte -->
<script context="module" lang="ts">
  import type { SvelteComponent } from 'svelte';

  // The instance type must now be a superset, including our standard API
  // and the specific Hero API for the orchestrator to use.
  export interface HeroSectionInstance {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    // We still expose the underlying component's methods for fine-grained control
    // during the initial site reveal sequence in +page.svelte.
    onTransitionToHeroStart: () => Promise<void>;
    onTransitionToHeroComplete: () => void;
    onTransitionFromHeroStart: () => void;
  }

  // A more specific type for the internal HeroParticleEffect component instance.
  interface HeroParticleEffectComponent extends SvelteComponent {
    onTransitionToHeroStart: () => Promise<void>;
    onTransitionToHeroComplete: () => void;
    onTransitionFromHeroStart: () => void;
  }
</script>

<script lang="ts">
  import { createEventDispatcher } from 'svelte';
  import HeroParticleEffect from '$lib/components/HeroParticleEffect.svelte';

  const dispatch = createEventDispatcher();

  // Props that will be passed down from the orchestrator (+page.svelte)
  export let activeSectionIndex: number;
  export let isTransitioning: boolean;
  export let transitionDuration: number;
  export let isInitialLoad: boolean;

  // Binding for the child particle effect component
  let heroParticleEffectInstance: HeroParticleEffectComponent | null = null;
  
  // --- Standard Animation API Implementation ---

  /**
   * This is the "enter" function for standard section-to-section navigation.
   * It proxies the generic call to the specific method on the particle effect component.
   */
  export function onEnterSection(): void {
    heroParticleEffectInstance?.onTransitionToHeroStart();
  }

  /**
   * This is the "leave" function for standard section-to-section navigation.
   * It proxies the generic call to the specific method on the particle effect component.
   */
  export function onLeaveSection(): void {
    heroParticleEffectInstance?.onTransitionFromHeroStart();
  }


  // --- Exposing the underlying API for fine-grained control ---
  // These are needed for the initial site load/reveal sequence in +page.svelte,
  // which has slightly different logic than a standard section transition.

  export function onTransitionToHeroStart(): Promise<void> {
    return heroParticleEffectInstance?.onTransitionToHeroStart() ?? Promise.resolve();
  }

  export function onTransitionToHeroComplete(): void {
    heroParticleEffectInstance?.onTransitionToHeroComplete();
  }

  export function onTransitionFromHeroStart(): void {
    heroParticleEffectInstance?.onTransitionFromHeroStart();
  }

</script>

<!-- 
  This wrapper contains the HeroParticleEffect. It ensures the effect is
  always present in the DOM, ready to be animated. The `div` itself
  doesn't need styling as the particle effect creates its own full-screen canvas.
-->
<div class="hero-section-wrapper">
  <HeroParticleEffect
    bind:this={heroParticleEffectInstance}
    {activeSectionIndex}
    {isTransitioning}
    {transitionDuration}
    {isInitialLoad}
    on:ready={() => dispatch('ready')}
  />
</div>

<style>
  .hero-section-wrapper {
    /* 
      This wrapper needs to occupy the full space of its parent <section>
      to ensure the particle effect's container (which is appended inside it)
      can correctly calculate its dimensions.
    */
    width: 100%;
    height: 100%;
    position: relative;
  }
</style>
--- END OF FILE src\lib\components\sections\HeroSection.svelte ---

--- START OF FILE src\lib\components\sections\ProjectOneSection.svelte ---
<!-- src/lib/components/sections/ProjectOneSection.svelte -->
<script context="module" lang="ts">
  export type ProjectOneSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
  };
</script>

<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import { goto } from '$app/navigation';
  import { gsap } from 'gsap';
  import type { Project, ProjectCard } from '$lib/data/projectsData';
  import ParallaxCard from '$lib/components/ParallaxCard.svelte';
  
  // Create an event dispatcher to signal when animations are done.
  const dispatch = createEventDispatcher();

  export let project: Project;

  let sectionEl: HTMLElement;
  let headlineEl: HTMLHeadingElement;
  let summaryEl: HTMLParagraphElement;
  let readMoreBtn: HTMLButtonElement | null = null;
  let cardWrapsToAnimate: HTMLElement[] = [];
  
  onMount(() => {
    cardWrapsToAnimate = Array.from(sectionEl.querySelectorAll('.card-wrap'));
  });
  
  export function onEnterSection() {
    if (!headlineEl || !summaryEl || cardWrapsToAnimate.length === 0) return;

    gsap.set(headlineEl, { autoAlpha: 0, y: 50 });
    gsap.set(summaryEl, { autoAlpha: 0, y: 40 });
    gsap.set(cardWrapsToAnimate, { autoAlpha: 0, scale: 0.97 });
    if(readMoreBtn) gsap.set(readMoreBtn, { autoAlpha: 0 });

    const tl = gsap.timeline({
      // Add an onComplete callback to the timeline.
      onComplete: () => {
        // Signal that the animation has finished.
        dispatch('animationComplete');
      }
    });
    tl.to(headlineEl, { autoAlpha: 1, y: 0, duration: 0.8, ease: 'power2.out' }, "start")
      .to(summaryEl, { autoAlpha: 1, y: 0, duration: 0.7, ease: 'power2.out' }, "start+=0.1")
      .to(cardWrapsToAnimate, { 
          autoAlpha: 1,
          scale: 1, 
          duration: 2.8, 
          stagger: 0.15, 
          ease: 'expo.out' 
      }, "start+=0.2");

    if (readMoreBtn) {
      tl.to(readMoreBtn, { autoAlpha: 1, duration: 0.5, ease: 'power2.out' }, "start+=0.4");
    }
  }

  export function onLeaveSection() {
    if (!headlineEl || !summaryEl || cardWrapsToAnimate.length === 0) return;
    
    const allElements = [headlineEl, summaryEl, ...cardWrapsToAnimate];
    if (readMoreBtn) allElements.push(readMoreBtn);
    
    gsap.killTweensOf(allElements);
    gsap.set(allElements, { autoAlpha: 0 });
  }
  
  function handleCardClick(card: ProjectCard) {
    const aspectLink = card.aspectLink || '';
    goto(`/projects/${project.slug}${aspectLink}`);
  }
</script>

<div class="project-section-wrapper" bind:this={sectionEl}>
  <div class="background-image-container" style="background-image: url({project.background.value});"></div>
  <div class="content-overlay">
    <div class="project-content">
      <h2 bind:this={headlineEl}>{project.headline}</h2>
      <p class="project-summary" bind:this={summaryEl}>{project.summary}</p>
      
      <div class="project-cards-container">
        {#each project.cards as card (card.id)}
          <button type="button" class="card-click-wrapper" on:click={() => handleCardClick(card)}>
            <ParallaxCard cardData={card} width="220px" height="290px" />
          </button>
        {/each}
      </div>
      
      {#if project.readMoreLinkText}
        <button class="read-more-btn" on:click={() => goto(`/projects/${project.slug}`)} bind:this={readMoreBtn}>
            {project.readMoreLinkText}
        </button>
      {/if}
    </div>
  </div>
</div>

<style>
    .project-section-wrapper { 
        width: 100%; 
        height: 100%; 
        color: rgb(245 245 247); 
        z-index: 2; 
        background-color: transparent; 
        display: flex; 
        flex-direction: column; 
        justify-content: center; 
        align-items: center; 
    }
    .background-image-container { 
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background-size: cover; 
        background-position: center; 
        z-index: -1; 
        transform: scale(1); 
    }
    .content-overlay { 
        background-color: rgba(9 9 11 / 0.85); 
        backdrop-filter: blur(8px); 
        padding: 2rem 3rem; 
        border-radius: 16px; 
        width: 90%; 
        max-width: 1100px; 
        z-index: 1; 
        position: relative; 
        border: 1px solid rgba(255 255 255 / 0.1); 
    }
    .project-content { 
        text-align: center; 
    }
    h2 { 
        opacity: 0; 
        visibility: hidden;
        font-size: 2.5rem; 
        font-weight: 300; 
        margin-bottom: 1rem; 
        letter-spacing: -0.02em; 
    }
    p.project-summary { 
        opacity: 0; 
        visibility: hidden;
        font-size: 1.15rem; 
        color: rgb(212 212 216); 
        line-height: 1.7; 
        margin-bottom: 2rem; 
        max-width: 800px; 
        margin-left: auto; 
        margin-right: auto; 
    }
    .project-cards-container { 
        display: flex; 
        justify-content: center; 
        gap: 1rem; 
        margin-top: 1rem; 
        margin-bottom: 2rem; 
        flex-wrap: wrap; 
    }
    .card-click-wrapper { 
        background: none; 
        border: none; 
        padding: 0; 
        cursor: pointer; 
        border-radius: 10px; 
        transition: transform 0.3s ease, box-shadow 0.3s ease; 
    }
    .card-click-wrapper:hover { 
        transform: translateY(-5px); 
        box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
    }
    .card-click-wrapper:focus-visible { 
        outline: 2px solid rgb(99 102 241); 
        outline-offset: 4px; 
    }
    button.read-more-btn { 
        opacity: 0; 
        visibility: hidden;
        padding: 0.875rem 2rem; 
        background-color: rgb(99 102 241); 
        color: white; 
        border: none; 
        border-radius: 8px; 
        cursor: pointer; 
        font-size: 1rem; 
        font-weight: 500; 
        transition: all 0.3s ease; 
        margin-top: 1rem; 
    }
    button.read-more-btn:hover { 
        background-color: rgb(79 70 229); 
        transform: translateY(-2px); 
        box-shadow: 0 4px 20px rgba(99 102 241 / 0.4); 
    }
</style>
--- END OF FILE src\lib\components\sections\ProjectOneSection.svelte ---

--- START OF FILE src\lib\components\sections\ProjectTwoSection.svelte ---
<!-- src/lib/components/sections/ProjectTwoSection.svelte -->
<script context="module" lang="ts">
  export type ProjectTwoSectionInstance = {
    onEnterSection: () => void;
    onLeaveSection: () => void;
  };
</script>

<script lang="ts">
  import { onMount, createEventDispatcher } from 'svelte';
  import { goto } from '$app/navigation';
  import { gsap } from 'gsap';
  import type { Project, ProjectCard } from '$lib/data/projectsData';
  import ParallaxCard from '$lib/components/ParallaxCard.svelte';
  
  // Create an event dispatcher to signal when animations are done.
  const dispatch = createEventDispatcher();

  export let project: Project;

  let sectionEl: HTMLElement;
  let headlineEl: HTMLHeadingElement;
  let summaryEl: HTMLParagraphElement;
  let readMoreBtn: HTMLButtonElement | null = null;
  let cardWrapsToAnimate: HTMLElement[] = [];
  
  onMount(() => {
    cardWrapsToAnimate = Array.from(sectionEl.querySelectorAll('.card-wrap'));
  });
  
  export function onEnterSection() {
    if (!headlineEl || !summaryEl || cardWrapsToAnimate.length === 0) return;

    gsap.set(headlineEl, { autoAlpha: 0, y: 50 });
    gsap.set(summaryEl, { autoAlpha: 0, y: 40 });
    gsap.set(cardWrapsToAnimate, { autoAlpha: 0, scale: 0.97 });
    if(readMoreBtn) gsap.set(readMoreBtn, { autoAlpha: 0 });

    const tl = gsap.timeline({
      // Add an onComplete callback to the timeline.
      onComplete: () => {
        // Signal that the animation has finished.
        dispatch('animationComplete');
      }
    });
    tl.to(headlineEl, { autoAlpha: 1, y: 0, duration: 0.8, ease: 'power2.out' }, "start")
      .to(summaryEl, { autoAlpha: 1, y: 0, duration: 0.7, ease: 'power2.out' }, "start+=0.1")
      .to(cardWrapsToAnimate, { 
          autoAlpha: 1,
          scale: 1, 
          duration: 2.8, 
          stagger: 0.15, 
          ease: 'expo.out' 
      }, "start+=0.2");

    if (readMoreBtn) {
      tl.to(readMoreBtn, { autoAlpha: 1, duration: 0.5, ease: 'power2.out' }, "start+=0.4");
    }
  }

  export function onLeaveSection() {
    if (!headlineEl || !summaryEl || cardWrapsToAnimate.length === 0) return;
    
    const allElements = [headlineEl, summaryEl, ...cardWrapsToAnimate];
    if (readMoreBtn) allElements.push(readMoreBtn);
    
    gsap.killTweensOf(allElements);
    gsap.set(allElements, { autoAlpha: 0 });
  }
  
  function handleCardClick(card: ProjectCard) {
    const aspectLink = card.aspectLink || '';
    goto(`/projects/${project.slug}${aspectLink}`);
  }
</script>

<div class="project-section-wrapper" bind:this={sectionEl}>
  <div class="background-image-container" style="background-image: url({project.background.value});"></div>
  <div class="content-overlay">
    <div class="project-content">
      <h2 bind:this={headlineEl}>{project.headline}</h2>
      <p class="project-summary" bind:this={summaryEl}>{project.summary}</p>
      
      <div class="project-cards-container">
        {#each project.cards as card (card.id)}
          <button type="button" class="card-click-wrapper" on:click={() => handleCardClick(card)}>
            <ParallaxCard cardData={card} width="220px" height="290px" />
          </button>
        {/each}
      </div>
      
      {#if project.readMoreLinkText}
        <button class="read-more-btn" on:click={() => goto(`/projects/${project.slug}`)} bind:this={readMoreBtn}>
            {project.readMoreLinkText}
        </button>
      {/if}
    </div>
  </div>
</div>

<style>
    .project-section-wrapper { 
        width: 100%; 
        height: 100%; 
        color: rgb(245 245 247); 
        z-index: 2; 
        background-color: transparent; 
        display: flex; 
        flex-direction: column; 
        justify-content: center; 
        align-items: center; 
    }
    .background-image-container { 
        position: absolute; 
        top: 0; 
        left: 0; 
        width: 100%; 
        height: 100%; 
        background-size: cover; 
        background-position: center; 
        z-index: -1; 
        transform: scale(1); 
    }
    .content-overlay { 
        background-color: rgba(9 9 11 / 0.85); 
        backdrop-filter: blur(8px); 
        padding: 2rem 3rem; 
        border-radius: 16px; 
        width: 90%; 
        max-width: 1100px; 
        z-index: 1; 
        position: relative; 
        border: 1px solid rgba(255 255 255 / 0.1); 
    }
    .project-content { 
        text-align: center; 
    }
    h2 { 
        opacity: 0; 
        visibility: hidden;
        font-size: 2.5rem; 
        font-weight: 300; 
        margin-bottom: 1rem; 
        letter-spacing: -0.02em; 
    }
    p.project-summary { 
        opacity: 0; 
        visibility: hidden;
        font-size: 1.15rem; 
        color: rgb(212 212 216); 
        line-height: 1.7; 
        margin-bottom: 2rem; 
        max-width: 800px; 
        margin-left: auto; 
        margin-right: auto; 
    }
    .project-cards-container { 
        display: flex; 
        justify-content: center; 
        gap: 1rem; 
        margin-top: 1rem; 
        margin-bottom: 2rem; 
        flex-wrap: wrap; 
    }
    .card-click-wrapper { 
        background: none; 
        border: none; 
        padding: 0; 
        cursor: pointer; 
        border-radius: 10px; 
        transition: transform 0.3s ease, box-shadow 0.3s ease; 
    }
    .card-click-wrapper:hover { 
        transform: translateY(-5px); 
        box-shadow: 0 10px 30px rgba(0,0,0,0.2); 
    }
    .card-click-wrapper:focus-visible { 
        outline: 2px solid rgb(99 102 241); 
        outline-offset: 4px; 
    }
    button.read-more-btn { 
        opacity: 0; 
        visibility: hidden;
        padding: 0.875rem 2rem; 
        background-color: rgb(99 102 241); 
        color: white; 
        border: none; 
        border-radius: 8px; 
        cursor: pointer; 
        font-size: 1rem; 
        font-weight: 500; 
        transition: all 0.3s ease; 
        margin-top: 1rem; 
    }
    button.read-more-btn:hover { 
        background-color: rgb(79 70 229); 
        transform: translateY(-2px); 
        box-shadow: 0 4px 20px rgba(99 102 241 / 0.4); 
    }
</style>
--- END OF FILE src\lib\components\sections\ProjectTwoSection.svelte ---

--- START OF FILE src\lib\data\projectsData.ts ---
// src/lib/data/projectsData.ts

export interface ProjectCard {
  id: string; // Unique ID for this card, e.g., 'data-exploration'
  title: string;
  image: string; // Path to card image, e.g., '/images/projects/project-one/card1.jpg'
  description?: string; // Short description for the card
  effect?: string; // Identifier for the card's hover/interaction effect
  aspectLink?: string; // Anchor link for the subpage section, e.g., '#data-exploration-section'
}

// --- MODIFICATION START ---
// Add a background property to the sub-page section interface
export interface ProjectSubPageSection {
    id: string; // Corresponds to aspectLink from a card, used for scrolling
    title: string;
    content: string; // Can be HTML or Markdown, we'll decide how to render it
    background: {
      type: 'image' | 'video' | 'color';
      value: string;
    };
}
// --- MODIFICATION END ---

export interface Project {
  id: string; // Unique ID for the project, e.g., 'project-alpha'
  slug: string; // URL-friendly slug for the project subpage, e.g., 'customer-churn-prediction'
  headline: string;
  headlineAnimation?: { // Optional: override default headline animation
    type?: string;
    duration?: number;
    delay?: number;
    stagger?: number;
    ease?: string;
  };
  summary: string; // A few sentences introducing the project
  background: {
    type: 'image' | 'video' | 'color'; // Type of background
    value: string; // Path to image/video or color code
  };
  tags?: string[]; // e.g., ['Machine Learning', 'Python', 'TensorFlow']
  cards: ProjectCard[];
  subPageSections: ProjectSubPageSection[]; // Content for the project detail page
  readMoreLinkText?: string;
}

export const projects: Project[] = [
  // Project 1 (Placeholder)
  {
    id: 'project-one',
    slug: 'ai-churn-prediction',
    headline: 'AI-Powered Customer Churn Prediction',
    summary: 'Leveraging machine learning to proactively identify and mitigate customer churn, improving retention rates.',
    background: {
      type: 'image',
      value: '/images/projects/project-one/background.jpg',
    },
    tags: ['Machine Learning', 'Python', 'Scikit-learn', 'Data Analysis'],
    cards: [
      {
        id: 'p1-data-exploration',
        title: 'Data Exploration',
        image: '/images/projects/project-one/card-data.jpg',
        description: 'Deep dive into dataset characteristics.',
        aspectLink: '#data-exploration' // This #hash is important
      },
      {
        id: 'p1-model-building',
        title: 'Model Building',
        image: '/images/projects/project-one/card-printing.webp',
        description: 'Developing predictive models.',
        aspectLink: '#model-building'
      },
      {
        id: 'p1-results',
        title: 'Results & Impact',
        image: '/images/projects/project-one/card-meWorking.webp',
        description: 'Analyzing model performance and business impact.',
        aspectLink: '#results'
      }
    ],
    // --- MODIFICATION START: Add background data to each sub-section ---
    subPageSections: [
        {
            id: 'data-exploration',
            title: 'In-Depth: Data Exploration',
            content: 'Detailed walkthrough of the data sources, features, and initial findings... This section describes the extensive process of cleaning, analyzing, and visualizing the raw customer data to identify patterns and potential predictors of churn.',
            background: { type: 'image', value: '/images/projects/project-one/card-data.jpg' } // Using card images for now
        },
        {
            id: 'model-building',
            title: 'Model Building Strategy',
            content: 'Explanation of the algorithms chosen, feature engineering, and training process... We tested several models, including Logistic Regression, Random Forest, and Gradient Boosting, using cross-validation to ensure robustness.',
            background: { type: 'image', value: '/images/projects/project-one/card-printing.webp' }
        },
        {
            id: 'results',
            title: 'Achieved Results and Business Value',
            content: 'Presentation of model accuracy, key metrics, and the tangible benefits realized... The final model achieved an accuracy of 88% and an F1-score of 0.75, enabling targeted retention campaigns that reduced churn by 15%.',
            background: { type: 'image', value: '/images/projects/project-one/card-meWorking.webp' }
        }
    ],
    // --- MODIFICATION END ---
    readMoreLinkText: "Explore Churn Prediction Project"
  },
  // Project 2 (Placeholder)
  {
    id: 'project-two',
    slug: 'interactive-data-visualization',
    // ... (same structure, remember to add backgrounds to its subPageSections as well)
    headline: 'Interactive Dashboard for Sales Analytics',
    summary: 'Developing a dynamic dashboard to visualize sales trends and provide actionable insights for stakeholders.',
    background: {
      type: 'image',
      value: '/images/projects/project-two/background.jpg',
    },
    tags: ['Data Visualization', 'Tableau (or similar)', 'JavaScript', 'SQL'],
    cards: [
      {
        id: 'p2-data-sourcing',
        title: 'Data Sourcing & ETL',
        image: '/images/projects/project-one/card-data.jpg',
        description: 'Gathering and preparing data.',
        aspectLink: '#data-sourcing'
      },
      {
        id: 'p2-dashboard-design',
        title: 'Dashboard Design (UX/UI)',
        image: '/images/projects/project-one/card-data.jpg',
        description: 'User-centric design.',
        aspectLink: '#dashboard-design'
      },
      {
        id: 'p2-key-insights',
        title: 'Key Insights & Features',
        image: '/images/projects/project-one/card-data.jpg',
        description: 'Impactful visualizations.',
        aspectLink: '#key-insights'
      }
    ],
    subPageSections: [
        {
            id: 'data-sourcing',
            title: 'Data Pipeline and ETL Processes',
            content: 'Overview of how data was collected, cleaned, and transformed...',
            background: { type: 'image', value: '/images/projects/project-two/card-data.jpg' }
        },
        {
            id: 'dashboard-design',
            title: 'Designing for User Experience',
            content: 'The thought process behind the dashboard layout and interactivity...',
            background: { type: 'image', value: '/images/projects/project-two/card-design.jpg' }
        },
        {
            id: 'key-insights',
            title: 'Unlocking Actionable Insights',
            content: 'Examples of how the dashboard helps users discover trends...',
            background: { type: 'image', value: '/images/projects/project-two/card-insights.jpg' }
        }
    ],
    readMoreLinkText: "Discover Interactive Sales Dashboard"
  }
];
--- END OF FILE src\lib\data\projectsData.ts ---

--- START OF FILE src\lib\data\siteConfig.ts ---
// src/lib/data/siteConfig.ts

export interface ParticleEffectConfig {
  type: string; // e.g., 'default', 'starryNight', etc.
  //options?: any; // This will hold the actual tsParticles JSON config
}

export interface SocialLink {
  name: string; // e.g., 'LinkedIn', 'GitHub', 'Email'
  url: string;
  icon?: string; // Optional: path to an icon or an icon library class name
}

export const siteConfig = {
  title: "Your Name - Data Scientist Portfolio",
  author: "Your Name",
  description: "A portfolio showcasing data science projects and expertise.",

  heroSection: {
    greeting: "Hello, I'm",
    name: "Your Name", // Or however you want to display it
    introduction: "A Data Scientist passionate about uncovering insights and building intelligent solutions.",
    particleEffect: {
      type: 'defaultGreetingParticles', // We'll define this later
    } as ParticleEffectConfig,
  },

  aboutSection: {
    title: "About Me", // MODIFIED
    introduction: "This is where you'll learn about who I am and what I do.", // MODIFIED
    imageUrl: "/images/profile.png", // MODIFIED - ensure this image exists in static/images
    imageParticleEffect: {
      type: 'imageAuraParticles', // We'll define this later
    } as ParticleEffectConfig,
    socialLinks: [ // Existing links, will be used by KeyboardButtons
      { name: "GitHub", url: "https://github.com/yourusername" }, // Replace with your actual URL
      { name: "LinkedIn", url: "https://www.linkedin.com/in/yourprofile/" }, // Replace with your actual URL
      { name: "Email", url: "mailto:youremail@example.com" }, // Replace with your actual email
    ] as SocialLink[],
  },

  contactSection: {
    title: "Get in Touch",
    outroMessage: "I'm always excited to discuss new projects, collaborations, or opportunities. Feel free to reach out!",
    email: "youremail@example.com", // Replace with your actual email
    additionalLinks: [
        { name: "View My Resume", url: "/resume.pdf" } // Place resume in `static` folder
    ]
  },

  defaultHeadlineAnimation: {
    type: 'fadeInUp',
    duration: 0.8,
    delay: 0.2,
    stagger: 0.1,
  },
};
--- END OF FILE src\lib\data\siteConfig.ts ---

--- START OF FILE src\lib\stores\preloadingStore.ts ---
// src/lib/stores/preloadingStore.ts
import { writable, derived, get } from 'svelte/store';

export type TaskStatus = 'idle' | 'pending' | 'loading' | 'loaded' | 'error';
export type AssetStatus = 'idle' | 'loading' | 'loaded' | 'error';

export interface PreloadTask {
  id: string;
  status: TaskStatus;
  progress?: number;
  message?: string;
  priority?: number;
}

// --- NEW: A dedicated store to track the status of individual asset URLs ---
// This prevents redundant loading across the entire application.
// e.g., { '/images/profile.png': 'loaded', '/fonts/font.json': 'loading' }
const assetLoadingStatus = writable<Record<string, AssetStatus>>({});

// Configuration
export const minimumLoadingDuration = 1780; // Minimum time to show loading screen (ms)

const tasks = writable<Record<string, PreloadTask>>({});

/**
 * Tracks whether the initial, full-site loading sequence has completed.
 * Once true, the main loading screen should not reappear.
 */
export const initialSiteLoadComplete = writable<boolean>(false);

/**
 * Overall loading progress from 0 to 1
 */
export const loadingProgress = derived(tasks, $tasks => {
  const allTasksArray = Object.values($tasks);
  if (allTasksArray.length === 0) return 0;
  
  let totalWeight = 0;
  let weightedProgress = 0;
  
  allTasksArray.forEach(task => {
    const weight = task.priority || 1;
    totalWeight += weight;
    
    let taskProgress = 0;
    switch (task.status) {
      case 'loaded': taskProgress = 1; break;
      case 'error': taskProgress = 1; break;
      case 'loading': taskProgress = task.progress || 0.5; break;
      default: taskProgress = 0; break;
    }
    
    weightedProgress += taskProgress * weight;
  });
  
  return totalWeight > 0 ? weightedProgress / totalWeight : 0;
});

export const preloadingStore = {
  subscribe: tasks.subscribe,
  
  registerTask: (taskId: string, initialStatus: TaskStatus = 'pending', priority: number = 1) => {
    tasks.update(currentTasks => {
      if (!currentTasks[taskId] || currentTasks[taskId].status === 'idle' || currentTasks[taskId].status === 'error') {
        currentTasks[taskId] = { 
          id: taskId, 
          status: initialStatus,
          priority,
          progress: initialStatus === 'loading' ? 0.5 : undefined
        };
      } else {
        currentTasks[taskId].priority = priority;
      }
      return currentTasks;
    });
  },
  
  updateTaskStatus: (taskId: string, status: TaskStatus, message?: string) => {
    tasks.update(currentTasks => {
      if (currentTasks[taskId]) {
        if (currentTasks[taskId].status !== 'loaded' || status !== 'loading') {
          currentTasks[taskId].status = status;
          if (message) currentTasks[taskId].message = message;
          if (status === 'loaded' || status === 'error') {
            currentTasks[taskId].progress = 1;
          }
        }
      } else {
        currentTasks[taskId] = { 
          id: taskId, 
          status: status, 
          message: message,
          progress: status === 'loaded' ? 1 : 0
        };
      }
      return currentTasks;
    });
  },
  
  updateTaskProgress: (taskId: string, progress: number) => {
    tasks.update(currentTasks => {
      if (currentTasks[taskId]) {
        currentTasks[taskId].progress = Math.max(0, Math.min(1, progress));
      }
      return currentTasks;
    });
  },
  
  getTaskStatus: (taskId: string): TaskStatus | undefined => {
    const currentTasks = get(tasks);
    return currentTasks[taskId]?.status;
  },
  
  resetTasks: () => {
    tasks.set({});
    initialSiteLoadComplete.set(false);
    assetLoadingStatus.set({}); // Reset the asset status map as well
  },

  // --- NEW: Asset Status Management ---
  getAssetStatus: (url: string): AssetStatus => {
    return get(assetLoadingStatus)[url] || 'idle';
  },

  setAssetStatus: (url: string, status: AssetStatus) => {
    assetLoadingStatus.update(current => {
      current[url] = status;
      return current;
    });
  }
};

export const overallLoadingState = derived(tasks, $tasks => {
  const allTasksArray = Object.values($tasks);

  if (allTasksArray.length === 0) return 'idle';
  if (allTasksArray.some(task => task.status === 'error')) return 'error';
  if (allTasksArray.every(task => task.status === 'loaded')) return 'loaded';
  if (allTasksArray.some(task => task.status === 'loading' || task.status === 'pending')) return 'loading';
  return 'idle';
});

export const startLoadingTask = (taskId: string, priority: number = 1) => {
  preloadingStore.registerTask(taskId, 'loading', priority);
};

// --- NEW: A Generic Asset Preloader Function ---
/**
 * A robust, generic function to preload an array of assets (images, fonts, etc.).
 * It updates the central asset status store to prevent re-downloads.
 * @param urls An array of asset URLs to load.
 * @returns A promise that resolves when all assets are loaded, or rejects on the first error.
 */
export async function preloadAssets(urls: string[]): Promise<void> {
  const promises: Promise<unknown>[] = [];

  for (const url of urls) {
    const status = preloadingStore.getAssetStatus(url);
    if (status === 'loaded' || status === 'loading') {
      continue; // Skip already loaded or currently loading assets
    }
    
    preloadingStore.setAssetStatus(url, 'loading');

    const promise = new Promise((resolve, reject) => {
      // Basic image preloader
      if (/\.(jpg|jpeg|png|webp|gif|svg)$/i.test(url)) {
        const img = new Image();
        img.src = url;
        img.onload = () => {
          preloadingStore.setAssetStatus(url, 'loaded');
          resolve(url);
        };
        img.onerror = () => {
          preloadingStore.setAssetStatus(url, 'error');
          reject(new Error(`Failed to load image: ${url}`));
        };
      } 
      // Basic font preloader (for .json from FontLoader)
      else if (/\.json$/i.test(url)) {
        fetch(url)
          .then(response => {
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            return response.json();
          })
          .then(() => {
            preloadingStore.setAssetStatus(url, 'loaded');
            resolve(url);
          })
          .catch(error => {
            preloadingStore.setAssetStatus(url, 'error');
            reject(new Error(`Failed to load font data: ${url} - ${error.message}`));
          });
      }
      // Add other file types (videos, etc.) here if needed
      else {
        console.warn(`Preloading not implemented for file type: ${url}`);
        resolve(url); // Resolve unsupported types immediately
      }
    });
    promises.push(promise);
  }

  await Promise.all(promises);
}
--- END OF FILE src\lib\stores\preloadingStore.ts ---

--- START OF FILE src\lib\three\BloomEffect.ts ---
// src/lib/three/BloomEffect.ts
import * as THREE from 'three';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';
import { OutputPass } from 'three/examples/jsm/postprocessing/OutputPass.js';

export class BloomEffect {
    private renderer: THREE.WebGLRenderer;
    private scene: THREE.Scene;
    // MODIFIED: Camera type is now more generic to support Orthographic camera
    private camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;
    
    public composer: EffectComposer;
    private renderPass: RenderPass;
    private bloomPass: UnrealBloomPass;
    private outputPass: OutputPass;

    // Bloom Parameters (shared default configuration)
    private bloomParams = {
        threshold: 0.4,
        strength: 0.15,
        radius: 0.1,
    };

    constructor(
        renderer: THREE.WebGLRenderer, 
        scene: THREE.Scene, 
        camera: THREE.PerspectiveCamera | THREE.OrthographicCamera,
        width: number, 
        height: number
    ) {
        this.renderer = renderer;
        this.scene = scene;
        this.camera = camera;

        this.composer = new EffectComposer(this.renderer);
        this.composer.setSize(width, height);
        this.composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        // 1. Render the original scene
        this.renderPass = new RenderPass(this.scene, this.camera);
        this.composer.addPass(this.renderPass);

        // 2. Apply bloom
        this.bloomPass = new UnrealBloomPass(
            new THREE.Vector2(width, height),
            this.bloomParams.strength,
            this.bloomParams.radius,
            this.bloomParams.threshold
        );
        this.composer.addPass(this.bloomPass);
        
        // 3. Output the result (handles tone mapping and color space conversion)
        this.outputPass = new OutputPass();
        this.composer.addPass(this.outputPass);
    }

    public render(deltaTime: number): void {
        this.composer.render(deltaTime);
    }

    public setSize(width: number, height: number): void {
        this.composer.setSize(width, height);
        this.composer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    }

    public updateParameters(params: { threshold?: number; strength?: number; radius?: number }): void {
        if (params.threshold !== undefined) this.bloomPass.threshold = params.threshold;
        if (params.strength !== undefined) this.bloomPass.strength = params.strength;
        if (params.radius !== undefined) this.bloomPass.radius = params.radius;
    }

    public dispose(): void {
        // EffectComposer automatically disposes its passes' render targets
        // if they were created internally by the composer or pass.
    }
}
--- END OF FILE src\lib\three\BloomEffect.ts ---

--- START OF FILE src\lib\three\heroParticleLogic.ts ---
// src/lib/three/heroParticleLogic.ts
import * as THREE from 'three';
import type { Font } from 'three/examples/jsm/loaders/FontLoader.js';
import { BloomEffect } from './BloomEffect';

// Shaders (VERTEX_SHADER and FRAGMENT_SHADER remain the same)
export const VERTEX_SHADER = `
attribute float size;
attribute vec3 customColor;
attribute float symbolState;
attribute float symbolIndex;
attribute float variability;

varying vec3 vColor;
varying float vSymbolState;
varying float vSymbolIndex;
varying float vVariability;

void main() {
  vColor = customColor;
  vSymbolState = symbolState;
  vSymbolIndex = symbolIndex;
  vVariability = variability;
  
  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
  gl_PointSize = size * (300.0 / -mvPosition.z);
  gl_Position = projectionMatrix * mvPosition;
}
`;

export const FRAGMENT_SHADER = `
uniform sampler2D pointTexture;
uniform sampler2D symbolsTexture;
uniform float symbolRows;

varying vec3 vColor;
varying float vSymbolState;
varying float vSymbolIndex;
varying float vVariability;

void main() {
  if(vSymbolState < 0.5) { // It's a normal particle (dot)
    gl_FragColor = vec4(vColor, 1.0) * texture2D(pointTexture, gl_PointCoord);
  } 
  else { // It's a symbol
    const float symbolsPerRow = 8.0;
    float symbolIndexVal = vSymbolIndex;
    
    float columnIndex = mod(symbolIndexVal, symbolsPerRow);
    float rowIndex = floor(symbolIndexVal / symbolsPerRow);
    
    vec2 symbolCoord = gl_PointCoord;
    symbolCoord.x = (symbolCoord.x + columnIndex) / symbolsPerRow;
    symbolCoord.y = (symbolCoord.y + rowIndex) / symbolRows; // Use dynamic row count
    
    vec4 symbolTexColor = texture2D(symbolsTexture, symbolCoord);
    
    if(symbolTexColor.a < 0.3) discard; // Discard transparent parts of the symbol
    
    gl_FragColor = vec4(vColor, symbolTexColor.a); 
  }
}
`;

export class Environment {
  public font: Font;
  public particleTexture: THREE.Texture;
  public container: HTMLElement;
  public scene!: THREE.Scene;
  public camera!: THREE.PerspectiveCamera;
  public renderer!: THREE.WebGLRenderer;
  public createParticles!: CreateParticles;
  private animationLoopCallback: (() => void) | null = null;

  private clock!: THREE.Clock; 
  private bloomEffect!: BloomEffect;

  constructor(font: Font, particleTexture: THREE.Texture, container: HTMLElement) {
    this.font = font;
    this.particleTexture = particleTexture;
    this.container = container;
    
    if (!this.container) {
      console.error("HeroParticleLogic: Container not provided to Environment!");
      return;
    }
    
    this.clock = new THREE.Clock(); 

    this.scene = new THREE.Scene();
    this.createCamera();
    this.createRenderer();
    
    this.bloomEffect = new BloomEffect(
        this.renderer, 
        this.scene, 
        this.camera, 
        this.container.clientWidth, 
        this.container.clientHeight
    );

    this.setup(); 
    this.bindWindowResize();

    if (this.renderer) {
        this.startAnimationLoop();
    }
  }

  public startAnimationLoop() {
    if (this.renderer && !this.animationLoopCallback) {
        this.animationLoopCallback = () => { this.render(); };
        this.renderer.setAnimationLoop(this.animationLoopCallback);
        console.log("HeroParticleLogic: Animation loop started.");
    }
  }

  public stopAnimationLoop() {
    if (this.renderer && this.animationLoopCallback) {
        this.renderer.setAnimationLoop(null);
        this.animationLoopCallback = null;
        console.log("HeroParticleLogic: Animation loop stopped.");
    }
  }

  public isLooping(): boolean {
    return !!this.animationLoopCallback;
  }

  private bindWindowResize() {
    window.addEventListener('resize', this.onWindowResize.bind(this));
  }

  private unbindWindowResize() {
    window.removeEventListener('resize', this.onWindowResize.bind(this));
  }

  private setup() {
    this.createParticles = new CreateParticles(
      this.scene, 
      this.font, 
      this.particleTexture, 
      this.camera, 
      this.renderer, 
      this.container 
    );
  }

  public render() {
    const deltaTime = this.clock.getDelta();

    if (this.createParticles) {
      this.createParticles.render(); 
    }
    
    if (this.bloomEffect) {
      this.bloomEffect.render(deltaTime);
    } else if (this.renderer && this.scene && this.camera) { 
      this.renderer.render(this.scene, this.camera);
    }
  }

  private createCamera() {
    this.camera = new THREE.PerspectiveCamera(
      65, 
      this.container.clientWidth / this.container.clientHeight, 
      1, 
      10000
    );
    this.camera.position.set(0, 0, 100);
  }

  private createRenderer() {
    this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true 
    });
    this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    
    if (THREE.ColorManagement.enabled) { 
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
    } else { 
        this.renderer.outputColorSpace = THREE.SRGBColorSpace;
    }
    
    this.container.appendChild(this.renderer.domElement);
  }
  public onWindowResize() {
    if (this.camera && this.renderer && this.container) {
      const newWidth = this.container.clientWidth;
      const newHeight = this.container.clientHeight;

      this.camera.aspect = newWidth / newHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(newWidth, newHeight);
      
      if (this.bloomEffect) {
        this.bloomEffect.setSize(newWidth, newHeight);
      }
      
      // Check for screen size changes and regenerate particles if needed
      if (this.createParticles) {
        if (this.createParticles.checkScreenSizeChange()) {
          this.createParticles.regenerateParticles();
        }
      }
    }
  }

  public dispose() {
    console.log("HeroParticleLogic: Disposing Environment");
    this.stopAnimationLoop();
    this.unbindWindowResize();
    if (this.createParticles) {
      this.createParticles.dispose();
    }
    if (this.bloomEffect) {
        this.bloomEffect.dispose();
    }
    if (this.renderer) {
      this.renderer.dispose();
      if (this.renderer.domElement && this.renderer.domElement.parentNode) {
        this.renderer.domElement.parentNode.removeChild(this.renderer.domElement);
      }
    }
    if (this.scene) {
        this.scene.traverse(object => {
            const obj = object as THREE.Mesh; 
            if (obj.geometry) obj.geometry.dispose();
            if (obj.material) {
                if (Array.isArray(obj.material)) {
                    obj.material.forEach((material: THREE.Material) => material.dispose());
                } else {
                    (obj.material as THREE.Material).dispose();
                }
            }
        });
    }
  }
}

interface ParticleData {
  text: string;
  amount: number;
  particleSize: number;
  textSize: number;
  area: number;
  ease: number;
  distortionThreshold: number;
  // maxCooldownTime: number; // REMOVED - Replaced by min/max duration
  minFadeOutRate: number;
  maxFadeOutRate: number;
  minSymbolSize: number;
  maxSymbolSize: number;
  symbolMinThreshold: number;
  symbolMidThreshold: number;
  symbolMaxThreshold: number;
  symbolMinProb: number;
  symbolMaxProb: number;
  symbolHeatRequirement: number;
  // --- NEW Cooldown Parameters ---
  particleCooldownDurationMin: number;
  particleCooldownDurationMax: number;
  symbolCooldownSpeedMultiplier: number;  // --- END NEW Cooldown Parameters ---
}

// Screen size categories for responsive design
type ScreenSizeType = 'mobile' | 'tablet' | 'laptop' | 'desktop' | 'large' | 'ultrawide';

export class CreateParticles {
  private scene: THREE.Scene;
  private font: Font;
  private particleImg: THREE.Texture;
  private camera: THREE.PerspectiveCamera;
  private renderer: THREE.WebGLRenderer; 
  private hostContainer: HTMLElement; 

  private raycaster: THREE.Raycaster;
  private mouse: THREE.Vector2;
  private isPressed: boolean = false;
  private hasMouseMoved: boolean = false; 

  private matrixSymbols: string[];
  private matrixColors: { [key: string]: THREE.Color };
  private bloomSymbolColor: THREE.Color; 
  
  private particleStates: number[] = [];
  private heatLevels: number[] = [];
  private cooldownRates: number[] = [];
  private symbolIndicesAttributeValues: number[] = [];
  private fadeOutRates: number[] = [];

  private data: ParticleData;
  private symbolsTexture!: THREE.Texture;
  private planeArea!: THREE.Mesh; 
  public particles!: THREE.Points;
  private geometryCopy!: THREE.BufferGeometry;

  private boundOnMouseDown: (event: MouseEvent) => void;
  private boundOnMouseMove: (event: MouseEvent) => void;
  private boundOnMouseUp: (event: MouseEvent) => void;
  private boundOnTouchStart: (event: TouchEvent) => void;
  private boundOnTouchMove: (event: TouchEvent) => void;
  private boundOnTouchEnd: (event: TouchEvent) => void;

  // Responsive design related properties
  private currentScreenSizeType: ScreenSizeType = 'desktop';
  private lastKnownWidth: number = 0;
  private lastKnownHeight: number = 0;
  private needsParticleRegeneration: boolean = false;

  // These constants control the symbol color variation
  private readonly SYMBOL_HUE_SHIFT_RANGE = 0.03;           // Controls hue variation (green tint shifts)
  private readonly SYMBOL_LUMINANCE_REDUCTION_MAX = 0.08;  // Controls brightness variation
  private readonly SYMBOL_MIN_LUMINANCE_TARGET = 0.45;      // Minimum brightness to prevent too-dark symbols

  // Screen size breakpoints
  private readonly SCREEN_SIZES = {
    mobile: { maxWidth: 640 },
    tablet: { minWidth: 641, maxWidth: 1024 },
    laptop: { minWidth: 1025, maxWidth: 1440 },
    desktop: { minWidth: 1441, maxWidth: 1920 },
    large: { minWidth: 1921, maxWidth: 2560 },
    ultrawide: { minWidth: 2561 }
  };

  // Responsive particle parameters for different screen sizes
  private readonly RESPONSIVE_PARAMS: Record<ScreenSizeType, Partial<ParticleData>> = {
    mobile: {
      amount: 1200,
      particleSize: 1.0,
      textSize: 12,
      minSymbolSize: 7,
      maxSymbolSize: 11,
      area: 150
    },
    tablet: {
      amount: 1800,
      particleSize: 1.1,
      textSize: 14,
      minSymbolSize: 7,
      maxSymbolSize: 11,
      area: 200
    },
    laptop: {
      amount: 2200,
      particleSize: 1.2,
      textSize: 15,
      minSymbolSize: 6.5,
      maxSymbolSize: 11,
      area: 230
    },
    desktop: {
      amount: 2400,
      particleSize: 1.4,
      textSize: 16,
      minSymbolSize: 7,
      maxSymbolSize: 11,
      area: 250
    },
    large: {
      amount: 2700,
      particleSize: 1.55,
      textSize: 18,
      minSymbolSize: 8,
      maxSymbolSize: 11,
      area: 280
    },
    ultrawide: {
      amount: 2900,
      particleSize: 1.6,
      textSize: 20,
      minSymbolSize: 9,
      maxSymbolSize: 16,
      area: 300
    }
  };

  private symbolTextureRows: number = 6; // Add this property declaration

  constructor(scene: THREE.Scene, font: Font, particleImg: THREE.Texture, camera: THREE.PerspectiveCamera, renderer: THREE.WebGLRenderer, hostContainer: HTMLElement) {
    this.scene = scene;
    this.font = font;
    this.particleImg = particleImg;
    this.camera = camera;
    this.renderer = renderer; 
    this.hostContainer = hostContainer;
    this.isPressed = false;

    this.raycaster = new THREE.Raycaster();
    this.mouse = new THREE.Vector2(1e5, 1e5);

    this.matrixSymbols = [ 
      '日', '〇', 'ﾊ', 'ﾐ', 'ﾋ', 'ｰ', 'ｳ', 'ｼ', 'ﾅ', 'ﾓ', 'ﾆ', 'ｻ', 'ﾜ',
      'ﾂ', 'ｵ', 'ﾘ', 'ｱ', 'ﾎ', 'ﾃ', 'ﾏ', 'ｹ', 'ﾒ', 'ｴ', 'ｶ', 'ｷ', 'ﾑ', 
      'ﾕ', 'ﾗ', 'ｾ', 'ﾈ', 'ｦ', 'ｲ', 'ｸ', 'ｺ', 'ｿ', 'ﾀ', 'ﾁ', 'ﾄ', 'ﾉ', 'ﾌ', 'ﾍ', 'ﾏ', 'ﾔ', 'ﾖ', 'ﾙ', 'ﾚ', 'ﾛ',
      '∆','δ', 'ε', 'ζ', 'η', 'θ', '∃', '∄','∅','ﾊ', 'ﾍ', 'ﾎ', 'ﾞ', 'ﾟ', 'ｧ', 'ｨ', 'ｩ', 'ｪ', 'ｫ', 'ｬ', 'ｭ', 'ｮ', 'ｯ','Д'
    ];
    
    this.matrixColors = {
      white: new THREE.Color(1.0, 1.0, 1.0),
      verySubtleGreenTint: new THREE.Color(0.9, 1.0, 0.9), 
      almostWhiteGreen: new THREE.Color(0.8, 1.0, 0.8),
      paleGreen: new THREE.Color(0.58, 1.0, 0.58),
      lightMatrixGreen: new THREE.Color(0.3, 1.0, 0.3),
      classicMatrixGreen: new THREE.Color(0.0, 1.0, 0.0),
      deepMatrixGreen: new THREE.Color(0.0, 0.85, 0.0)
    };

    this.bloomSymbolColor = new THREE.Color(0.0, 0.95, 0.05); 

    // Base configuration (will be adjusted for screen size)
    this.data = { 
      text: "Hi, I'm\nMiká",
      amount: 2700,
      particleSize: 1.5,
      textSize: 16,
      area: 250, 
      ease: .05, 
      distortionThreshold: 12,
      minFadeOutRate: 0.09,
      maxFadeOutRate: 0.12,
      minSymbolSize: 7,
      maxSymbolSize: 12,
      symbolMinThreshold: 13,
      symbolMidThreshold: 20,
      symbolMaxThreshold: 40,
      symbolMinProb: 0.001,
      symbolMaxProb: 0.15,
      symbolHeatRequirement: 0.4,
      particleCooldownDurationMin: 200, 
      particleCooldownDurationMax: 340,
      symbolCooldownSpeedMultiplier: 3.1,
    };
    
    // Track the container dimensions to detect significant changes
    this.lastKnownWidth = this.hostContainer.clientWidth;
    this.lastKnownHeight = this.hostContainer.clientHeight;
    
    // Determine initial screen size and apply responsive settings
    this.currentScreenSizeType = this.getScreenSizeType();
    this.applyResponsiveParameters(this.currentScreenSizeType);
    
    // Log the detected screen size and particle configuration
    console.log(`🖥️ Hero Particle Effect - Screen Size Detection:`);
    console.log(`   Screen dimensions: ${this.lastKnownWidth}x${this.lastKnownHeight}px`);
    console.log(`   Detected screen type: ${this.currentScreenSizeType.toUpperCase()}`);
    console.log(`   Particle configuration:`);
    console.log(`     • Particle count: ${this.data.amount}`);
    console.log(`     • Particle size: ${this.data.particleSize}`);
    console.log(`     • Text size: ${this.data.textSize}px`);
    console.log(`     • Symbol size range: ${this.data.minSymbolSize} - ${this.data.maxSymbolSize}`);
    console.log(`     • Effect area: ${this.data.area}`);
    
    this.boundOnMouseDown = this.onMouseDown.bind(this);
    this.boundOnMouseMove = this.onMouseMove.bind(this);
    this.boundOnMouseUp = this.onMouseUp.bind(this);
    this.boundOnTouchStart = this.onTouchStart.bind(this);
    this.boundOnTouchMove = this.onTouchMove.bind(this);
    this.boundOnTouchEnd = this.onTouchEnd.bind(this);
    
    this.createMatrixSymbolsTexture();
    this.setupPlaneArea();
    this.createText();
  }

  private getMatrixColor(heatLevel: number): THREE.Color {
    if (heatLevel <= 0.05) return this.matrixColors.white;                
    if (heatLevel <= 0.18) return this.matrixColors.verySubtleGreenTint; 
    if (heatLevel <= 0.35) return this.matrixColors.almostWhiteGreen;     
    if (heatLevel <= 0.55) return this.matrixColors.paleGreen;            
    if (heatLevel <= 0.75) return this.matrixColors.lightMatrixGreen;
    if (heatLevel <= 0.92) return this.matrixColors.classicMatrixGreen;   
    return this.matrixColors.deepMatrixGreen;                             
  }

  private getSymbolProbability(distortion: number): number {
    const { symbolMinThreshold, symbolMidThreshold, symbolMaxThreshold, symbolMinProb, symbolMaxProb } = this.data;
    if (distortion < symbolMinThreshold) return 0;
    if (distortion >= symbolMaxThreshold) return symbolMaxProb; 
    if (distortion < symbolMidThreshold) {
      const ratio = (distortion - symbolMinThreshold) / (symbolMidThreshold - symbolMinThreshold);
      return symbolMinProb + (symbolMaxProb / 10) * Math.pow(ratio, 3);
    } else {
      const ratio = (distortion - symbolMidThreshold) / (symbolMaxThreshold - symbolMidThreshold);
      return (symbolMaxProb / 10) + 
             (symbolMaxProb - symbolMaxProb / 10) * Math.pow(ratio, 1.5);
    }
  }

  private initParticleStates(count: number) { 
    this.particleStates = new Array(count).fill(0);
    this.heatLevels = new Array(count).fill(0);
    this.cooldownRates = new Array(count);
    this.symbolIndicesAttributeValues = new Array(count);
    this.fadeOutRates = new Array(count);
    // Remove symbolSizesMultipliers array since we generate sizes dynamically
    
    for (let i = 0; i < count; i++) {
      this.symbolIndicesAttributeValues[i] = Math.floor(Math.random() * this.matrixSymbols.length);
      
      // --- MODIFIED Cooldown Rate Calculation ---
      const randomDuration = this.data.particleCooldownDurationMin + 
                             Math.random() * (this.data.particleCooldownDurationMax - this.data.particleCooldownDurationMin);
      this.cooldownRates[i] = 1 / Math.max(1, randomDuration); // Rate is 1/duration. Ensure duration > 0.
      // --- END MODIFIED ---

      this.fadeOutRates[i] = this.data.minFadeOutRate + Math.random() * (this.data.maxFadeOutRate - this.data.minFadeOutRate);
      // Remove pre-calculation of symbol sizes
    }
  }

  private createMatrixSymbolsTexture() {
    // Calculate required rows based on symbol count
    const cols = 8;
    const symbolSize = 64;
    const rows = Math.ceil(this.matrixSymbols.length / cols);
    
    const canvas = document.createElement('canvas');
    canvas.width = cols * symbolSize; 
    canvas.height = rows * symbolSize;
    const ctx = canvas.getContext('2d')!;
    
    // Clear canvas with transparent background
    ctx.fillStyle = 'rgba(0,0,0,0)'; 
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Improved font rendering settings
    ctx.font = 'bold 48px "Courier New", monospace';
    ctx.textAlign = 'center'; 
    ctx.textBaseline = 'middle';
    ctx.fillStyle = '#00FF00';
    
    // Enable better text rendering (remove invalid textRenderingOptimization)
    if (ctx.imageSmoothingEnabled !== undefined) {
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
    }
    
    for (let i = 0; i < this.matrixSymbols.length; i++) {
      const col = i % cols; 
      const row = Math.floor(i / cols);
      const x = col * symbolSize + symbolSize / 2; 
      const y = row * symbolSize + symbolSize / 2;
      
      // Add slight padding to prevent edge clipping
      const symbol = this.matrixSymbols[i];
      ctx.fillText(symbol, x, y);
    }
    
    this.symbolsTexture = new THREE.Texture(canvas);
    this.symbolsTexture.needsUpdate = true;
    this.symbolsTexture.generateMipmaps = false;
    this.symbolsTexture.minFilter = THREE.LinearFilter;
    this.symbolsTexture.magFilter = THREE.LinearFilter;
    this.symbolsTexture.wrapS = THREE.ClampToEdgeWrapping;
    this.symbolsTexture.wrapT = THREE.ClampToEdgeWrapping;
    
    // Store the row count for the shader
    this.symbolTextureRows = rows;
    
    // Log texture info for debugging
    console.log(`Symbol texture created: ${cols}x${rows} grid (${this.matrixSymbols.length} symbols)`);
  }

  private setupPlaneArea() {
    const planeZ = 0;
    const planeWidth = this.visibleWidthAtZDepth(planeZ, this.camera);
    const planeHeight = this.visibleHeightAtZDepth(planeZ, this.camera);

    const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
    const material = new THREE.MeshBasicMaterial({ 
        transparent: true, 
        opacity: 0, 
        depthWrite: false 
    });
    this.planeArea = new THREE.Mesh(geometry, material);
    this.planeArea.position.z = planeZ;
    this.planeArea.visible = true;
    this.scene.add(this.planeArea);
  }

  private createText() {
    const thePoints: THREE.Vector3[] = [];
    const colorsArr: number[] = []; 
    const sizesArr: number[] = []; 
    const symbolStatesArr: number[] = []; 
    const symbolIndicesArrForAttribute: number[] = []; 
    const variabilitiesArr: number[] = [];

    if (!this.font) { console.error("HeroParticleLogic: Font not available for createText"); return; }

    const mainShapes = this.font.generateShapes(this.data.text, this.data.textSize);
    const allPaths: THREE.Path[] = [];
    mainShapes.forEach(shape => {
        allPaths.push(shape); 
        if (shape.holes && shape.holes.length > 0) {
            allPaths.push(...shape.holes); 
        }
    });
    
    const tempShapeGeometry = new THREE.ShapeGeometry(mainShapes); 
    tempShapeGeometry.computeBoundingBox();
    const xMid = -0.5 * (tempShapeGeometry.boundingBox!.max.x - tempShapeGeometry.boundingBox!.min.x);
    const yMid = (tempShapeGeometry.boundingBox!.max.y - tempShapeGeometry.boundingBox!.min.y) / 2.85; 
    tempShapeGeometry.dispose();

    let totalLength = 0;
    allPaths.forEach(path => totalLength += path.getLength());
    if (totalLength === 0) totalLength = 1; 

    const initialColor = this.matrixColors.white; 

    allPaths.forEach(path => {
      const pathLength = path.getLength();
      const numPointsForThisPath = Math.max(10, Math.floor((pathLength / totalLength) * this.data.amount));
      const points = path.getSpacedPoints(numPointsForThisPath);
      
      points.forEach(p => {
        thePoints.push(new THREE.Vector3(p.x, p.y, 0));
        colorsArr.push(initialColor.r, initialColor.g, initialColor.b); 
        sizesArr.push(this.data.particleSize);
        symbolStatesArr.push(0); 
        symbolIndicesArrForAttribute.push(Math.floor(Math.random() * this.matrixSymbols.length));
        variabilitiesArr.push(Math.random());
      });
    });
    
    const finalPointCount = thePoints.length;
    if (colorsArr.length / 3 !== finalPointCount) { colorsArr.length = finalPointCount * 3; for(let i=0; i<finalPointCount; ++i) colorsArr.splice(i*3, 3, initialColor.r, initialColor.g, initialColor.b); }
    if (sizesArr.length !== finalPointCount) { sizesArr.length = finalPointCount; sizesArr.fill(this.data.particleSize); }
    if (symbolStatesArr.length !== finalPointCount) { symbolStatesArr.length = finalPointCount; symbolStatesArr.fill(0); }
    if (symbolIndicesArrForAttribute.length !== finalPointCount) { symbolIndicesArrForAttribute.length = finalPointCount; for(let i=0; i<finalPointCount; ++i) symbolIndicesArrForAttribute[i] = Math.floor(Math.random() * this.matrixSymbols.length); }
    if (variabilitiesArr.length !== finalPointCount) { variabilitiesArr.length = finalPointCount; for(let i=0; i<finalPointCount; ++i) variabilitiesArr[i] = Math.random(); }


    const geoParticles = new THREE.BufferGeometry().setFromPoints(thePoints);
    geoParticles.translate(xMid, yMid, 0); 
    geoParticles.setAttribute('customColor', new THREE.Float32BufferAttribute(colorsArr, 3));
    geoParticles.setAttribute('size', new THREE.Float32BufferAttribute(sizesArr, 1));
    geoParticles.setAttribute('symbolState', new THREE.Float32BufferAttribute(symbolStatesArr, 1));
    geoParticles.setAttribute('symbolIndex', new THREE.Float32BufferAttribute(symbolIndicesArrForAttribute, 1));
    geoParticles.setAttribute('variability', new THREE.Float32BufferAttribute(variabilitiesArr, 1));

    const particleMaterial = new THREE.ShaderMaterial({
      uniforms: {
        pointTexture: { value: this.particleImg },
        symbolsTexture: { value: this.symbolsTexture },
        symbolRows: { value: this.symbolTextureRows } // Add dynamic row count uniform
      },
      vertexShader: VERTEX_SHADER,
      fragmentShader: FRAGMENT_SHADER,
      blending: THREE.NormalBlending, 
      depthTest: false, 
      transparent: true, 
    });

    this.particles = new THREE.Points(geoParticles, particleMaterial);
    this.scene.add(this.particles);
    this.geometryCopy = new THREE.BufferGeometry().copy(this.particles.geometry);
    this.initParticleStates(thePoints.length);
   }

  public bindInteractionEvents() {
    this.hostContainer.addEventListener('mousedown', this.boundOnMouseDown);
    this.hostContainer.addEventListener('mousemove', this.boundOnMouseMove);
    document.addEventListener('mouseup', this.boundOnMouseUp); 

    this.hostContainer.addEventListener('touchstart', this.boundOnTouchStart, { passive: false });
    this.hostContainer.addEventListener('touchmove', this.boundOnTouchMove, { passive: false });
    this.hostContainer.addEventListener('touchend', this.boundOnTouchEnd, { passive: false });
    this.isPressed = false;
  }

  public unbindInteractionEvents() {
    this.hostContainer.removeEventListener('mousedown', this.boundOnMouseDown);
    this.hostContainer.removeEventListener('mousemove', this.boundOnMouseMove);
    document.removeEventListener('mouseup', this.boundOnMouseUp);

    this.hostContainer.removeEventListener('touchstart', this.boundOnTouchStart);
    this.hostContainer.removeEventListener('touchmove', this.boundOnTouchMove);
    this.hostContainer.removeEventListener('touchend', this.boundOnTouchEnd);
    
    this.neutralizeLastMousePosition();
  }

  public neutralizeLastMousePosition() {
    this.mouse.set(1e5, 1e5); 
    this.hasMouseMoved = false; 
    this.isPressed = false; 
  }

  private onMouseDown(event: MouseEvent) { this.updateMousePosition(event.clientX, event.clientY); this.isPressed = true; this.data.ease = .01; }
  private onMouseUp() { this.isPressed = false; this.data.ease = .05; }
  private onMouseMove(event: MouseEvent) { 
    if (!this.hasMouseMoved) this.hasMouseMoved = true; 
    this.updateMousePosition(event.clientX, event.clientY); 
  }
  private onTouchStart(event: TouchEvent) { if (event.touches.length > 0) { this.updateMousePosition(event.touches[0].clientX, event.touches[0].clientY); this.isPressed = true; this.data.ease = .01; this.hasMouseMoved = true; } event.preventDefault(); }
  private onTouchMove(event: TouchEvent) { if (event.touches.length > 0) { this.hasMouseMoved = true; this.updateMousePosition(event.touches[0].clientX, event.touches[0].clientY); } event.preventDefault(); }
  private onTouchEnd(event: TouchEvent) { this.isPressed = false; this.data.ease = .05; event.preventDefault(); }
  
  private updateMousePosition(clientX: number, clientY: number) {
    const rect = this.hostContainer.getBoundingClientRect();
    this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
    this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
  }

  private getVariedSymbolColor(): THREE.Color {
    const variedColor = this.bloomSymbolColor.clone(); // Base color: (0.0, 0.95, 0.05)
    const hsl = { h: 0, s: 0, l: 0 };
    variedColor.getHSL(hsl); 

    // HUE VARIATION: Shifts the green tint slightly
    const hueOffset = (Math.random() - 0.5) * this.SYMBOL_HUE_SHIFT_RANGE;
    hsl.h += hueOffset;
    hsl.h = (hsl.h + 1.0) % 1.0; 

    // LUMINANCE VARIATION: Makes some symbols brighter/dimmer
    const luminanceReduction = Math.random() * this.SYMBOL_LUMINANCE_REDUCTION_MAX;
    hsl.l -= luminanceReduction;
    
    // Ensure minimum brightness
    hsl.l = Math.max(this.SYMBOL_MIN_LUMINANCE_TARGET, hsl.l);
    hsl.l = Math.min(1.0, hsl.l);

    variedColor.setHSL(hsl.h, hsl.s, hsl.l); 
    return variedColor;
  }

  public render() {
    if (!this.particles || !this.planeArea || !this.camera) return; 

    if (!this.hasMouseMoved && !this.isPressed) {
        if (this.particles && this.geometryCopy) {
            const pos = this.particles.geometry.attributes.position as THREE.BufferAttribute;
            const copyPos = this.geometryCopy.attributes.position as THREE.BufferAttribute;
            let changed = false;
            for (let i = 0, l = pos.count; i < l; i++) {
                const initX = copyPos.getX(i); const initY = copyPos.getY(i); const initZ = copyPos.getZ(i);
                let px = pos.getX(i); let py = pos.getY(i); let pz = pos.getZ(i);
                const prevPx = px; const prevPy = py; const prevPz = pz;

                px += (initX - px) * this.data.ease; 
                py += (initY - py) * this.data.ease; 
                pz += (initZ - pz) * this.data.ease;
                pos.setXYZ(i, px, py, pz);
                if (px !== prevPx || py !== prevPy || pz !== prevPz) changed = true;
            }
            if (changed) pos.needsUpdate = true;
        }
        return; 
    }

    this.raycaster.setFromCamera(this.mouse, this.camera);
    const intersects = this.raycaster.intersectObject(this.planeArea);

    let attributesNeedUpdate = false;

    if (intersects.length > 0) {
      const pos = this.particles.geometry.attributes.position as THREE.BufferAttribute;
      const copyPos = this.geometryCopy.attributes.position as THREE.BufferAttribute;
      const colors = this.particles.geometry.attributes.customColor as THREE.BufferAttribute;
      const sizes = this.particles.geometry.attributes.size as THREE.BufferAttribute;
      const symbolStates = this.particles.geometry.attributes.symbolState as THREE.BufferAttribute;
      const symbolIndicesBuffer = this.particles.geometry.attributes.symbolIndex as THREE.BufferAttribute;

      const mx = intersects[0].point.x;
      const my = intersects[0].point.y;

      for (let i = 0, l = pos.count; i < l; i++) {
        const initX = copyPos.getX(i); const initY = copyPos.getY(i); const initZ = copyPos.getZ(i);
        let px = pos.getX(i); let py = pos.getY(i); let pz = pos.getZ(i);

        const dx = mx - px; const dy = my - py;
        const mouseDistance = Math.sqrt(dx * dx + dy * dy);
        const dSquared = Math.max(1e-5, dx * dx + dy * dy); 
        const f = -this.data.area / dSquared;

        if (this.isPressed) {
          const t = Math.atan2(dy, dx);
          px -= f * Math.cos(t); py -= f * Math.sin(t);
          this.heatLevels[i] = Math.min(this.heatLevels[i] + 0.1, 1.0);
          attributesNeedUpdate = true;
        } else if (mouseDistance < this.data.area) {
          const t = Math.atan2(dy, dx);
          px += f * Math.cos(t); py += f * Math.sin(t);
          attributesNeedUpdate = true;
          const distortion = Math.sqrt(Math.pow(px - initX, 2) + Math.pow(py - initY, 2));
          
          if (distortion > this.data.distortionThreshold) {
            this.heatLevels[i] = Math.min(this.heatLevels[i] + Math.min(distortion / 50, 0.1), 1.0);
            if (this.particleStates[i] === 0 && this.heatLevels[i] > this.data.symbolHeatRequirement) {
              if (Math.random() < this.getSymbolProbability(distortion)) {
                this.particleStates[i] = 1; 
                symbolStates.setX(i, 1.0);
                
                // FIXED: Generate random size and symbol index each time a particle becomes a symbol
                const randomSymbolSize = this.data.minSymbolSize + Math.random() * (this.data.maxSymbolSize - this.data.minSymbolSize);
                const randomSymbolIndex = Math.floor(Math.random() * this.matrixSymbols.length);
                
                sizes.setX(i, this.data.particleSize * randomSymbolSize);
                symbolIndicesBuffer.setX(i, randomSymbolIndex);
                
                const symbolColorToRender = this.getVariedSymbolColor();
                colors.setXYZ(i, symbolColorToRender.r, symbolColorToRender.g, symbolColorToRender.b);
                attributesNeedUpdate = true; 
              }
            }
          }
        }

        if (this.particleStates[i] === 1) { 
          const currentSize = sizes.getX(i);
          const newSize = Math.max(this.data.particleSize, currentSize - this.fadeOutRates[i]);
          if (currentSize !== newSize) {
             sizes.setX(i, newSize);
             attributesNeedUpdate = true;
          }
          // --- MODIFIED Symbol Cooldown ---
          this.heatLevels[i] = Math.max(0, this.heatLevels[i] - (this.cooldownRates[i] * this.data.symbolCooldownSpeedMultiplier));
          // --- END MODIFIED ---
          
          // FIXED: Use a small tolerance instead of exact comparison to handle floating point precision
          const fadeThreshold = this.data.particleSize + 0.01; // Small tolerance for floating point comparison
          if (newSize <= fadeThreshold) {
            this.particleStates[i] = 0; 
            symbolStates.setX(i, 0.0);
            sizes.setX(i, this.data.particleSize); 
            attributesNeedUpdate = true;
          }
        } else { 
          const matrixColor = this.getMatrixColor(this.heatLevels[i]);
          if (colors.getX(i) !== matrixColor.r || colors.getY(i) !== matrixColor.g || colors.getZ(i) !== matrixColor.b) {
            colors.setXYZ(i, matrixColor.r, matrixColor.g, matrixColor.b);
            attributesNeedUpdate = true;
          }
        }
        
        if (this.heatLevels[i] > 0 && this.particleStates[i] === 0) { // For normal particles
          this.heatLevels[i] = Math.max(0, this.heatLevels[i] - this.cooldownRates[i]);
        }

        const prevPx = px; const prevPy = py; const prevPz = pz;
        px += (initX - px) * this.data.ease; 
        py += (initY - py) * this.data.ease; 
        pz += (initZ - pz) * this.data.ease;
        
        if (px !== prevPx || py !== prevPy || pz !== prevPz) {
            pos.setXYZ(i, px, py, pz);
            attributesNeedUpdate = true;
        }
      }
    } else { 
        const pos = this.particles.geometry.attributes.position as THREE.BufferAttribute;
        const copyPos = this.geometryCopy.attributes.position as THREE.BufferAttribute;
        for (let i = 0, l = pos.count; i < l; i++) {
            const initX = copyPos.getX(i); const initY = copyPos.getY(i); const initZ = copyPos.getZ(i);
            let px = pos.getX(i); let py = pos.getY(i); let pz = pos.getZ(i);
            const prevPx = px; const prevPy = py; const prevPz = pz;
            px += (initX - px) * this.data.ease; 
            py += (initY - py) * this.data.ease; 
            pz += (initZ - pz) * this.data.ease;
            if (px !== prevPx || py !== prevPy || pz !== prevPz) {
                pos.setXYZ(i, px, py, pz);
                attributesNeedUpdate = true;
            }
        }
    }
    
    if (attributesNeedUpdate) {
        (this.particles.geometry.attributes.position as THREE.BufferAttribute).needsUpdate = true;
        (this.particles.geometry.attributes.customColor as THREE.BufferAttribute).needsUpdate = true;
        (this.particles.geometry.attributes.size as THREE.BufferAttribute).needsUpdate = true;
        (this.particles.geometry.attributes.symbolState as THREE.BufferAttribute).needsUpdate = true;
        (this.particles.geometry.attributes.symbolIndex as THREE.BufferAttribute).needsUpdate = true;
    }
  }
  
  public resetParticleState() {
    if (!this.particles || !this.particles.geometry) return;
    
    const colors = this.particles.geometry.attributes.customColor as THREE.BufferAttribute;
    const sizes = this.particles.geometry.attributes.size as THREE.BufferAttribute;
    const symbolStates = this.particles.geometry.attributes.symbolState as THREE.BufferAttribute;
    const symbolIndicesBuffer = this.particles.geometry.attributes.symbolIndex as THREE.BufferAttribute;

    if (!colors || !sizes || !symbolStates || !symbolIndicesBuffer) return;

    const initialColor = this.matrixColors.white;

    for (let i = 0; i < colors.count; i++) {
      colors.setXYZ(i, initialColor.r, initialColor.g, initialColor.b); 
      this.particleStates[i] = 0; 
      this.heatLevels[i] = 0; 
      sizes.setX(i, this.data.particleSize); 
      symbolStates.setX(i, 0.0); 
      
      // Generate fresh random symbol indices
      this.symbolIndicesAttributeValues[i] = Math.floor(Math.random() * this.matrixSymbols.length);
      symbolIndicesBuffer.setX(i, this.symbolIndicesAttributeValues[i]);

      // Generate fresh random fade out rates
      this.fadeOutRates[i] = this.data.minFadeOutRate + Math.random() * (this.data.maxFadeOutRate - this.data.minFadeOutRate);
      // Don't pre-calculate symbol sizes anymore - they're generated when particles become symbols
    }
    colors.needsUpdate = true; sizes.needsUpdate = true; 
    symbolStates.needsUpdate = true; symbolIndicesBuffer.needsUpdate = true;
  }

  private visibleHeightAtZDepth(depth: number, camera: THREE.PerspectiveCamera): number {
    const cameraOffset = camera.position.z;
    const relativeDepth = depth - cameraOffset; 
    const vFOV = camera.fov * Math.PI / 180; 
    return 2 * Math.tan(vFOV / 2) * Math.abs(relativeDepth);
  }
  private visibleWidthAtZDepth(depth: number, camera: THREE.PerspectiveCamera): number {
    return this.visibleHeightAtZDepth(depth, camera) * camera.aspect;
  }

  // Responsive design methods
  private getScreenSizeType(): ScreenSizeType {
    const width = this.hostContainer.clientWidth;
    
    if (width <= this.SCREEN_SIZES.mobile.maxWidth) {
      return 'mobile';
    } else if (width >= this.SCREEN_SIZES.tablet.minWidth && width <= this.SCREEN_SIZES.tablet.maxWidth) {
      return 'tablet';
    } else if (width >= this.SCREEN_SIZES.laptop.minWidth && width <= this.SCREEN_SIZES.laptop.maxWidth) {
      return 'laptop';
    } else if (width >= this.SCREEN_SIZES.desktop.minWidth && width <= this.SCREEN_SIZES.desktop.maxWidth) {
      return 'desktop';
    } else if (width >= this.SCREEN_SIZES.large.minWidth && width <= this.SCREEN_SIZES.large.maxWidth) {
      return 'large';
    } else {
      return 'ultrawide';
    }
  }
  private applyResponsiveParameters(screenType: ScreenSizeType): void {
    const params = this.RESPONSIVE_PARAMS[screenType];
    
    // Apply the responsive parameters to the data object
    if (params.amount !== undefined) this.data.amount = params.amount;
    if (params.particleSize !== undefined) this.data.particleSize = params.particleSize;
    if (params.textSize !== undefined) this.data.textSize = params.textSize;
    if (params.minSymbolSize !== undefined) this.data.minSymbolSize = params.minSymbolSize;
    if (params.maxSymbolSize !== undefined) this.data.maxSymbolSize = params.maxSymbolSize;
    if (params.area !== undefined) this.data.area = params.area;
  }

  public checkScreenSizeChange(): boolean {
    const currentWidth = this.hostContainer.clientWidth;
    const currentHeight = this.hostContainer.clientHeight;
    
    // Check if dimensions have changed significantly (more than 10% or 100px)
    const widthChange = Math.abs(currentWidth - this.lastKnownWidth);
    const heightChange = Math.abs(currentHeight - this.lastKnownHeight);
    const significantChange = widthChange > 100 || heightChange > 100 || 
                             widthChange / this.lastKnownWidth > 0.1 || 
                             heightChange / this.lastKnownHeight > 0.1;
    
    if (significantChange) {
      const newScreenType = this.getScreenSizeType();
      
      if (newScreenType !== this.currentScreenSizeType) {
        console.log(`🖥️ Screen size change detected: ${this.currentScreenSizeType} → ${newScreenType}`);
        this.currentScreenSizeType = newScreenType;
        this.applyResponsiveParameters(newScreenType);
        this.lastKnownWidth = currentWidth;
        this.lastKnownHeight = currentHeight;
        this.needsParticleRegeneration = true;
        return true;
      }
    }
    
    return false;
  }

  public regenerateParticles(): void {
    if (!this.needsParticleRegeneration) return;
    
    console.log(`🔄 Regenerating particles for ${this.currentScreenSizeType} screen size:`);
    console.log(`   New particle count: ${this.data.amount}`);
    console.log(`   New particle size: ${this.data.particleSize}`);
    
    // Remove existing particles
    if (this.particles) {
      this.scene.remove(this.particles);
      this.particles.geometry.dispose();
      const material = this.particles.material as THREE.Material;
      if (material) material.dispose();
    }
    
    // Recreate particles with new parameters
    this.createText();
    
    this.needsParticleRegeneration = false;
  }
  
  public dispose() {
    this.unbindInteractionEvents();
    if (this.particles) {
      this.scene.remove(this.particles);
      this.particles.geometry.dispose();
      const material = this.particles.material as THREE.Material | THREE.Material[];
      if (Array.isArray(material)) {
        material.forEach(m => m.dispose());
      } else {
        material.dispose();
      }
    }
    if (this.geometryCopy) this.geometryCopy.dispose();
    if (this.symbolsTexture) this.symbolsTexture.dispose();
    if (this.planeArea) {
      this.scene.remove(this.planeArea);
      this.planeArea.geometry.dispose();
      const material = this.planeArea.material as THREE.Material | THREE.Material[];
      if (Array.isArray(material)) {
         material.forEach(m => m.dispose());
      } else {
        (material as THREE.Material).dispose();
      }
    }
  }
}
--- END OF FILE src\lib\three\heroParticleLogic.ts ---

--- START OF FILE src\routes\+layout.svelte ---
<!-- src/routes/+layout.svelte -->
<script lang="ts">
  import '../app.css'; // Import global styles for keyboard buttons etc.
</script>

<slot />
--- END OF FILE src\routes\+layout.svelte ---

--- START OF FILE src\routes\+page.svelte ---
<!-- src/routes/+page.svelte -->
<script lang="ts">
  import { onMount, onDestroy, tick } from 'svelte';
  import { writable, get } from 'svelte/store';
  import { siteConfig } from '$lib/data/siteConfig';
  import { projects, type Project } from '$lib/data/projectsData';
  import { overallLoadingState, initialSiteLoadComplete, preloadingStore, startLoadingTask, preloadAssets } from '$lib/stores/preloadingStore';
  import { gsap } from 'gsap';

  // Component Imports
  import LoadingScreen from '$lib/components/LoadingScreen.svelte';
  import HeroSection from '$lib/components/sections/HeroSection.svelte';
  import AboutSection from '$lib/components/sections/AboutSection.svelte';
  import ProjectOneSection from '$lib/components/sections/ProjectOneSection.svelte';
  import ProjectTwoSection from '$lib/components/sections/ProjectTwoSection.svelte';
  import ContactSection from '$lib/components/sections/ContactSection.svelte';

  // Type Imports
  interface IAnimatedComponent {
    onEnterSection: () => void;
    onLeaveSection: () => void;
    initializeEffect?: () => Promise<void>;
    // Add the new optional lifecycle hook
    onTransitionComplete?: () => void;
  }
  import type { HeroSectionInstance } from '$lib/components/sections/HeroSection.svelte';

  // Section Data
  const allSectionsData = [
    { id: 'hero', component: HeroSection, data: siteConfig.heroSection },
    { id: 'about', component: AboutSection, data: siteConfig.aboutSection },
    { id: `project-${projects[0].id}`, component: ProjectOneSection, data: projects[0] },
    { id: `project-${projects[1].id}`, component: ProjectTwoSection, data: projects[1] },
    { id: 'contact', component: ContactSection, data: siteConfig.contactSection }
  ];
  const contactSectionIndex = allSectionsData.findIndex(s => s.id === 'contact');

  // Instance Management
  let heroSectionInstance: HeroSectionInstance | null = null;
  let sectionInstancesArray: (IAnimatedComponent | null)[] = new Array(allSectionsData.length).fill(null);
  let sectionInstances = new Map<string, IAnimatedComponent>();
  $: if (heroSectionInstance) {
    sectionInstancesArray[0] = heroSectionInstance;
    const newMap = new Map<string, IAnimatedComponent>();
    allSectionsData.forEach((section, index) => {
      const instance = sectionInstancesArray[index];
      if (instance) newMap.set(section.id, instance);
    });
    sectionInstances = newMap;
  }
  
  // Core State
  const isAnimating = writable(false);
  const currentSectionIndex = writable(0);
  const isTransitioning = writable(false);
  const isInitialReveal = writable(true);
  const particleEffectReady = writable(false);

  // Page & Animation State
  let visibilityHideTimeoutId: number | undefined;
  let isTabHiddenAndPaused = false;
  const HIDE_BUFFER_DURATION = 15000;
  let sectionElements: HTMLElement[] = [];
  let sectionBackgroundZooms: (gsap.core.Tween | null)[] = [];
  const transitionDuration = 1.1;
  const projectBgZoomDuration = 3;
  const minSectionDisplayDuration = 1.2;
  const initialRevealDelay = 300;
  const particleFadeInDuration = 1.5;
  let unsubOverallLoadingState: (() => void) | undefined;
  let unsubInitialLoadComplete: (() => void) | undefined;
  let hasStartedInitialReveal = false;
  
  let particleLayerPointerEvents = 'none';
  $: particleLayerPointerEvents = ($currentSectionIndex === 0 && !$isInitialReveal) ? 'auto' : 'none';
  let mainContainerPointerEvents = 'auto';
  $: mainContainerPointerEvents = ($currentSectionIndex === 0 || $isInitialReveal) ? 'none' : 'auto';

  // --- "Patient" Preload Manager ---
  const preloadManager = {
    isPrewarming: false,
    preparedIndexes: new Set<number>(),
    
    getSectionAssetUrls(index: number): string[] {
      if (index < 0 || index >= allSectionsData.length) return [];
      const section = allSectionsData[index];
      let urls: string[] = [];
      if (section.id === 'about') {
        urls.push((section.data as typeof siteConfig.aboutSection).imageUrl);
      } else if (section.id.startsWith('project-')) {
        const p = section.data as Project;
        urls.push(p.background.value);
        p.cards.forEach(card => urls.push(card.image));
      }
      return urls.filter(Boolean);
    },

    preWarmGpuLayers(sectionElement: HTMLElement | undefined) {
      if (this.isPrewarming || !sectionElement) return;
      this.isPrewarming = true;
      setTimeout(() => {
        const targets = sectionElement.querySelectorAll('.gpu-prewarm-target');
        if (targets.length === 0) {
          this.isPrewarming = false;
          return;
        }
        gsap.set(targets, {
          autoAlpha: 0.001,
          stagger: 0.05,
          onComplete: () => {
            gsap.set(targets, { autoAlpha: 0 });
            this.isPrewarming = false;
          }
        });
      }, 100);
    },
    
    async initializeAndPreWarm(index: number) {
      if (index < 0 || index >= allSectionsData.length || this.preparedIndexes.has(index)) return;
      
      const instance = sectionInstances.get(allSectionsData[index].id);
      if (instance?.initializeEffect) {
        await instance.initializeEffect();
      }
      
      const targetSectionElement = sectionElements[index];
      this.preWarmGpuLayers(targetSectionElement);
      this.preparedIndexes.add(index);
    },

    async prepareSection(index: number) {
      if (index < 0 || index >= allSectionsData.length || this.preparedIndexes.has(index)) return;
      
      const urls = this.getSectionAssetUrls(index);
      if (urls.length > 0) {
        await preloadAssets(urls);
      }
      
      await this.initializeAndPreWarm(index);
    },
  };

  function handleAnimationComplete() {
    const nextIndex = get(currentSectionIndex) + 1;
    preloadManager.prepareSection(nextIndex);
  }

  function handleVisibilityChange() {
    const currentIndex = get(currentSectionIndex);
    const currentInstance = sectionInstances.get(allSectionsData[currentIndex].id);
    if (document.hidden) {
      visibilityHideTimeoutId = window.setTimeout(() => {
        if (document.hidden && !isTabHiddenAndPaused) {
          currentInstance?.onLeaveSection();
          isTabHiddenAndPaused = true;
        }
      }, HIDE_BUFFER_DURATION);
    } else {
      clearTimeout(visibilityHideTimeoutId);
      if (isTabHiddenAndPaused) {
        currentInstance?.onEnterSection();
        requestAnimationFrame(() => {
          currentInstance?.onTransitionComplete?.();
        });
        isTabHiddenAndPaused = false;
        handleAnimationComplete();
      }
    }
  }

  onMount(() => {
    const setup = async () => {
      startLoadingTask('initialAssets', 2);
      await preloadAssets(preloadManager.getSectionAssetUrls(1));
      preloadingStore.updateTaskStatus('initialAssets', 'loaded');

      await tick();
      
      sectionElements = allSectionsData.map(section => document.getElementById(section.id) as HTMLElement);
      if (sectionElements.some(el => !el)) return;
      
      sectionElements.forEach((sectionEl, index) => {
        const bgTarget = sectionEl.querySelector('.background-image-container') as HTMLElement;
        sectionBackgroundZooms[index] = bgTarget ? gsap.to(bgTarget, { scale: 1.05, duration: projectBgZoomDuration, ease: 'power1.out', paused: true }) : null;
        gsap.set(sectionEl, { yPercent: index === 0 ? 0 : 100, autoAlpha: index === 0 ? 1 : 0 });
      });
      
      window.addEventListener('wheel', handleWheel, { passive: false });
      window.addEventListener('keydown', handleKeyDown);
      document.addEventListener('visibilitychange', handleVisibilityChange);
    };
    
    unsubOverallLoadingState = overallLoadingState.subscribe(status => { if (status === 'loaded' && !get(initialSiteLoadComplete)) { setTimeout(() => { initialSiteLoadComplete.set(true); if (get(particleEffectReady) && !hasStartedInitialReveal) startInitialReveal(); }, 100); }});
    unsubInitialLoadComplete = initialSiteLoadComplete.subscribe(complete => { if (complete && get(particleEffectReady) && !hasStartedInitialReveal) startInitialReveal(); });
    
    setup();

    return () => { /* ... cleanup ... */ };
  });

  function startInitialReveal() {
    if (hasStartedInitialReveal) return;
    hasStartedInitialReveal = true;
    setTimeout(() => {
      if (heroSectionInstance) {
        heroSectionInstance.onTransitionToHeroComplete();
        preloadManager.prepareSection(1);
      }
      setTimeout(() => { isInitialReveal.set(false); }, particleFadeInDuration * 1000);
    }, initialRevealDelay);
  }
  
  function navigateToSection(newIndex: number) { 
    if (get(isInitialReveal)) return; 
    const oldIndex = get(currentSectionIndex); 
    if (get(isAnimating) || newIndex === oldIndex || newIndex < 0 || newIndex >= sectionElements.length) return; 
    
    isAnimating.set(true); 
    isTransitioning.set(true); 

    const oldInstance = sectionInstances.get(allSectionsData[oldIndex].id);
    const newInstance = sectionInstances.get(allSectionsData[newIndex].id);
    
    oldInstance?.onLeaveSection();
    sectionBackgroundZooms[oldIndex]?.progress(0).pause(); 
    newInstance?.onEnterSection();

    const currentSectionEl = sectionElements[oldIndex]; 
    const targetSectionEl = sectionElements[newIndex]; 
    const direction = newIndex > oldIndex ? 1 : -1; 
    
    const masterTransitionTl = gsap.timeline({ 
      onComplete: () => { 
        currentSectionIndex.set(newIndex); 
        isTransitioning.set(false);
        sectionBackgroundZooms[newIndex]?.restart();
        
        // FIX: Defer the heavy onTransitionComplete call until the next animation frame.
        requestAnimationFrame(() => {
          newInstance?.onTransitionComplete?.();
        });

        if (allSectionsData[newIndex].id === 'hero' && heroSectionInstance) {
           heroSectionInstance.onTransitionToHeroComplete();
        }
      } 
    }); 
    
    gsap.set(targetSectionEl, { yPercent: direction * 100, autoAlpha: 1 }); 
    masterTransitionTl.to(currentSectionEl, { yPercent: -direction * 100, autoAlpha: 0, duration: transitionDuration, ease: 'expo.out' }, "slide"); 
    masterTransitionTl.to(targetSectionEl, { yPercent: 0, duration: transitionDuration, ease: 'expo.out' }, "slide"); 
    
    gsap.delayedCall(Math.max(transitionDuration, minSectionDisplayDuration), () => { 
      isAnimating.set(false); 
    }); 
  }

  let lastScrollTime = 0;
  const scrollDebounce = 200;
  function handleWheel(event: WheelEvent) { event.preventDefault(); if (get(isInitialReveal)) return; const currentTime = Date.now(); if (currentTime - lastScrollTime < scrollDebounce || get(isAnimating)) return; lastScrollTime = currentTime; navigateToSection(get(currentSectionIndex) + (event.deltaY > 0 ? 1 : -1)); }
  function handleKeyDown(event: KeyboardEvent) { if (get(isInitialReveal) || get(isAnimating)) { if (['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', ' ', 'Home', 'End'].includes(event.key)) event.preventDefault(); return; } const currentTime = Date.now(); if (currentTime - lastScrollTime < scrollDebounce) { if (['ArrowUp', 'ArrowDown', 'PageUp', 'PageDown', ' ', 'Home', 'End'].includes(event.key)) event.preventDefault(); return; } let newIndex = get(currentSectionIndex); let shouldScroll = false; switch (event.key) { case 'ArrowDown': case 'PageDown': case ' ': newIndex++; shouldScroll = true; break; case 'ArrowUp': case 'PageUp': newIndex--; shouldScroll = true; break; case 'Home': newIndex = 0; shouldScroll = true; break; case 'End': newIndex = sectionElements.length - 1; shouldScroll = true; break; } if (shouldScroll && newIndex !== get(currentSectionIndex)) { event.preventDefault(); lastScrollTime = currentTime; navigateToSection(newIndex); } }
  function onParticleEffectReady() { particleEffectReady.set(true); }
</script>

<svelte:head>
  <title>{siteConfig.title}</title>
  <meta name="description" content={siteConfig.description} />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous">
  <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&display=swap" rel="stylesheet">
</svelte:head>

<div>
  <LoadingScreen /> 

  <div class="particle-effect-layer" class:initial-state={$isInitialReveal} style="pointer-events: {particleLayerPointerEvents};">
    <HeroSection
      bind:this={heroSectionInstance}
      activeSectionIndex={$currentSectionIndex}
      isTransitioning={$isTransitioning}
      {transitionDuration}
      isInitialLoad={$isInitialReveal}
      on:ready={onParticleEffectReady}
    />
  </div>

  <main class="portfolio-container" style="pointer-events: {mainContainerPointerEvents};">
    <section id="hero" class="full-screen-section hero-section-container"></section>

    {#each allSectionsData.slice(1) as section, i (section.id)}
      <section 
        id={section.id} 
        class="full-screen-section"
      >
        {#if section.id === 'about'}
          <AboutSection
            bind:this={sectionInstancesArray[i + 1]}
            data={section.data as typeof siteConfig.aboutSection}
            {contactSectionIndex}
            {navigateToSection}
            on:animationComplete={handleAnimationComplete}
          />
        {:else if section.id === `project-${projects[0].id}`}
          <ProjectOneSection
            bind:this={sectionInstancesArray[i + 1]}
            project={section.data as Project}
            on:animationComplete={handleAnimationComplete}
          />
        {:else if section.id === `project-${projects[1].id}`}
          <ProjectTwoSection
            bind:this={sectionInstancesArray[i + 1]}
            project={section.data as Project}
            on:animationComplete={handleAnimationComplete}
          />
        {:else if section.id === 'contact'}
          <ContactSection
            bind:this={sectionInstancesArray[i + 1]}
            data={section.data as typeof siteConfig.contactSection}
            on:animationComplete={handleAnimationComplete}
          />
        {/if}
      </section>
    {/each}
  </main>

  <style>
    :global(body) { background-color: rgb(9 9 11); color: rgb(245 245 247); }
    .particle-effect-layer { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; background-color: rgb(9 9 11); transition: opacity 1.5s cubic-bezier(0.4, 0, 0.2, 1); }
    .particle-effect-layer.initial-state { background-color: rgb(5 8 5); }
    .portfolio-container { position: relative; width: 100%; height: 100vh; overflow: hidden; z-index: 1; }
    
    .full-screen-section {
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      box-sizing: border-box;
      background-color: transparent; 
    }

    .hero-section-container {
      pointer-events: none;
    }
    
    * { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
  </style>
</div>
--- END OF FILE src\routes\+page.svelte ---

--- START OF FILE src\routes\projects\[slug]\+layout.svelte ---
<!-- src/routes/projects/[slug]/+layout.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { goto } from '$app/navigation';
  import { ArrowLeft } from 'lucide-svelte'; // A nice icon library for the back button

  let showButton = false;

  onMount(() => {
    // A slight delay ensures the button fades in after the page transition starts
    const timer = setTimeout(() => {
      showButton = true;
    }, 300);

    return () => clearTimeout(timer);
  });
</script>

<div class="project-subpage-layout">
  <button 
    class="back-button"
    class:visible={showButton}
    on:click={() => goto('/')}
    aria-label="Back to home"
  >
    <ArrowLeft size={24} />
  </button>

  <!-- The content of +page.svelte will be rendered here -->
  <slot />
</div>

<style>
  .project-subpage-layout {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .back-button {
    position: fixed;
    top: 2rem;
    left: 2rem;
    z-index: 1000; /* Ensure it's on top of all page content */
    
    background-color: rgba(30, 30, 32, 0.7);
    border: 1px solid rgba(255, 255, 255, 0.1);
    color: white;
    backdrop-filter: blur(8px);
    
    width: 3rem;
    height: 3rem;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    
    cursor: pointer;
    transition: all 0.3s ease-in-out;
    
    opacity: 0;
    transform: scale(0.8);
    pointer-events: none;
  }

  .back-button.visible {
    opacity: 1;
    transform: scale(1);
    pointer-events: auto;
  }

  .back-button:hover {
    background-color: rgba(50, 50, 52, 0.9);
    transform: scale(1.05);
  }

  /* Add lucide-svelte to your dev dependencies if you don't have it: npm install -D lucide-svelte */
</style>
--- END OF FILE src\routes\projects\[slug]\+layout.svelte ---

--- START OF FILE src\routes\projects\[slug]\+page.svelte ---
<!-- src/routes/projects/[slug]/+page.svelte -->
<script lang="ts">
  import { onMount, tick } from 'svelte';
  import { get, writable } from 'svelte/store';
  import { page } from '$app/stores';
  import { gsap } from 'gsap';
  import { siteConfig } from '$lib/data/siteConfig';
  // FIX: Import the new generic preloadAssets and task management functions
  import { preloadingStore, startLoadingTask, preloadAssets } from '$lib/stores/preloadingStore';

  export let data;
  const { project } = data;

  // A unique task ID for this project's assets
  const PROJECT_ASSETS_TASK_ID = `project-assets-${project.slug}`;

  // A writable store to track when content for this specific page is ready.
  const isContentLoaded = writable(false);

  const allSubSections = [
    { 
      id: 'overview', 
      title: project.headline,
      content: project.summary,
      background: project.background
    },
    ...project.subPageSections
  ];

  let sectionElements: HTMLElement[] = [];
  let sectionContentTimelines: (gsap.core.Timeline | null)[] = [];
  let sectionBackgroundZooms: (gsap.core.Tween | null)[] = [];

  let currentSectionIndex = 0;
  let isAnimating = false;
  let lastScrollTime = 0;
  const scrollDebounce = 200;
  const transitionDuration = 1.1;

  onMount(() => {
    // FIX: Use the new centralized preloading system.
    const runPreload = async () => {
      // Register the task with the global preloading store.
      startLoadingTask(PROJECT_ASSETS_TASK_ID, 2);

      const assetUrls = allSubSections
        .filter(s => s.background.type === 'image')
        .map(s => s.background.value);
      
      try {
        await preloadAssets(assetUrls);
        preloadingStore.updateTaskStatus(PROJECT_ASSETS_TASK_ID, 'loaded');
        console.log(`All assets for project '${project.slug}' preloaded successfully.`);
      } catch (error) {
        console.error(error);
        preloadingStore.updateTaskStatus(PROJECT_ASSETS_TASK_ID, 'error', (error as Error).message);
      } finally {
        // Once preloading is complete (success or fail), mark content as ready to be shown.
        isContentLoaded.set(true);
      }
    };
    
    runPreload();

    return () => {
      window.removeEventListener('wheel', handleWheel);
      window.removeEventListener('keydown', handleKeyDown);
      sectionContentTimelines.forEach(timeline => { timeline?.kill(); });
      sectionBackgroundZooms.forEach(tween => { tween?.kill(); });
    };
  });

  // This reactive block ensures animation setup only runs *after* assets are loaded.
  $: if ($isContentLoaded) {
    setupAnimations();
  }

  async function setupAnimations() {
      await tick();

      sectionElements = allSubSections.map(section => document.getElementById(section.id) as HTMLElement);
      
      const urlHash = get(page).url.hash;
      const cleanHash = urlHash.startsWith('#') ? urlHash.substring(1) : null;
      
      let initialIndex = 0;
      if (cleanHash) {
        const foundIndex = allSubSections.findIndex(s => s.id === cleanHash);
        if (foundIndex !== -1) {
          initialIndex = foundIndex;
        }
      }
      currentSectionIndex = initialIndex;

      sectionElements.forEach((sectionEl, index) => {
        const contentTl = gsap.timeline({ paused: true });
        const contentOverlay = sectionEl.querySelector('.subpage-content-overlay');
        const h2El = sectionEl.querySelector('h2');
        const pEl = sectionEl.querySelector('p');

        if (contentOverlay) {
          contentTl.fromTo(contentOverlay, { autoAlpha: 0, scale: 0.95 }, { autoAlpha: 1, scale: 1, duration: 0.7, ease: 'power2.out' }, "start");
        }
        if (h2El) {
          contentTl.fromTo(h2El, { autoAlpha: 0, y: 30 }, { autoAlpha: 1, y: 0, duration: 0.8, ease: 'power2.out' }, "start+=0.2");
        }
        if (pEl) {
          contentTl.fromTo(pEl, { autoAlpha: 0, y: 20 }, { autoAlpha: 1, y: 0, duration: 0.7, ease: 'power2.out' }, "start+=0.35");
        }
        sectionContentTimelines[index] = contentTl;
        
        const bgTarget = sectionEl.querySelector('.subpage-background-image') as HTMLElement;
        if (bgTarget) {
          sectionBackgroundZooms[index] = gsap.to(bgTarget, { scale: 1.05, duration: 3, ease: 'power1.out', paused: true });
        }
      });

      sectionElements.forEach((el, index) => {
        if (index === initialIndex) {
          gsap.set(el, { yPercent: 0, autoAlpha: 1 });
          sectionContentTimelines[index]?.restart();
          sectionBackgroundZooms[index]?.restart();
        } else {
          gsap.set(el, { yPercent: 100, autoAlpha: 0 });
        }
      });

      window.addEventListener('wheel', handleWheel, { passive: false });
      window.addEventListener('keydown', handleKeyDown);
  }

  function navigateToSection(newIndex: number) {
    const oldIndex = currentSectionIndex;
    if (isAnimating || newIndex === oldIndex || newIndex < 0 || newIndex >= sectionElements.length) return;
    
    isAnimating = true;

    const currentSectionEl = sectionElements[oldIndex];
    const targetSectionEl = sectionElements[newIndex];
    const direction = newIndex > oldIndex ? 1 : -1;

    sectionContentTimelines[oldIndex]?.progress(0).pause();
    sectionBackgroundZooms[oldIndex]?.progress(0).pause();

    gsap.set(targetSectionEl, { yPercent: direction * 100, autoAlpha: 1 });

    const masterTl = gsap.timeline({
      onComplete: () => {
        isAnimating = false;
        currentSectionIndex = newIndex;
      }
    });

    masterTl.to(currentSectionEl, { yPercent: -direction * 100, autoAlpha: 0, duration: transitionDuration, ease: 'expo.out' }, "slide");
    masterTl.to(targetSectionEl, { yPercent: 0, duration: transitionDuration, ease: 'expo.out' }, "slide");
    
    masterTl.call(() => { sectionContentTimelines[newIndex]?.restart(); }, [], `slide+=${transitionDuration * 0.3}`);
    masterTl.call(() => { sectionBackgroundZooms[newIndex]?.restart(); }, [], `slide+=${transitionDuration * 0.1}`);
  }

  function handleWheel(event: WheelEvent) {
    event.preventDefault();
    const currentTime = Date.now();
    if (currentTime - lastScrollTime < scrollDebounce || isAnimating) return;
    lastScrollTime = currentTime;
    navigateToSection(currentSectionIndex + (event.deltaY > 0 ? 1 : -1));
  }

  function handleKeyDown(event: KeyboardEvent) {
    if (isAnimating) return;
    let newIndex = currentSectionIndex;
    if (event.key === 'ArrowDown' || event.key === ' ') newIndex++;
    if (event.key === 'ArrowUp') newIndex--;
    navigateToSection(newIndex);
  }

</script>

<svelte:head>
  <title>{project.headline} | {siteConfig.author}</title>
  <meta name="description" content={project.summary} />
</svelte:head>

<div class="subpage-container" class:loaded={$isContentLoaded}>
  {#each allSubSections as section, i (section.id)}
    <section id={section.id} class="subpage-fullscreen-section">
      <div 
        class="subpage-background-image"
        style="background-image: url({section.background.value});"
      ></div>
      
      <div class="subpage-content-overlay">
        <h2>{section.title}</h2>
        <p>{section.content}</p>
      </div>
    </section>
  {/each}
</div>

<style>
  .subpage-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #000;
    overflow: hidden;
    opacity: 0;
    transition: opacity 0.6s ease-in-out;
  }
  
  .subpage-container.loaded {
    opacity: 1;
  }

  .subpage-fullscreen-section {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    padding: 2rem;
    box-sizing: border-box;
  }

  .subpage-background-image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 0;
    transform: scale(1);
  }

  .subpage-content-overlay {
    position: relative;
    z-index: 1;
    max-width: 800px;
    text-align: center;
    padding: 2rem;
    background-color: rgba(9, 9, 11, 0.75);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.1);
    opacity: 0;
  }

  .subpage-content-overlay h2 {
    font-size: clamp(2.2rem, 5vw, 3.5rem);
    font-weight: 700;
    font-family: 'Playfair Display', serif;
    margin-bottom: 1.5rem;
    text-shadow: 0 2px 20px rgba(0,0,0,0.5);
    opacity: 0;
  }

  .subpage-content-overlay p {
    font-size: clamp(1rem, 2.5vw, 1.15rem);
    line-height: 1.8;
    max-width: 700px;
    margin: 0 auto;
    color: #e2e8f0;
    opacity: 0;
  }
</style>
--- END OF FILE src\routes\projects\[slug]\+page.svelte ---

--- START OF FILE src\routes\projects\[slug]\+page.ts ---
// src/routes/projects/[slug]/+page.ts

import { error } from '@sveltejs/kit';
import { projects } from '$lib/data/projectsData';
import type { PageLoad } from './$types';

// FIX: Removed `url` from the function parameters. We only need `params`.
export const load: PageLoad = ({ params }) => {
  const project = projects.find(p => p.slug === params.slug);

  if (!project) {
    throw error(404, 'Project not found');
  }

  // FIX: Only return the project data. The hash will be read on the client.
  return {
    project
  };
};
--- END OF FILE src\routes\projects\[slug]\+page.ts ---

